<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>《TCP/IP详解》读书笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="读第二遍时做笔记的要求：简单的分组格式不要跳过，复杂的分组格式要指明图x-yy，不要跳过例子和习题。  ch01 概述 ch02 链路层 ch03 IP：网际协议 ch04 ARP：地址解析协议 ch05 RARP：逆地址解析协议 ch06 ICMP：Internet控制报文协议 ch07 Ping程序 ch08 Traceroute程序 ch09 IP选路 ch10 动态选路协议 ch11 UD">
<meta property="og:type" content="article">
<meta property="og:title" content="《TCP&#x2F;IP详解》读书笔记">
<meta property="og:url" content="http://example.com/2021/05/09/tcp-ip-xiang-jie/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="读第二遍时做笔记的要求：简单的分组格式不要跳过，复杂的分组格式要指明图x-yy，不要跳过例子和习题。  ch01 概述 ch02 链路层 ch03 IP：网际协议 ch04 ARP：地址解析协议 ch05 RARP：逆地址解析协议 ch06 ICMP：Internet控制报文协议 ch07 Ping程序 ch08 Traceroute程序 ch09 IP选路 ch10 动态选路协议 ch11 UD">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/3/images2/52im_1.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/8/images2/52im_net_9.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/11/images2/52im_net_27.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/11/images2/52im_net_28.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/12/images2/52im_net_7.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/12/images2/52im_net_8.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/13/images2/52im_net_2.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_3.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_8.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_x3.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_x4.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/15/images2/52im_net_1.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/15/images2/52im_net_2.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_2.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_3.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_4.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/images2/52im_net_2.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/images2/52im_net_x1.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_14.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_17.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_32.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_34.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_40.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_43.png">
<meta property="og:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_44.png">
<meta property="article:published_time" content="2021-05-09T06:01:57.000Z">
<meta property="article:modified_time" content="2022-05-11T03:19:10.222Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://docs.52im.net/extend/docs/book/tcpip/vol1/3/images2/52im_1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-tcp-ip-xiang-jie" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/09/tcp-ip-xiang-jie/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T06:01:57.000Z" itemprop="datePublished">2021-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      《TCP/IP详解》读书笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>读第二遍时做笔记的要求：简单的分组格式不要跳过，复杂的分组格式要指明图x-yy，不要跳过例子和习题。</p>
<ul>
<li><a href="#ch01-%E6%A6%82%E8%BF%B0">ch01 概述</a></li>
<li><a href="#ch02-%E9%93%BE%E8%B7%AF%E5%B1%82">ch02 链路层</a></li>
<li><a href="#ch03-IP%EF%BC%9A%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">ch03 IP：网际协议</a></li>
<li><a href="#ch04-ARP%EF%BC%9A%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">ch04 ARP：地址解析协议</a></li>
<li><a href="#ch05-RARP%EF%BC%9A%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">ch05 RARP：逆地址解析协议</a></li>
<li><a href="#ch06-ICMP%EF%BC%9AInternet%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE">ch06 ICMP：Internet控制报文协议</a></li>
<li><a href="#ch07-Ping%E7%A8%8B%E5%BA%8F">ch07 Ping程序</a></li>
<li><a href="#ch08-Traceroute%E7%A8%8B%E5%BA%8F">ch08 Traceroute程序</a></li>
<li><a href="#ch09-IP%E9%80%89%E8%B7%AF">ch09 IP选路</a></li>
<li><a href="#ch10-%E5%8A%A8%E6%80%81%E9%80%89%E8%B7%AF%E5%8D%8F%E8%AE%AE">ch10 动态选路协议</a></li>
<li><a href="#ch11-UDP%EF%BC%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">ch11 UDP：用户数据报协议</a></li>
<li><a href="#ch12-%E5%B9%BF%E6%92%AD%E5%92%8C%E5%A4%9A%E6%92%AD">ch12 广播和多播</a></li>
<li><a href="#ch13-IGMP%EF%BC%9AInternet%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE">ch13 IGMP：Internet组管理协议</a></li>
<li><a href="#ch14-DNS%EF%BC%9A%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">ch14 DNS：域名系统</a></li>
<li><a href="#ch15-TFTP%EF%BC%9A%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">ch15 TFTP：简单文件传送协议</a></li>
<li><a href="#ch16-BOOTP%EF%BC%9A%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%E5%8D%8F%E8%AE%AE">ch16 BOOTP：引导程序协议</a></li>
<li><a href="#ch17-TCP%EF%BC%9A%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">ch17 TCP：传输控制协议</a></li>
<li><a href="#ch18-TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%BB%88%E6%AD%A2">ch18 TCP连接的建立与终止</a></li>
<li><a href="#ch19-TCP%E7%9A%84%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E6%B5%81">ch19 TCP的交互数据流</a></li>
<li><a href="#ch20-TCP%E7%9A%84%E6%88%90%E5%9D%97%E6%95%B0%E6%8D%AE%E6%B5%81">ch20 TCP的成块数据流</a></li>
<li><a href="#ch21-TCP%E7%9A%84%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0">ch21 TCP的超时与重传</a></li>
<li><a href="#ch22-TCP%E7%9A%84%E5%9D%9A%E6%8C%81%E5%AE%9A%E6%97%B6%E5%99%A8">ch22 TCP的坚持定时器</a></li>
<li><a href="#ch23-TCP%E7%9A%84%E4%BF%9D%E6%B4%BB%E5%AE%9A%E6%97%B6%E5%99%A8">ch23 TCP的保活定时器</a></li>
<li><a href="#ch24-TCP%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%92%8C%E6%80%A7%E8%83%BD">ch24 TCP的未来和性能</a></li>
<li><a href="#ch25-SNMP%EF%BC%9A%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE">ch25 SNMP：简单网络管理协议</a></li>
<li><a href="#ch26-Telnet%E5%92%8CRlogin%EF%BC%9A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95">ch26 Telnet和Rlogin：远程登录</a></li>
<li><a href="#ch27-FTP%EF%BC%9A%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">ch27 FTP：文件传送协议</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本书用tcpdump观察TCP/IP协议族的运作过程</p>
<h2 id="本书的组织"><a href="#本书的组织" class="headerlink" title="本书的组织"></a>本书的组织</h2><p>自底向上与功能方法</p>
<h2 id="读者"><a href="#读者" class="headerlink" title="读者"></a>读者</h2><p>具有一定TCP/IP背景知识的读者可以从第7章开始阅读，然后着重阅读感兴趣的某些章节。</p>
<h2 id="用作测试的系统"><a href="#用作测试的系统" class="headerlink" title="用作测试的系统"></a>用作测试的系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">                                                        Internet</span><br><span class="line">                                                           ^</span><br><span class="line">                                                           |</span><br><span class="line">  AIX 3.2.2        Solaris 2.2       SunOS 4.1.1           | .104.1</span><br><span class="line">+-----------+     +-----------+     +-----------+     +----*------+</span><br><span class="line">|    aix    |     |  solaris  |     |  gemini   |     |  gateway  | Cisco路由器</span><br><span class="line">+-----*-----+     +-----*-----+     +-----*-----+     +----*------+</span><br><span class="line">      | .1.92           | .1.32           | .1.11          | .1.4</span><br><span class="line">      |                 |                 |                |</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">                                   以太网                |</span><br><span class="line">                                                         | .1.183</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                   |   netb    | Telebit</span><br><span class="line">                                                   +-----*-----+ NetBlazer</span><br><span class="line">                                                         |</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                   |调制解调器 |</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                         |</span><br><span class="line">                                                   SLIP  |（拨号）</span><br><span class="line">                                                         |</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                   |调制解调器 |</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                         |</span><br><span class="line">                                                         |</span><br><span class="line"> BSD&#x2F;386 1.0                   BSD&#x2F;386 1.0    SunOS 4.1.3| .1.29       SVR4</span><br><span class="line">+-----------+                 +-----------+      +-------*---+     +-----------+</span><br><span class="line">|   slip    |-----------------|   bsdi    |      |    sun    |     |   svr4    |</span><br><span class="line">+-----------+ .13.65   .13.66 +----*------+      +----*------+     +----*------+</span><br><span class="line">                                   | .13.35           | .13.33          | .13.34</span><br><span class="line">                                   |                  |                 |</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">                                             以太网</span><br></pre></td></tr></table></figure>
<p>在这个图中（作者的子网），大多数的例子都运行在下面四个系统中。图中所有的IP地址属于B类地址，网络号为140.252。所有的主机名属于.tuc.noao.edu这个域</p>
<h1 id="ch01-概述"><a href="#ch01-概述" class="headerlink" title="ch01 概述"></a>ch01 概述</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p>本章的目的是为本书其余章节提供充分的背景知识</p>
<h2 id="1-2-分层"><a href="#1-2-分层" class="headerlink" title="1.2 分层"></a>1.2 分层</h2><p>TCP/IP通常被认为是一个四层协议系统。下三层则一般在（操作系统）内核中执行。</p>
<p>网络接口层和应用层的目的是很显然的<br>网络层和运输层之间的区别不那么明显。为什么要把它们划分成两个不同的层次呢？为了理解这一点，我们必须把视野从单个网络扩展到一组网络。</p>
<p>网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务。</p>
<p>现在网关这个术语只用来表示应用层网关：一个连接两种不同协议族的进程（例如，TCP/IP和IBM的SNA），它为某个特定的应用程序服务（常常是电子邮件或文件传输）。</p>
<p>TCP/IP倾向于使用路由器而不是网桥来连接网络</p>
<h2 id="1-3-TCP-IP的分层"><a href="#1-3-TCP-IP的分层" class="headerlink" title="1.3 TCP/IP的分层"></a>1.3 TCP/IP的分层</h2><p>在图1-4中，我们给出了一个跳过了运输层而直接访问IP的应用程序。这是很少见的，但也是可能的。</p>
<p>尽管ICMP主要被IP使用，但应用程序也有可能访问它。</p>
<p>IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p>
<p>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p>
<h2 id="1-4-互联网的地址"><a href="#1-4-互联网的地址" class="headerlink" title="1.4 互联网的地址"></a>1.4 互联网的地址</h2><p>多接口主机具有多个IP地址，其中每个接口都对应一个IP地址。</p>
<p>InterNIC只分配网络号。主机号的分配由系统管理员来负责。</p>
<h2 id="1-5-域名系统"><a href="#1-5-域名系统" class="headerlink" title="1.5 域名系统"></a>1.5 域名系统</h2><p>任何应用程序都可以调用一个标准的库函数来查看给定名字的主机的IP地址。</p>
<p>大多数使用主机名作为参数的应用程序也可以把IP地址作为参数。</p>
<h2 id="1-6-封装"><a href="#1-6-封装" class="headerlink" title="1.6 封装"></a>1.6 封装</h2><p>运输层协议在生成报文首部时要存入一个应用程序的标识符。TCP和UDP都用一个16bit的端口号来表示不同的应用程序。</p>
<h2 id="1-7-分用"><a href="#1-7-分用" class="headerlink" title="1.7 分用"></a>1.7 分用</h2><p>这些分层协议盒并不都是完美的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">应用程序...应用程序  应用程序...应用程序</span><br><span class="line">            ^     ^</span><br><span class="line">            |     |</span><br><span class="line">           TCP  UDP</span><br><span class="line">ICMP  IGMP  &#x2F;  &#x2F;</span><br><span class="line">    \   |  &#x2F; &#x2F;</span><br><span class="line">     \  | &#x2F;&#x2F;</span><br><span class="line">        IP</span><br><span class="line">ARP     |       RARP</span><br><span class="line">   \    |     &#x2F;</span><br><span class="line">    \   |    &#x2F;</span><br><span class="line">以太网驱动程序</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">进入的帧</span><br></pre></td></tr></table></figure>
<p>图1-8以太网数据帧的分用过程</p>
<h2 id="1-8-客户-服务器模型"><a href="#1-8-客户-服务器模型" class="headerlink" title="1.8 客户-服务器模型"></a>1.8 客户-服务器模型</h2><p>服务分为两种类型：重复型或并发型。</p>
<p>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。</p>
<p>一般来说，TCP服务器是并发的，而UDP服务器是重复的，但也存在一些例外。</p>
<h2 id="1-9-端口号"><a href="#1-9-端口号" class="headerlink" title="1.9 端口号"></a>1.9 端口号</h2><p>服务器一般都是通过知名端口号来识别的。<br>任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet号分配机构（Internet Assigned Numbers Authority, IANA）来管理。</p>
<p>客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以了。客户端口号又称作临时端口号（即存在时间很短暂）。</p>
<p>大多数TCP/IP实现给临时端口分配1024～5000之间的端口号。大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务)。</p>
<p>Unix系统有保留端口号的概念。只有具有超级用户特权的进程才允许给它自己分配一个保留端口号。</p>
<p>这些端口号介于1～1023之间，一些应用程序（如有名的Rlogin，26.2节）将它作为客户与服务器之间身份认证的一部分。</p>
<h2 id="1-10-标准化过程"><a href="#1-10-标准化过程" class="headerlink" title="1.10 标准化过程"></a>1.10 标准化过程</h2><p>有四个小组在负责Internet技术。</p>
<h2 id="1-11-RFC"><a href="#1-11-RFC" class="headerlink" title="1.11 RFC"></a>1.11 RFC</h2><p>所有关于Internet的正式标准都以RFC（Request for Comment）文档出版。另外，大量的RFC并不是正式的标准，出版的目的只是为了提供信息。RFC的篇幅从1页到200页不等。每一项都用一个数字来标识，如RFC 1122，数字越大说明RFC的内容越新。</p>
<h2 id="1-12-标准的简单服务"><a href="#1-12-标准的简单服务" class="headerlink" title="1.12 标准的简单服务"></a>1.12 标准的简单服务</h2><p>有一些标准的简单服务几乎每种实现都要提供。在本书中我们将使用其中的一些服务程序，而客户程序通常选择Telnet。图1-9描述了这些服务。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>端口号</th>
<th>RFC</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>echo</td>
<td>7</td>
<td>862</td>
<td>服务器返回客户发送的所有内容</td>
</tr>
<tr>
<td>discard</td>
<td>9</td>
<td>863</td>
<td>服务器返回丢弃发送的所有内容</td>
</tr>
<tr>
<td>daytime</td>
<td>13</td>
<td>867</td>
<td>服务器以可读形式返回时间和日期</td>
</tr>
<tr>
<td>chargen</td>
<td>19</td>
<td>864</td>
<td>TCP服务器发送一串连续的字符流，UDP服务器发送一个随机长度的数据报</td>
</tr>
<tr>
<td>time</td>
<td>37</td>
<td>848</td>
<td>服务器返回一个二进制形式的32bit数，表示从UTC时间1900至今的秒数</td>
</tr>
</tbody></table>
<h2 id="1-13-互联网"><a href="#1-13-互联网" class="headerlink" title="1.13 互联网"></a>1.13 互联网</h2><p>internet意思是用一个共同的协议族把多个网络连接在一起。而Internet指的是世界范围内通过TCP/IP互相通信的所有主机集合</p>
<h2 id="1-14-实现"><a href="#1-14-实现" class="headerlink" title="1.14 实现"></a>1.14 实现</h2><p>在本书中，我们将使用“伯克利派生系统”来指SunOS 4.x、SVR4以及AIX 3.2等那些基于伯克利源代码开发的系统。这些系统有很多共同之处，经常包含相同的错误。</p>
<h2 id="1-15-应用编程接口"><a href="#1-15-应用编程接口" class="headerlink" title="1.15 应用编程接口"></a>1.15 应用编程接口</h2><p>使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：Transport Layer Interface）。</p>
<h2 id="1-16-测试网络"><a href="#1-16-测试网络" class="headerlink" title="1.16 测试网络"></a>1.16 测试网络</h2><p><a href="#%E7%94%A8%E4%BD%9C%E6%B5%8B%E8%AF%95%E7%9A%84%E7%B3%BB%E7%BB%9F">图1-11</a>是本书中所有的例子运行的测试网络。</p>
<h2 id="1-17-小结"><a href="#1-17-小结" class="headerlink" title="1.17 小结"></a>1.17 小结</h2><p>略</p>
<h2 id="ch01-习题"><a href="#ch01-习题" class="headerlink" title="ch01 习题"></a>ch01 习题</h2><ol>
<li>请计算最多有多少个A类、B类和C类网络号。</li>
</ol>
<ul>
<li>答案：分别为2^7-2、2^14-2、2^21-2。每一部分都减去2是因为全0或全1网络ID是非法的。</li>
</ul>
<ol>
<li>用匿名FTP（见27.3节）从主机nic.merit.edu上获取文件nsfnet/statistics/history.netcount。推算何时会用完所有的网络地址</li>
</ol>
<ul>
<li>答案：2000年</li>
</ul>
<ol>
<li>获取一份主机需求RFC拷贝[Braden 1989a]，阅读有关应用于TCP/IP协议族每一层的稳健性原则。这个原则的参考对象是什么？</li>
</ol>
<ul>
<li>答案：自由地接收，保守地发送</li>
</ul>
<ol>
<li>获取一份最新的赋值RFC拷贝。“quote of the day”协议的有名端口号是什么？哪个RFC对该协议进行了定义？</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>如果你有一个接入TCP/IP互联网的主机帐号，它的主IP地址是多少？这台主机是否接入了Internet？它是多接口主机吗？</li>
</ol>
<ul>
<li>无答案。答：动态分配、是、不是</li>
</ul>
<ol>
<li>获取一份RFC 1000的拷贝，了解RFC这个术语从何而来。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>与Internet协会联系，<a href="mailto:&#105;&#x73;&#111;&#x63;&#x40;&#105;&#x73;&#x6f;&#x63;&#46;&#x6f;&#114;&#103;">&#105;&#x73;&#111;&#x63;&#x40;&#105;&#x73;&#x6f;&#x63;&#46;&#x6f;&#114;&#103;</a>或者+1703 648 9888，了解有关加入的情况。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>用匿名FTP从主机is.internic.net处获取文件about-internic/information-about-the-internic。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<h1 id="ch02-链路层"><a href="#ch02-链路层" class="headerlink" title="ch02 链路层"></a>ch02 链路层</h1><h2 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h2><p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件</p>
<p>在本章中，我们将详细讨论以太网链路层协议，两个串行接口链路层协议（SLIP和PPP），以及大多数实现都包含的环回（loopback）驱动程序。以太网和SLIP是本书中大多数例子使用的链路层。对MTU（最大传输单元）进行了介绍，这个概念在本书的后面章节中将多次遇到。我们还讨论了如何为串行线路选择MTU。</p>
<h2 id="2-2-以太网和IEEE-802封装"><a href="#2-2-以太网和IEEE-802封装" class="headerlink" title="2.2 以太网和IEEE 802封装"></a>2.2 以太网和IEEE 802封装</h2><p>以太网是当今TCP/IP采用的主要的局域网技术。它的速率为10 Mb/s，地址为48 bit。</p>
<p>802.2和802.3定义了一个与以太网不同的帧格式。</p>
<p>图2-1显示了两种不同形式的封装格式。</p>
<p>两种帧格式都采用48 bit（6字节）的目的地址和源地址（802.3允许使用16 bit的地址，但一般是48 bit地址）。这就是我们在本书中所称的硬件地址。ARP和RARP协议（第4章和第5章）对32 bit的IP地址和48 bit的硬件地址进行映射。</p>
<p>802.3标准定义的帧和以太网的帧都有最小长度要求。802.3规定数据部分必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充（pad）字节。</p>
<p>在本书中，我们在需要的时候将给出以太网的封装格式，因为这是最为常见的封装格式。</p>
<h2 id="2-3-尾部封装"><a href="#2-3-尾部封装" class="headerlink" title="2.3 尾部封装"></a>2.3 尾部封装</h2><p>通过把变长的字段移到尾部，节省内存到内存的复制过程。</p>
<p>现在，尾部封装已遭到反对</p>
<h2 id="2-4-SLIP：串行线路IP"><a href="#2-4-SLIP：串行线路IP" class="headerlink" title="2.4 SLIP：串行线路IP"></a>2.4 SLIP：串行线路IP</h2><p>SLIP适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet。</p>
<p>大多数实现以一个称作END（0xc0）的特殊字符开始和结束，还对IP报文中的ESC和END做转义。</p>
<p>SLIP是一种简单的帧封装方法，还有一些值得一提的缺陷：</p>
<ol>
<li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li>
<li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输的报文被线路噪声影响而发生错误，只能通过上层协议来发现（另一种方法是，新型的调制解调器可以检测并纠正错误报文）。</li>
</ol>
<h2 id="2-5-压缩的SLIP"><a href="#2-5-压缩的SLIP" class="headerlink" title="2.5 压缩的SLIP"></a>2.5 压缩的SLIP</h2><p>CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接</p>
<h2 id="2-6-PPP：点对点协议"><a href="#2-6-PPP：点对点协议" class="headerlink" title="2.6 PPP：点对点协议"></a>2.6 PPP：点对点协议</h2><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。PPP包括以下三个部分：</p>
<ol>
<li>在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。</li>
<li>建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li>
<li>针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。例如，IP NCP允许双方商定是否对报文首部进行压缩，类似于CSLIP（缩写词NCP也可用在TCP的前面）。</li>
</ol>
<p>图2-3是PPP数据帧的格式</p>
<ol>
<li>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</li>
<li>接下来是协议字段，类似于以太网中类型字段的功能。当它的</li>
</ol>
<ul>
<li>值为0x0021时，表示信息字段是一个IP数据报；</li>
<li>值为0xc021时，表示信息字段是链路控制数据；</li>
<li>值为0x8021时，表示信息字段是网络控制数据。</li>
</ul>
<ol>
<li>CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
<li>由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。</li>
</ol>
<p>与SLIP类似，由于PPP经常用于低速的串行链路，因此减少每一帧的字节数可以降低应用程序的交互时延。利用链路控制协议，大多数的产品通过协商可以省略标志符和地址字段，并且把协议字段由2个字节减少到1个字节。如果我们把PPP的帧格式与前面的SLIP的帧格式（图2-2）进行比较会发现，PPP只增加了3个额外的字节：1个字节留给协议字段，另2个给CRC字段使用。另外，使用IP网络控制协议，大多数的产品可以通过协商采用Van Jacobson报文首部压缩方法（对应于CSLIP压缩），减小IP和TCP首部长度。</p>
<p>总的来说，PPP比SLIP具有下面这些优点：</p>
<ul>
<li>PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>每一帧都有循环冗余检验；</li>
<li>通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>链路控制协议可以对多个数据链路选项进行设置。<br>为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li>
</ul>
<h2 id="2-7-环回接口"><a href="#2-7-环回接口" class="headerlink" title="2.7 环回接口"></a>2.7 环回接口</h2><p>大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。</p>
<p>看上去用传输层和IP层的方法来处理环回数据似乎效率不高，但它简化了设计，因为环回接口可以被看作是网络层下面的另一个链路层。网络层把一份数据报传送给环回接口，就像传给其他链路层一样，只不过环回接口把它返回到IP的输入队列中。</p>
<h2 id="2-8-最大传输单元MTU"><a href="#2-8-最大传输单元MTU" class="headerlink" title="2.8 最大传输单元MTU"></a>2.8 最大传输单元MTU</h2><p>正如在图2-1看到的那样，以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU，最大传输单元。不同类型的网络大多数都有一个上限。</p>
<p>图2-5列出了一些典型的MTU值,它们摘自RFC 1191[Mogul and Deering 1990]。点到点的链路层（如SLIP和PPP）的MTU并非指的是网络媒体的物理特性。相反，它是一个逻辑限制，目的是为交互使用提供足够快的响应时间。</p>
<h2 id="2-9-路径MTU"><a href="#2-9-路径MTU" class="headerlink" title="2.9 路径MTU"></a>2.9 路径MTU</h2><p>重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。</p>
<p>两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径MTU在两个方向上不一定是一致的。</p>
<h2 id="2-10-串行线路吞吐量计算"><a href="#2-10-串行线路吞吐量计算" class="headerlink" title="2.10 串行线路吞吐量计算"></a>2.10 串行线路吞吐量计算</h2><p>如果线路速率是9600 b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960 B/s（字节/秒）。以这个速率传输一个1024字节的分组需要1066 ms。如果用SLIP链接运行一个交互式应用程序，同时还运行另一个应用程序如FTP发送或接收1024字节的数据，那么一般来说就必须等待一半的时间（533 ms）才能把交互式应用程序的分组数据发送出去。</p>
<p>假定交互分组数据可以在其他“大块”分组数据发送之前被发送出去。大多数的SLIP实现确实提供这类服务排队方法，把交互数据放在大块的数据前面。交互通信一般有Telnet、Rlogin以及FTP的控制部分（用户的命令，而不是数据）。</p>
<p>对于交互应用来说，等待533 ms是不能接受的。关于人的有关研究表明，交互响应时间超过100～200 ms就被认为是不好的</p>
<p>把SLIP的MTU缩短到256就意味着链路传输一帧最长需要266 ms，它的一半是133 ms（这是一般需要等待的时间）。这样情况会好一些，但仍然不完美。我们选择它的原因（与64或128相比）是因为大块数据提供良好的线路利用率（如大文件传输）。<br>如果把MTU降到256以下，那么将降低传输大块数据的最大吞吐量。</p>
<p>在后面的章节中，我们将用这些串行线路吞吐量的计算来验证数据从串行线路上通过的时间。</p>
<h2 id="2-11-小结"><a href="#2-11-小结" class="headerlink" title="2.11 小结"></a>2.11 小结</h2><p>TCP/IP成功的原因之一是它几乎能在任何数据链路技术上运行。</p>
<h2 id="ch02-习题"><a href="#ch02-习题" class="headerlink" title="ch02 习题"></a>ch02 习题</h2><ol>
<li>如果你的系统支持netstat(1)命令（参见3.9节），那么请用它确定系统上的接口及其MTU。</li>
</ol>
<ul>
<li>无答案。已上机实验</li>
</ul>
<h1 id="ch03-IP：网际协议"><a href="#ch03-IP：网际协议" class="headerlink" title="ch03 IP：网际协议"></a>ch03 IP：网际协议</h1><h2 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h2><p>所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</p>
<p>IP仅提供最好的传输服务。发生错误时：丢弃该数据报，然后发送ICMP消息报给信源端。</p>
<p>无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。</p>
<h2 id="3-2-IP首部"><a href="#3-2-IP首部" class="headerlink" title="3.2 IP首部"></a>3.2 IP首部</h2><p>IP数据报的格式如图3-1所示。</p>
<p><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/3/images2/52im_1.png" alt="图3-1"></p>
<p>首部长度指的是首部占32 bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部最长为60个字节。在第8章中，我们将看到这种限制使某些选项如路由记录选项在当今已没有什么用处。普通IP数据报（没有任何选择项）字段的值是5。</p>
<p>服务类型（TOS）字段包括一个3bit的优先权子字段（现在已被忽略），4bit的TOS子字段和1bit未用位但必须置0。4bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。如果所有4bit均为0，那么就意味着是一般服务。RFC 1340[Reynolds and Postel 1992]描述了所有的标准应用如何设置这些服务类型。RFC 1349[Almquist 1992]对该RFC进行了修正，更为详细地描述了TOS的特性。</p>
<p>图3-2列出了对不同应用建议的TO S值。在最后一列中给出的是十六进制值，因为这就是在后面将要看到的tcpdump命令输出。</p>
<p>总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节</p>
<p>TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。<br>当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</p>
<p>首部检验和字段是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p>
<p>为了计算一份数据报的IP检验和，首先把检验和字段置为0。然后，对首部中每个16 bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中。当收到一份IP数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传。</p>
<p>ICMP、IGMP、UDP和TCP都采用相同的检验和算法，尽管TCP和UDP除了本身的首部和数据外，在IP首部中还包含不同的字段。<br>由于路由器经常只修改TTL字段（减1），因此当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算。</p>
<p>最后一个字段是任选项，是数据报中的一个可变长的可选信息。目前，这些任选项定义如下：</p>
<ul>
<li>安全和处理限制（用于军事领域，详细内容参见RFC 1108[Kent 1991]）</li>
<li>记录路径（让每个路由器都记下它的IP地址，见7.3节）</li>
<li>时间戳（让每个路由器都记下它的IP地址和时间，见7.4节）</li>
<li>宽松的源站选路（为数据报指定一系列必须经过的IP地址，见8.5节）</li>
<li>严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。<br>这些选项很少被使用，并非所有的主机和路由器都支持这些选项。</li>
</ul>
<p>选项字段一直都是以32 bit作为界限，在必要的时候插入值为0的填充字节。这样就保证IP首部始终是32 bit的整数倍（这是首部长度字段所要求的）。</p>
<h2 id="3-3-IP路由选择"><a href="#3-3-IP路由选择" class="headerlink" title="3.3 IP路由选择"></a>3.3 IP路由选择</h2><ul>
<li>主机发送数据报：如果目的主机与源主机直接相连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。</li>
<li>路由器转发数据报：查找路由表。<h4 id="例子已理解"><a href="#例子已理解" class="headerlink" title="例子已理解"></a>例子已理解</h4></li>
</ul>
<h2 id="3-4-子网寻址"><a href="#3-4-子网寻址" class="headerlink" title="3.4 子网寻址"></a>3.4 子网寻址</h2><p>现在所有的主机都要求支持子网编址</p>
<p>与30个C类地址相比，用一个包含30个子网的B类地址的好处是，它可以缩小Internet路由表的规模。</p>
<h2 id="3-5-子网掩码"><a href="#3-5-子网掩码" class="headerlink" title="3.5 子网掩码"></a>3.5 子网掩码</h2><h4 id="例子已理解-1"><a href="#例子已理解-1" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="3-6-特殊情况的IP地址"><a href="#3-6-特殊情况的IP地址" class="headerlink" title="3.6 特殊情况的IP地址"></a>3.6 特殊情况的IP地址</h2><table>
<thead>
<tr>
<th>类型</th>
<th>前缀</th>
<th>网络号</th>
<th>主机号</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>0</td>
<td>7位网络号</td>
<td>24位主机号</td>
</tr>
<tr>
<td>B类</td>
<td>10</td>
<td>14位网络号</td>
<td>16位主机号</td>
</tr>
<tr>
<td>C类</td>
<td>110</td>
<td>21位网络号</td>
<td>8位主机号</td>
</tr>
<tr>
<td>D类</td>
<td>1110</td>
<td>多播组号</td>
<td></td>
</tr>
<tr>
<td>E类</td>
<td>11110</td>
<td>留待后用</td>
<td></td>
</tr>
</tbody></table>
<p>下表的子网号栏为空表示该地址没有进行子网划分</p>
<table>
<thead>
<tr>
<th>网络号</th>
<th>子网号</th>
<th>主机号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td></td>
<td>0</td>
<td>网络上的主机</td>
</tr>
<tr>
<td>0</td>
<td></td>
<td>hostid</td>
<td>网络上的特定主机</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>127</td>
<td></td>
<td>任何值</td>
<td>环回地址</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>-1</td>
<td></td>
<td>-1</td>
<td>受限的广播（永远不被转发）</td>
</tr>
<tr>
<td>netid</td>
<td></td>
<td>-1</td>
<td>以网络为目的向netid广播</td>
</tr>
<tr>
<td>netid</td>
<td>subnetid</td>
<td>-1</td>
<td>以子网为目的向netid、subnetid广播</td>
</tr>
<tr>
<td>netid</td>
<td>subnetid</td>
<td>-1</td>
<td>以所有子网为目的向netid广播</td>
</tr>
</tbody></table>
<p>上表的头两项，网络号为0，如主机使用BOOTP协议确定本机IP地址时只能作为初始化过程中的源地址出现。</p>
<h2 id="3-7-一个子网的例子"><a href="#3-7-一个子网的例子" class="headerlink" title="3.7 一个子网的例子"></a>3.7 一个子网的例子</h2><p>使用两个不同的子网掩码<br>需要变长子网</p>
<p>RIP不支持变长子网，RIP第2版和OSPF都支持</p>
<h2 id="3-8-ifconfig命令"><a href="#3-8-ifconfig命令" class="headerlink" title="3.8 ifconfig命令"></a>3.8 ifconfig命令</h2><p>ifconfig可以配置和查询主机上的每个接口</p>
<p>SLIP的LINK标志</p>
<ul>
<li>LINK0：允许压缩slip的数据（CSLIP）</li>
<li>LINK1：如果从另一端收到一份压缩报文，就允许采用CSLIP</li>
<li>LINK2：所有外出的ICMP报文都被丢弃</li>
</ul>
<h2 id="3-9-netstat命令"><a href="#3-9-netstat命令" class="headerlink" title="3.9 netstat命令"></a>3.9 netstat命令</h2><p><code>netstat -in</code>打印出每个接口的MTU、输入分组数、输入错误、输出分组数、输出错误、冲突以及当前的输出队列长度。</p>
<h2 id="3-10-IP的未来"><a href="#3-10-IP的未来" class="headerlink" title="3.10 IP的未来"></a>3.10 IP的未来</h2><p>IP主要存在三个方面的问题</p>
<p>有四个建议之一会被选为IPv4的替换者，你读到此书时可能已经对新版IP做出选择。</p>
<h2 id="3-11-小结"><a href="#3-11-小结" class="headerlink" title="3.11 小结"></a>3.11 小结</h2><p>数据报在各站的传输过程中目的IP地址始终不变，但是封装和目的链路层地址在每一站都可以改变。</p>
<h2 id="ch03-习题"><a href="#ch03-习题" class="headerlink" title="ch03 习题"></a>ch03 习题</h2><ol>
<li>环回地址必须是127.0.0.1吗？</li>
</ol>
<ul>
<li>答案：不，任何网络ID为127的A类地址都是可行的</li>
</ul>
<ol>
<li>在图3-6中指出有两个网络接口的路由器。</li>
</ol>
<ul>
<li>已理解</li>
</ul>
<ol>
<li>子网号为16 bit的A类地址与子网号为8bit的B类地址的子网掩码有什么不同？</li>
</ol>
<ul>
<li>答案：没有区别：作为一个没有再区分子网的C类地址，它们都有一个255.255.255.0的子网掩码。</li>
</ul>
<ol>
<li>阅读RFC 1219[Tsuchiya 1991]，学习分配子网号和主机号的有关推荐技术。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>子网掩码255.255.0.255是否对A类地址有效？</li>
</ol>
<ul>
<li>答案：它是合法的，被称为非连续的子网掩码，因为其用于子网掩码的16位是不连续的。但是RFC建议反对使用非连续的子网掩码。</li>
</ul>
<ol>
<li>你认为为什么3.9小节中打印出来的环回接口的MTU要设置为1536？</li>
</ol>
<ul>
<li>答案：这是一个历史遗留问题。值是1024＋512，但是打印的MTU值包含了所有需要的首部字节数。</li>
</ul>
<ol>
<li>TCP/IP协议族是基于一种数据报的网络技术，即IP层，其他的协议族则基于面向连接的网络技术。阅读文献[Clark 1988]，找出数据报网络层提供的三个优点。答案：</li>
</ol>
<ul>
<li>数据报降低了路由器中对于连接状态的需求。</li>
<li>数据报提供了基本的构件，在它的上面可以构造不可靠的（UDP）和可靠的（TCP）的运输层。</li>
<li>数据报代表了最小的网络层假定，使得可以使用很大范围的数据链路层服务。</li>
</ul>
<h1 id="ch04-ARP：地址解析协议"><a href="#ch04-ARP：地址解析协议" class="headerlink" title="ch04 ARP：地址解析协议"></a>ch04 ARP：地址解析协议</h1><h2 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h2><p>一个网络如以太网可以同时被不同的网络层使用</p>
<ul>
<li>ARP是自动完成的</li>
<li>RARP是被那些没有磁盘驱动器的系统使用，需要手工设置</li>
</ul>
<h2 id="4-2-一个例子"><a href="#4-2-一个例子" class="headerlink" title="4.2 一个例子"></a>4.2 一个例子</h2><h4 id="例子已理解-2"><a href="#例子已理解-2" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射</p>
<p>点对点链路不使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址。</p>
<h2 id="4-3-ARP高速缓存"><a href="#4-3-ARP高速缓存" class="headerlink" title="4.3 ARP高速缓存"></a>4.3 ARP高速缓存</h2><p><code>arp -a</code>显示ARP高速缓存中多有的内容</p>
<p>每一项的生存时间一般为20分钟</p>
<h2 id="4-4-ARP的分组格式"><a href="#4-4-ARP的分组格式" class="headerlink" title="4.4 ARP的分组格式"></a>4.4 ARP的分组格式</h2><p>ARP请求和应答分组的格式如图4-3所示</p>
<p>分组中的重复信息：在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址。</p>
<p>对于一个ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。</p>
<h2 id="4-5-ARP举例"><a href="#4-5-ARP举例" class="headerlink" title="4.5 ARP举例"></a>4.5 ARP举例</h2><h3 id="4-5-1-一般的例子"><a href="#4-5-1-一般的例子" class="headerlink" title="4.5.1 一般的例子"></a>4.5.1 一般的例子</h3><h4 id="例子已理解-3"><a href="#例子已理解-3" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>单词arp或ip后面的值60指的是以太网数据帧的长度，包含14字节的以太网帧头，但是不包括4个字节的以太网帧尾。</p>
<p>arp who has和arp reply都接近自然语言的描述。 </p>
<h3 id="4-5-2-对不存在主机的ARP请求"><a href="#4-5-2-对不存在主机的ARP请求" class="headerlink" title="4.5.2 对不存在主机的ARP请求"></a>4.5.2 对不存在主机的ARP请求</h3><p>会产生不完整的表项<code>? (140.252.13.36) at (incomplete)</code></p>
<p>直到ARP回答返回时，TCP报文段才可以被发送。</p>
<h3 id="4-5-3-ARP高速缓存超时设置"><a href="#4-5-3-ARP高速缓存超时设置" class="headerlink" title="4.5.3 ARP高速缓存超时设置"></a>4.5.3 ARP高速缓存超时设置</h3><ul>
<li>完整的表项超时值为20分钟</li>
<li>不完整的表项超时值为3分钟</li>
<li>管理员可以用arp命令把地址放入高速缓存中而不设置超时值</li>
</ul>
<h2 id="4-6-ARP代理"><a href="#4-6-ARP代理" class="headerlink" title="4.6 ARP代理"></a>4.6 ARP代理</h2><p>如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理(Proxy ARP)。这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。</p>
<p>拨号SLIP链路的两端只拥有一个IP地址</p>
<p>ARP代理也称作混合ARP（promiscuousARP）或ARP出租(ARP hack)。这些名字来自于ARP代理的其他用途：通过两个物理网络之间的路由器可以互相隐藏物理网络。在这种情况下，两个物理网络可以使用相同的网络号，只要把中间的路由器设置成一个ARP代理，以响应一个网络到另一个网络主机的ARP请求。</p>
<h2 id="4-7-免费ARP"><a href="#4-7-免费ARP" class="headerlink" title="4.7 免费ARP"></a>4.7 免费ARP</h2><p>免费ARP(gratuitous ARP)是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。</p>
<p>免费ARP可以有两个方面的作用：</p>
<ul>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。</li>
<li>如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li>
</ul>
<p>通过发送含有备份硬件地址和故障服务器的IP地址的免费ARP请求，使得备份文件服务器可以顺利地接替故障服务器进行工作。</p>
<h2 id="4-8-arp命令"><a href="#4-8-arp命令" class="headerlink" title="4.8 arp命令"></a>4.8 arp命令</h2><p>-a：显示ARP高速缓存中的所有内容。这里介绍其他参数的功能。<br>-d：删除ARP高速缓存中的某一项内容（需超级用户）。<br>-s：来增加高速缓存中的内容。这个参数需要主机名和以太网地址：对应于主机名的IP地址和以太网地址被增加到高速缓存中。新增加的内容是永久性的（比如，它没有超时值），除非在命令行的末尾附上关键字temp。<br>位于命令行末尾的关键字pub和-s选项一起：可以使系统起着主机ARP代理的作用。系统将回答与主机名对应的IP地址的ARP请求，并以指定的以太网地址作为应答。如果广播的地址是系统本身，那么系统就为指定的主机名起着委托ARP代理的作用。</p>
<h2 id="4-9-小结"><a href="#4-9-小结" class="headerlink" title="4.9 小结"></a>4.9 小结</h2><p>略</p>
<h1 id="ch04-习题"><a href="#ch04-习题" class="headerlink" title="ch04 习题"></a>ch04 习题</h1><ol>
<li>当输入命令以生成类似图4-4那样的输出时，发现本地ARP快速缓存为空以后，输入命令<code>bsdi % rsh svr4 arp -a</code>如果发现目的主机上的ARP快速缓存也是空的，那将发生什么情况？(该命令将在svr4主机上运行arp -a命令）。</li>
</ol>
<ul>
<li>答案：发出一条rsh命令与另一台主机建立一个TCP连接。这样做引起在两个主机之间交换IP数据报。为此，在那台主机的ARP缓存中必须有我们这台主机的登记项。因此，即使在执行rsh命令之前，ARP缓存是空的，当rsh服务器执行arp命令时，必须保证ARP缓存中登记有我们这台主机。</li>
</ul>
<ol>
<li>请描述如何判断一个给定主机是否能正确处理接收到的非必要的ARP请求的方法。</li>
</ol>
<ul>
<li>答案：保证你的主机上的ARP缓存中没有登记以太网上的某个叫作foo的主机。保证foo引导时发送一个免费ARP请求，也许是在foo引导时，在那台主机上运行tcpdump。然后关闭主机foo，使用说明了temp选项的arp命令，在你的系统的ARP缓存中为foo输入一个不正确的登记项。引导foo并在它启动好之后，察看主机的ARP缓存，看看不正确的登记项是不是已经被更正了。</li>
</ul>
<ol>
<li>由于发送一个数据包后ARP将等待响应，因此4.2节所描述的步骤7可能会持续一段时间。你认为ARP将如何处理在这期间收到相同目的IP地址发来的多个数据包？</li>
</ol>
<ul>
<li>答案：CF：RFC的2.3.2.2节和本书中的<a href="#">11.9节</a>。</li>
</ul>
<ol>
<li>在4.5节的最后，我们指出Host Requirements RFC和伯克利派生系统在处理活动ARP表目的超时时存在差异。那么如果我们在一个由伯克利派生系统的客户端上，试图与一个正在更换以太网卡而处于关机状态的服务器主机联系，这时会发生什么情况？如果服务器在引导过程中广播一份免费ARP，这种情况是否会发生变化？</li>
</ol>
<ul>
<li>答案：假设当服务器关闭时，客户机保存了关于服务器的一个完整的ARP登记项。如果我们继续试图与（已关闭的）服务器联系，过了20分钟以后，ARP将超时。最后，当服务器以另一个新的硬件地址重启动。如果它没有发出一个免费ARP，旧的、不再正确的ARP登记项仍然存在于客户机上。我们将无法和在新硬件地址上的服务器联系直到我们手工删除这个ARP登记项，或者在20分钟内停止与服务器联系的尝试。</li>
</ul>
<h1 id="ch05-RARP：逆地址解析协议"><a href="#ch05-RARP：逆地址解析协议" class="headerlink" title="ch05 RARP：逆地址解析协议"></a>ch05 RARP：逆地址解析协议</h1><h2 id="5-1-引言"><a href="#5-1-引言" class="headerlink" title="5.1 引言"></a>5.1 引言</h2><p>无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求，请求某个主机响应该无盘系统的IP地址</p>
<h2 id="5-2-RARP的分组格式"><a href="#5-2-RARP的分组格式" class="headerlink" title="5.2 RARP的分组格式"></a>5.2 RARP的分组格式</h2><p>RARP分组的格式与ARP分组基本一致（见图4-3）。它们之间主要的差别是RARP请求或应答的帧类型代码为0x8035，而且RARP请求的操作代码为3，应答操作代码为4。</p>
<h2 id="5-3-RARP举例"><a href="#5-3-RARP举例" class="headerlink" title="5.3 RARP举例"></a>5.3 RARP举例</h2><p>当无盘系统从RARP应答中收到它的IP地址后，它将发送TFTP请求来读取引导映象。</p>
<h2 id="5-4-RARP服务器的设计"><a href="#5-4-RARP服务器的设计" class="headerlink" title="5.4 RARP服务器的设计"></a>5.4 RARP服务器的设计</h2><p>虽然RARP在概念上很简单，但是一个RARP服务器的设计与系统相关而且比较复杂。</p>
<h3 id="5-4-1-作为用户进程的RARP服务器"><a href="#5-4-1-作为用户进程的RARP服务器" class="headerlink" title="5.4.1 作为用户进程的RARP服务器"></a>5.4.1 作为用户进程的RARP服务器</h3><p>由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供，而不是作为内核的TCP/IP实现的一部分。</p>
<p>由于发送和接收特殊类型的以太网数据帧与系统有关，因此RARP服务器的实现是与系统捆绑在一起的。</p>
<h3 id="5-4-2-每个网络有多个RARP服务器"><a href="#5-4-2-每个网络有多个RARP服务器" class="headerlink" title="5.4.2 每个网络有多个RARP服务器"></a>5.4.2 每个网络有多个RARP服务器</h3><p>通常在一个网络上（例如一根电缆）要提供多个RARP服务器。</p>
<p>当服务器的数目增加时（以提供冗余备份），网络流量也随之增加，因为每个服务器对每个RARP请求都要发送RARP应答。发送RARP请求的无盘系统一般采用最先收到的RARP应答。</p>
<h2 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h2><p>在第16章中，我们将看到BOOTP在无盘系统引导时会返回更多的信息：IP地址和引导主机的名字等。</p>
<h2 id="ch05-习题"><a href="#ch05-习题" class="headerlink" title="ch05 习题"></a>ch05 习题</h2><ol>
<li>RARP需要不同的帧类型字段吗？ARP和RARP都使用相同的值0x0806吗？</li>
</ol>
<ul>
<li>答案：一个单独的帧类型并不是必需的，因为图4-3中的op字段对于所有的四个操作（ARP请求、ARP应答、RARP请求和RARP应答）都有一个不同的值。但是实现一个RARP服务器，独立于内核中的ARP服务器，更容易处理不同的帧类型字段。</li>
</ul>
<ol>
<li>在一个有多个RARP服务器的网络上，如何防止它们的响应发生冲突？</li>
</ol>
<ul>
<li>答案： 每个RARP服务器在发送一个响应之前可以延迟一个小的随机时间。作为一个优化，可以指定一个RARP服务器为主服务器，其他的为次服务器。主服务器发出响应不需要延迟，而次服务器发出响应则需要一个随机的延迟。作为另一个优化，也是指定一个主RARP服务器，其他为次服务器。次服务器只对在一个短时间段内发生的重复请求进行响应。这里假设出现重复请求的原因是由于主服务器停机了。</li>
</ul>
<h1 id="ch06-ICMP：Internet控制报文协议"><a href="#ch06-ICMP：Internet控制报文协议" class="headerlink" title="ch06 ICMP：Internet控制报文协议"></a>ch06 ICMP：Internet控制报文协议</h1><h2 id="6-1-引言"><a href="#6-1-引言" class="headerlink" title="6.1 引言"></a>6.1 引言</h2><p>ICMP报文的格式如图6-2所示。类型字段可以有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代码字段的值来进一步描述不同的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0        7 8      15 16               31</span><br><span class="line">+---------+---------+------------------+</span><br><span class="line">| 8位类型 | 8位代码 |    16位检验和    |</span><br><span class="line">+---------*---------*------------------+</span><br><span class="line">|    （不同类型和代码有不同的内容）    | </span><br><span class="line">+--------------------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="6-2-ICMP报文的类型"><a href="#6-2-ICMP报文的类型" class="headerlink" title="6.2 ICMP报文的类型"></a>6.2 ICMP报文的类型</h2><p>各种类型的ICMP报文如图6-3所示</p>
<p>图中的最后两列表明ICMP报文是一份查询报文还是一份差错报文。</p>
<p>下面各种情况都不会导致产生ICMP差错报文：</p>
<ol>
<li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。</li>
<li>目的地址是广播地址（见图3-9）或多播地址（D类地址，见图1-5）的IP数据报。</li>
<li>作为链路层广播的数据报。</li>
<li>不是IP分片的第一片（将在11.5节介绍分片）。</li>
<li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。<br>这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴。</li>
</ol>
<h2 id="6-3-ICMP地址掩码请求与应答"><a href="#6-3-ICMP地址掩码请求与应答" class="headerlink" title="6.3 ICMP地址掩码请求与应答"></a>6.3 ICMP地址掩码请求与应答</h2><p>ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码</p>
<p>ICMP报文中的标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回。这样，发送端就可以把应答与请求进行匹配。</p>
<p>广播的一般特性：发送主机也能通过某种内部环回机制收到一份广播报文拷贝。</p>
<p>通常，应答地址必须是单播地址，除非请求端的源IP地址是0.0.0.0。</p>
<p>RFC规定，除非系统是地址掩码的授权代理，否则它不能发送地址掩码应答（为了成为授权代理，它必须进行特殊配置，以发送这些应答。参见附录E）。但是，正如我们从本例中看到的那样，大多数主机在收到请求时都发送一个应答，甚至有一些主机还发送差错的应答。</p>
<p>ICMP地址掩码应答必须是收到请求接口的子网掩码</p>
<h2 id="6-4-ICMP时间戳请求与应答"><a href="#6-4-ICMP时间戳请求与应答" class="headerlink" title="6.4 ICMP时间戳请求与应答"></a>6.4 ICMP时间戳请求与应答</h2><p>ICMP时间戳请求允许系统向另一个系统查询当前的时间。返回的建议值是自午夜开始计算的毫秒数。这种ICMP报文的好处是它提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间（如某些Unix系统提供的rdate命令）只能提供秒级的分辨率。由于返回的时间是从午夜开始计算的，因此调用者必须通过其他方法获知当时的日期，这是它的一个缺陷。</p>
<p>请求端填写发起时间戳，然后发送报文。应答系统收到请求报文时填写接收时间戳，在发送应答时填写发送时间戳。但是，实际上，大多数的实现把后面两个字段都设成相同的值</p>
<h3 id="6-4-1-举例"><a href="#6-4-1-举例" class="headerlink" title="6.4.1 举例"></a>6.4.1 举例</h3><p>往返时间（rtt），它的值是收到应答时的时间值减去发送请求时的时间值。difference的值是接收时间戳值减去发起时间戳值。</p>
<p>如果我们相信RTT的值，并且相信RTT的一半用于请求报文的传输，另一半用于应答报文的传输，那么为了使本机时钟与查询主机的时钟一致，本机时钟需要进行调整，调整值是difference减去RTT的一半。</p>
<h3 id="6-4-2-另一种方法"><a href="#6-4-2-另一种方法" class="headerlink" title="6.4.2 另一种方法"></a>6.4.2 另一种方法</h3><p>还可以用另一种方法来获得时间和日期。</p>
<ul>
<li>在1.12节中描述了日期服务程序和时间服务程序（前面我们提过的rdate命令使用的是TCP时间服务程序）。</li>
<li>严格的计时器使用网络时间协议（NTP），该协议在RFC 1305中给出了描述[Mills1992]。这个协议采用先进的技术来保证LAN或WA N上的一组系统的时钟误差在毫秒级以内。对计算机精确时间感兴趣的读者应该阅读这份RFC文档。</li>
<li>开放软件基金会（OSF）的分布式计算环境（DCE）定义了分布式时间服务（DTS），它也提供计算机之间的时钟同步。文献[Rosenberg, Kenney and Fisher 1992]提供了该服务的其他细节描述。</li>
<li>伯克利大学的Unix系统提供守护程序timed(8)，来同步局域网上的系统时钟。不像NTP和DTS，timed不在广域网范围内工作。</li>
</ul>
<h2 id="6-5-ICMP端口不可达差错"><a href="#6-5-ICMP端口不可达差错" class="headerlink" title="6.5 ICMP端口不可达差错"></a>6.5 ICMP端口不可达差错</h2><p>UDP的规则之一是，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。</p>
<p>ICMP差错报文必须包括生成该差错报文的数据报IP首部（包含任何选项），还必须至少包括跟在该IP首部后面的前8个字节。</p>
<p>当ICMP报文返回时，为什么TFTP客户程序还要继续重发请求呢？这是由于网络编程中的一个因素，即BSD系统不把从插口(socket)接收到的ICMP报文中的UDP数据通知用户进程，除非该进程已经发送了一个connect命令给该插口。</p>
<h2 id="6-6-ICMP报文的4-4BSD处理"><a href="#6-6-ICMP报文的4-4BSD处理" class="headerlink" title="6.6 ICMP报文的4.4BSD处理"></a>6.6 ICMP报文的4.4BSD处理</h2><p>由于ICMP覆盖的范围很广，从致命差错到信息差错，因此即使在一个给定的系统实现中，对每个ICMP报文的处理都是不相同的。图6-12的内容与图6-3相同，它显示的是4.4BSD系统对每个可能的ICMP报文的处理方法。</p>
<ul>
<li>如果最后一列标明是“内核”，那么ICMP就由内核来处理。</li>
<li>如果最后一列指明是“用户进程”，那么报文就被传送到所有在内核中登记的用户进程，以读取收到的ICMP报文。</li>
<li>如果不存在任何这样的用户进程，那么报文就悄悄地被丢弃（这些用户进程还会收到所有其他类型的ICMP报文的拷贝，虽然它们应该由内核来处理，当然用户进程只有在内核处理以后才能收到这些报文）。</li>
<li>有一些报文完全被忽略。</li>
<li>如果最后一列标明的是引号内的一串字符，那么它就是对应的Unix差错。</li>
</ul>
<h2 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h2><p>略</p>
<h2 id="ch06-习题"><a href="#ch06-习题" class="headerlink" title="ch06 习题"></a>ch06 习题</h2><ol>
<li>在6.2节的末尾，我们列出了5种不发送ICMP差错报文的特殊条件。如果这些条件不满足而我们又在局域网上向一个似乎不存在的端口号发送一份广播UDP数据报，这时会发生什么样的情况？</li>
</ol>
<ul>
<li>答案：如果在局域网线上有一百个主机，每个都可能在同一时刻发送一个ICMP端口不可达的报文。很多报文的传输都可能发生冲突（如果使用的是以太网），这将导致1秒或2秒的时间里网络不可用。</li>
</ul>
<ol>
<li>阅读RFC [Braden 1989a]，注意生成一个ICMP端口不可达差错是否为“必须”，“应该”或者“可能”。这些信息所在的页码和章节是多少？</li>
</ol>
<ul>
<li>答案：它是一个“should”。</li>
</ul>
<ol>
<li>阅读RFC 1349 [Almquist 1992]，看看IP的服务类型字段（见图3-2）是如何被ICMP设置的？</li>
</ol>
<ul>
<li>答案：如我们在图3-2所指出的，发送一个ICMP差错总是将TOS置为0。发送一个ICMP查询请求可以将TOS置为任何值，但是发送相应的应答必须将TOS置为相同的值。</li>
</ul>
<ol>
<li>如果你的系统提供netstat命令，请用它来查看接收和发送的ICMP报文类型。</li>
</ol>
<ul>
<li>答案：netstat -s是查看每个协议统计数据的常用方法。</li>
</ul>
<h1 id="ch07-Ping程序"><a href="#ch07-Ping程序" class="headerlink" title="ch07 Ping程序"></a>ch07 Ping程序</h1><h2 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h2><p>Ping还给我们提供了检测IP记录路由和时间戳选项的机会</p>
<p>出现了提供访问控制清单的路由器和防火墙以后，一台主机的可达性可能不只取决于IP层是否可达</p>
<h2 id="7-2-Ping程序"><a href="#7-2-Ping程序" class="headerlink" title="7.2 Ping程序"></a>7.2 Ping程序</h2><p>大多数的TCP/IP实现都在内核中直接支持Ping服务器——这种服务器不是一个用户进程。<br>回显请求，地址掩码和时间戳请求，都是直接在内核中进行处理的</p>
<p>ICMP回显请求和回显应答报文如图7-1所示。</p>
<p>对于其他类型的ICMP查询报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣。</p>
<p>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息。</p>
<p>序列号从0开始，每发送一次新的回显请求就加1。ping程序打印出返回的每个分组的序列号，允许我们查看是否有分组丢失、失序或重复。IP是一种尽力而为的数据报传递服务，因此这三个条件都有可能发生。</p>
<h3 id="7-2-1-LAN输出"><a href="#7-2-1-LAN输出" class="headerlink" title="7.2.1 LAN输出"></a>7.2.1 LAN输出</h3><p>ping程序通过在ICMP报文数据中存放发送请求的时间值来计算往返时间。</p>
<p>键入ping命令，几秒钟过后会在第1行打印出IP地址，DNS就是利用这段时间来确定主机名所对应的IP地址。</p>
<h3 id="7-2-2-WAN输出"><a href="#7-2-2-WAN输出" class="headerlink" title="7.2.2 WAN输出"></a>7.2.2 WAN输出</h3><p>像52%这样高的分组丢失率是不正常的。即使是在工作日的下午，对于Internet来说也是不正常的。</p>
<p>通过广域网还有可能看到重复的分组（即相同序列号的分组被打印两次或更多次），失序的分组（序列号为N+1的分组在序列号为N的分组之前被打印）。</p>
<h3 id="7-2-3-线路SLIP链接"><a href="#7-2-3-线路SLIP链接" class="headerlink" title="7.2.3 线路SLIP链接"></a>7.2.3 线路SLIP链接</h3><p>让我们再来看看SLIP链路上的往返时间，因为它们经常运行于低速的异步方式，如9600b/s或更低。</p>
<p>对于SVR4来说，往返时间大约是1.5秒，但是程序仍然每间隔1秒钟发送一次ICMP回显请求。这就是为什么总结行指出丢失了一个分组。实际上分组并未丢失，很可能仍然在返回的途中。</p>
<h3 id="7-2-4-拨号SLIP链路"><a href="#7-2-4-拨号SLIP链路" class="headerlink" title="7.2.4 拨号SLIP链路"></a>7.2.4 拨号SLIP链路</h3><p>对于拔号SLIP链路来说，调制解调器带来了时延</p>
<p>这些调制解调器的参数对RTT的影响很大，使用错误控制和数据压缩方式似乎效果最好。</p>
<h2 id="7-3-IP记录路由选项"><a href="#7-3-IP记录路由选项" class="headerlink" title="7.3 IP记录路由选项"></a>7.3 IP记录路由选项</h2><p>ping程序为我们提供了查看IP记录路由（RR）选项的机会。大多数不同版本的ping程序都提供-R选项，以提供记录路由的功能。它使得ping程序在发送出去的IP数据报中设置IPRR选项（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都把它的IP地址放入选项字段中。当数据报到达目的端时，IP地址清单应该复制到ICMP回显应答中，这样返回途中所经过的路由器地址也被加入清单中。当ping程序收到回显应答时，它就打印出这份IP地址清单。</p>
<p>有一些系统不把ICMP请求中的IP清单复制到ICMP应答中。</p>
<p>但是，最大的问题是IP首部中只有有限的空间来存放IP地址。</p>
<p>IP数据报中的RR选项的一般格式如图7-3所示。</p>
<p>当路由器（根据定义应该是多穴的）在清单中记录IP地址时，它应该记录哪个地址呢？是入口地址还是出口地址？为此，RFC 791[Postel 1981a]指定路由器记录出口IP地址。</p>
<h3 id="7-3-1-通常的例子"><a href="#7-3-1-通常的例子" class="headerlink" title="7.3.1 通常的例子"></a>7.3.1 通常的例子</h3><p>我们举一个用RR选项运行ping程序的例子，在主机svr4上运行ping程序到主机slip。一个中间路由器(bsdi)将处理这个数据报。</p>
<p>分组所经过的四站如图7-4所示（每个方向各有两站），每一站都把自己的出口IP地址加入RR清单。</p>
<p>通过运行带有-v选项的tcpdump命令来查看主机sun上进行的分组交换（参见IP选项）。输出如图7-5所示。</p>
<p>输出中optlen=40表示在IP首部中有40个字节的选项空间（IP首部长度必须为4字节的整数倍）。RR{39}的意思是记录路由选项已被设置，它的长度字段是39。然后是9个IP地址，符号“#”用来标记RR选项中的ptr字段所指向的IP地址。</p>
<p>位于路由信息末尾的标记EOL表示IP选项“end of list（清单结束）”的值。EOL选项的值可以为0。这时表示39个字节的RR数据位于IP首部中的40字节空间中。由于在数据报发送之前空间选项被设置为0，因此跟在39个字节的RR数据之后的0字符就被解释为EOL。这正是我们所希望的结果。如果在IP首部中的选项字段中有多个选项，在开始下一个选项之前必须填入空白字符，另外还可以用另一个值为1的特殊字符NOP（“no operation”）。</p>
<h3 id="7-3-2-异常的输出"><a href="#7-3-2-异常的输出" class="headerlink" title="7.3.2 异常的输出"></a>7.3.2 异常的输出</h3><p>为什么传出的数据报（ICMP回显请求）直接从netb传到aix，而返回的数据报（ICMP回显应答）却从aix开始经路由器gateway再到netb？</p>
<p>路由器gateway比子网140.252.1上的任何主机都具备更强的选路能力（在这个以太网上有超过150台主机，每台主机的路由表中都有一个默认项指向路由器gateway，这样就不用在每台主机上都运行一个选路守护程序）。</p>
<p>这里没有应答的一个问题是为什么gateway不直接发送ICMP报文重定向到aix（9.5节），以更新它的路由表？由于某种原因（很可能是由于数据报产生的重定向是一份ICMP回显请求报文），重定向并没有产生。但是如果我们用Te lnet登录到aix上的daytime服务器，ICMP就会产生重定向</p>
<h2 id="7-4-IP时间戳选项"><a href="#7-4-IP时间戳选项" class="headerlink" title="7.4 IP时间戳选项"></a>7.4 IP时间戳选项</h2><p>IP时间戳选项与记录路由选项类似。IP时间戳选项的格式如图7-7所示（请与图7-3进行比较）。</p>
<p>时间戳选项的代码为0x44。其他两个字段len和ptr与记录路由选项相同：选项的总长度（一般为36或40）和指向下一个可用空间的指针（5，9，13等）。</p>
<p>接下来的两个字段是4bit的值：OF表示溢出字段，FL表示标志字段。时间戳选项的操作根据标志字段来进行，如图7-8所示。</p>
<p>如果路由器由于没有空间而不能增加时间戳选项，那么它将增加溢出字段的值。</p>
<p>时间戳的取值一般为自UTC午夜开始计的毫秒数，与ICMP时间戳请求和应答相类似。如果路由器不使用这种格式，它就可以插入任何它使用的时间表示格式，但是必须打开时间戳中的高位以表明为非标准值。</p>
<p>与我们遇到的记录路由选项所受到的限制相比，时间戳选项遇到情况要更坏一些。如果我们要同时记录IP地址和时间戳（标志位为1），那么就可以同时存入其中的四对值。只记录时间戳是没有用处的，因为我们没有标明时间戳与路由器之间的对应关系（除非有一个永远不变的拓扑结构）。标志值取3会更好一些，因为我们可以插入时间戳的路由器。一个更为基本的问题是，很可能无法控制任何给定路由器上时间戳的正确性。这使得试图用IP选项来计算路由器之间的跳站数是徒劳的。</p>
<h2 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5 小结"></a>7.5 小结</h2><p>略</p>
<h2 id="ch07-习题"><a href="#ch07-习题" class="headerlink" title="ch07 习题"></a>ch07 习题</h2><ol>
<li>请画出7.2节中ping输出的时间线。</li>
</ol>
<ul>
<li>无答案。已思考</li>
</ul>
<ol>
<li>若把bsdi和slip主机之间的SLIP链路设置为9600 b/s，请计算这时的RTT。假定默认的数据是56字节。</li>
</ol>
<ul>
<li>已对答案：86字节除以960字节/秒，乘以2 = 179.2ms</li>
</ul>
<ol>
<li>当前BSD版中的ping程序允许我们为ICMP报文的数据部分指定一种模式（数据部分的前8个字节不用来存放模式，因为它要存放发送报文的时间）。如果我们指定的模式为0xc0，请重新计算上一题中的答案（提示：阅读2.4节）。</li>
</ol>
<ul>
<li>答案：（86＋48）除以960字节/秒，乘以2得到279.2ms。另外的48字节是因为56字节的数据部分的最后48字节必须忽略：0xc0是SLIP END字符。</li>
</ul>
<ol>
<li>使用压缩SLIP（CSLIP，见2.5节）是否会影响我们在7.2节中看到的ping输出中的时间值？</li>
</ol>
<ul>
<li>答案：CSLIP只压缩了TCP报文段的TCP首部和IP首部。它对ping使用的ICMP报文没有作用。</li>
</ul>
<ol>
<li>在图2-4中，ping环回地址与ping主机以太网地址会出现什么不同？</li>
</ol>
<ul>
<li>在一个SPA RC工作站ELC上，对回环地址的ping操作产生一个1.310 ms的RTT，而对一个主机的以太网地址的ping操作产生一个1.460 ms的RTT。这个差值是由于以太网驱动程序需要时间来判定这个数据报的目的地址是一个本地的主机。需要一个产生微秒级输出的ping来验证这一点。</li>
</ul>
<h1 id="ch08-Traceroute程序"><a href="#ch08-Traceroute程序" class="headerlink" title="ch08 Traceroute程序"></a>ch08 Traceroute程序</h1><h2 id="8-1-引言"><a href="#8-1-引言" class="headerlink" title="8.1 引言"></a>8.1 引言</h2><p>尽管不能保证从源端发往目的端的两份连续的IP数据报具有相同的路由，但是大多数情况下是这样的。Traceroute程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由。Traceroute程序还可以让我们使用IP源路由选项。</p>
<h2 id="8-2-Traceroute程序的操作"><a href="#8-2-Traceroute程序的操作" class="headerlink" title="8.2 Traceroute程序的操作"></a>8.2 Traceroute程序的操作</h2><p>在7.3节中，我们描述了IP记录路由选项（RR）。为什么不使用这个选项而另外开发一个新的应用程序？有三个方面的原因。</p>
<ul>
<li>Traceroute程序不需要中间路由器具备任何特殊的或可选的功能</li>
<li>Traceroute程序只需要目的端运行一个UDP模块—其他不需要任何特殊的服务器应用程序</li>
<li>最主要的原因是，在IP首部选项字段中最多只能存放9个IP地址</li>
</ul>
<p>TTL的初始值由分配数字RFC指定，当前值为64。发送ICMP回显应答时经常把TTL设为最大值255。</p>
<p>每个处理数据报的路由器都需要把TTL的值减1或减去数据报在路由器中停留的秒数。由于大多数的路由器转发数据报的时延都小于1秒钟，因此TTL最终成为一个跳站的计数器，所经过的每个路由器都将其值减1。</p>
<p>当路由器收到一份IP数据报，如果其TTL字段是0或1，路由器将该数据报丢弃，并给信源机发一份ICMP“超时”信息。</p>
<p>目的主机哪怕接收到TTL值为1的IP数据报，也不会丢弃该数据报并产生一份超时ICMP报文，这是因为数据报已经到达其最终目的地。那么我们该如何判断是否已经到达目的主机了呢？</p>
<p>Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于30 000），使目的主机的任何一个应用程序都不可能使用该端口。因为，当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”错误（见6.5节）的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。</p>
<h2 id="8-3-局域网输出"><a href="#8-3-局域网输出" class="headerlink" title="8.3 局域网输出"></a>8.3 局域网输出</h2><p>对于每个TTL值，发送3份数据报。每接收到一份ICMP报文，就计算并打印出往返时间。如果在5秒种内仍未收到3份数据报的任意一份的响应，则打印一个星号，并发送下一份数据报。</p>
<ul>
<li>目的主机UDP端口号最开始设置为33435，且每发送一个数据报加1。</li>
<li>traceroute程序将其发送的UDP数据报的源端口号设置为Unix进程号与32768之间的逻辑或值。对于在同一台主机上多次运行traceroute程序的情况，每个进程都查看ICMP返回的UDP首部的源端口号，并且只处理那些对自己发送应答的报文。</li>
</ul>
<p>当TTL值为0或1时，tcpdump打印出注释<code>[ttl 1]</code></p>
<p>有两种不同的ICMP“超时”报文（见6.2节的图6-3），它们的ICMP报文中code字段不同。图8-2给出了这种ICMP差错报文的格式。</p>
<ul>
<li>code字段为0：在TTL值等于0时产生</li>
<li>code字段为1：主机在组装分片时发生超时</li>
</ul>
<p>与Ping不一样的是，返回的数据报大小是变化的。从图6-9可以看出，返回的ICMP报文包含发生差错的数据报的IP首部以及紧随该IP首部的8字节数据</p>
<p>关于traceroute程序，还有一些必须指出的事项。</p>
<ul>
<li>并不能保证现在的路由也是将来所要采用的路由</li>
<li>不能保证ICMP报文的路由与traceroute程序发送的UDP数据报采用同一路由。</li>
<li>从A主机到B主机上运行traceroute程序和从B主机到A主机上运行traceroute程序所得到的结果可能是不同的。</li>
</ul>
<p>在广域网情况下，如果traceroute程序的输出是可读的域名形式，而不是IP地址形式，那么会更好理解一些。但是由于traceroute程序接收到ICMP报文时，它所获得的唯一信息就是IP地址，因此，在给定IP地址的情况下，它做一个“反向域名查看”工作来获得域名。这就需要路由器或主机的管理员正确配置其反向域名查看功能（并非所有的情况下都是如此）。</p>
<h2 id="8-4-广域网输出"><a href="#8-4-广域网输出" class="headerlink" title="8.4 广域网输出"></a>8.4 广域网输出</h2><h4 id="例子已理解-4"><a href="#例子已理解-4" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="8-5-IP源站选路选项"><a href="#8-5-IP源站选路选项" class="headerlink" title="8.5 IP源站选路选项"></a>8.5 IP源站选路选项</h2><p>源站选路(source routing)的思想是由发送者指定路由。它可以采用以下两种形式：</p>
<ol>
<li>严格的源路由选择。发送端指明IP数据报所必须采用的确切路由。如果一个路由器发现源路由所指定的下一个路由器不在其直接连接的网络上，那么它就返回一个“源站路由失败”的ICMP差错报文。</li>
<li>宽松的源站选路。发送端指明了一个数据报经过的IP地址清单，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器。</li>
</ol>
<p>Traceroute程序提供了一个查看源站选路的方法，我们可以在选项中指明源站路由，然后检查其运行情况。</p>
<p>这个格式与我们在图7-3中所示的记录路由选项格式基本一致。不同之处是，对于源站选路，我们必须在发送IP数据报前填充IP地址清单；而对于记录路由选项，我们需要为IP地址清单分配并清空一些空间，并让路由器填充该清单中的各项。</p>
<p>对于宽松的源站选路来说，code字段的值是0x83；而对于严格的源站选路，其值为0x89。len和ptr字段与7.3节中所描述的一样。</p>
<p>在图8-7中，我们假设主机S上的发送应用程序发送一份数据报给D，指定源路由为R1，R2和R3。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/8/images2/52im_net_9.png" alt="图8-7 IP源路由示例"></p>
<p>当一个应用程序接收到由信源指定路由的数据时，在发送应答时，应该读出接收到的路由值，并提供反向路由。</p>
<h3 id="8-5-1-宽松的源站选路的-traceroute-程序示例"><a href="#8-5-1-宽松的源站选路的-traceroute-程序示例" class="headerlink" title="8.5.1 宽松的源站选路的 traceroute 程序示例"></a>8.5.1 宽松的源站选路的 traceroute 程序示例</h3><p>使用traceroute程序的-g选项，可以为宽松的源站选路指明一些中间路由器。采用该选项可以最多指定8个中间路由器（其个数是8而不是9的原因是，所使用的编程接口要求最后的表目是目的主机）。</p>
<h4 id="例子已理解-5"><a href="#例子已理解-5" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>使用traceroute程序的-g选项，可以为宽松的源站选路指明一些中间路由器。采用该选项可以最多指定8个中间路由器（其个数是8而不是9的原因是，所使用的编程接口要求最后的表目是目的主机）。</p>
<h3 id="8-5-2-严格的源站选路的-traceroute-程序示例"><a href="#8-5-2-严格的源站选路的-traceroute-程序示例" class="headerlink" title="8.5.2 严格的源站选路的 traceroute 程序示例"></a>8.5.2 严格的源站选路的 traceroute 程序示例</h3><p>在作者的traceroute程序版本中，-G选项是严格的源站选路而不是宽松的源站选路。我们可以采用这个选项来观察在指明无效的严格的源站选路时其结果会是什么样的。</p>
<p>RTT后面的!S。这表明traceroute程序接收到ICMP“源站路由失败”的差错报文</p>
<p>在tcpdump中指定-v选项以显示出源站路由信息。宽松的源站选路和严格的源站选路，分别用LSRR和SSRR表示</p>
<h3 id="8-5-3-宽松的源站选路traceroute程序的往返路由"><a href="#8-5-3-宽松的源站选路traceroute程序的往返路由" class="headerlink" title="8.5.3 宽松的源站选路traceroute程序的往返路由"></a>8.5.3 宽松的源站选路traceroute程序的往返路由</h3><p>从A到B的路径并不一定与从B到A的路径完全一样。除非同时在两个系统中登录并在每个终端上运行traceroute程序，否则很难发现两条路径是否不同。但是，采用宽松的源站选路，就可以决定两个方向上的路径。</p>
<p>这里的窍门就在于指定一个宽松的源站路由，该路由的目的端和宽松路径一样，但发送端为目的主机。</p>
<h4 id="例子已理解-6"><a href="#例子已理解-6" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="8-6-小结"><a href="#8-6-小结" class="headerlink" title="8.6 小结"></a>8.6 小结</h2><p>略</p>
<h2 id="ch08-习题"><a href="#ch08-习题" class="headerlink" title="ch08 习题"></a>ch08 习题</h2><ol>
<li>当IP将接收到的TTL字段减1，发现它为0时，将会发生什么结果？</li>
</ol>
<ul>
<li>答案：如果一个输入数据报的TTL为0，做减一操作然后测试会将把TTL设置为255，并且让数据报继续传输。尽管一个路由器永远不会收到一个TTL为0的数据报，但这种情况确实会发生。</li>
</ul>
<ol>
<li>traceroute程序是如何计算RTT的？将这种计算RTT的方法与ping相比较。</li>
</ol>
<ul>
<li>答案：traceroute保存了它发送分组的时间，当收到一个ICMP应答时，取出当时的时间，把两个值相减就可以得出RTT。</li>
<li>回忆一下第7章中，ping在输出的ICMP回显请求中存储了时间，这个值被服务器回显了回来。这样即使分组返回时失序，ping也能打印出正确的RTT。</li>
</ul>
<ol>
<li>（本习题与下一道习题是基于开发traceroute程序过程中遇到的实际问题，它们来自于traceroute程序源代码注释）。假设源主机和目的主机之间有三个路由器（R1、R2和R3），而中间的路由器（R2）在进入TTL字段为1时，将TTL字段减1，但却错误地将该IP数据报发往下一个路由器。请描述会发生什么结果。在运行traceroute程序时会看到什么样的现象？</li>
</ol>
<ul>
<li>答案：第1行输出是正确的，并且标识了R1。下一个探测分组启动时将TTL置为2，并且这个值被R1减1。当R2收到这个分组时，把TTL从1减为0，但是错误地将它传递给了R3。R3看见进入的TTL是0就将超时的分组发送回来。这就意味着第2行输出（TTL为2）标识了R3，而不是R2。第3行输出正确地标识了R3。这个错误所表现出来的线索就是两个连续的输出行标识了同一个路由器。</li>
</ul>
<ol>
<li>同样，假设源主机和目的主机之间有三个路由器。由于目的主机上存在错误，因此，它总是将进入TTL值作为外出ICMP报文的TTL值。请描述这将发生什么结果，你会看到什么现象。</li>
</ol>
<ul>
<li>答案：TTL为1、2和3的行正确地标识了R1、R2和R3，接下来的三行每个都包含三个超时，再接下来的TTL为7的行标识了目的地。</li>
</ul>
<ol>
<li>在图8-8运行例子中，我们可以在sun和netb之间的SLIP链路上运行tcpdump程序。如果指定-v选项，就可以看到返回ICMP报文的TTL值。这样，我们可以看到进入netb、butch、Gabby和enss142.UT.westnet.net的TTL值分别为255、253、252和249。这是否为我们判断是否存在丢失路由器提供了额外的信息？</li>
</ol>
<ul>
<li>答案：未觉察的路由器没有正确地处理向外输出的UDP数据报，但它们都对返回的ICMP报文正确地进行了TTL减1操作。</li>
<li>我们必须在查看输入的TTL时非常小心，因为有时候一个和我们想要的不同的值可能是由于返回的ICMP报文采用了一条与输出UDP数据报不同的路径。</li>
</ul>
<ol>
<li>SunOS和SVR4都提供了带-l选项的ping版本，以提供松源选路。手册上说明，该选项可以与-R选项（指定记录路由选项）一起使用。如果已经进入到这些系统中，请尝试同时用这两个选项。其结果是什么？如果采用tcpdump来观测数据报，请描述其过程。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>比较ping和traceroute程序在处理同一台主机上客户的多个实例的不同点。</li>
</ol>
<ul>
<li>答案：ping的客户把ICMP回显请求报文（图7-1）的标识符字段设置为它的进程ID。ICMP回显应答报文包含同样值的标识符字段。每个客户都要查看这个返回的标识符字段，并且只处理那些它发送过的报文。</li>
<li>traceroute客户将它的UDP源端口号设置为它的进程ID和32768的逻辑或。因为返回的ICMP报文总是包含产生错误的IP数据报的前8个字节（图6-9），这8个字节包括了完整的UDP首部，所以这个源端口号在ICMP差错报文中被返回。</li>
</ul>
<ol>
<li>比较ping和traceroute程序在计算往返时间上的不同点。</li>
</ol>
<ul>
<li>答案：ping客户将ICMP回显请求报文的可选数据部分设置为分组发送的时间。这个可选的数据必须在ICMP回显应答中返回。这样使得即使分组返回时失序，客户也能计算出精确的回环时间。</li>
<li>traceroute客户不能这样操作，因为在ICMP差错报文中返回的只是UDP首部（图6-9），没有UDP数据。因此，traceroute必须记住它发送一个请求的时间，等待应答，然后计算两者的时间差。</li>
<li>这里显示了ping和traceroute的另一个不同点：ping每秒发送一个分组，而不管是否收到任何应答；traceroute发送一个请求，然后在发送下一个请求前等待一个应答或者一个超时。</li>
</ul>
<ol>
<li>我们已经说过，traceroute程序选取开始UDP目的主机端口号为33453，每发送一个数据报将此数加1。在1.9节中，我们说过暂时端口号通常是1024~5000之间的值，因此traceroute程序的目的主机端口号不可能是目的主机上所使用的端口号。在Solaris2.2系统中的情况也是如此吗？（提示：查看E.4节）</li>
</ol>
<ul>
<li>答案：因为默认情况下Solaris 2.2从32768开始使用临时的UDP端口，所以目的主机上的目的端口已经被使用的机会更大。</li>
</ul>
<ol>
<li>RFC 1393 [Malkin 1993b]提出了另一种判断到目的主机路径的方法。请问其优缺点是什么？</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<h1 id="ch09-IP选路"><a href="#ch09-IP选路" class="headerlink" title="ch09 IP选路"></a>ch09 IP选路</h1><h2 id="9-1-引言"><a href="#9-1-引言" class="headerlink" title="9.1 引言"></a>9.1 引言</h2><p>路由表经常被IP访问（在一个繁忙的主机上，一秒钟内可能要访问几百次），但是它被路由守护程序更新的频度却要低得多（可能大约30秒种一次）。当接收到ICMP重定向，报文时，路由表也要被更新</p>
<h2 id="9-2-选路的原理"><a href="#9-2-选路的原理" class="headerlink" title="9.2 选路的原理"></a>9.2 选路的原理</h2><p>IP执行选路机制，而路由守护程序则一般提供选路策略。</p>
<h3 id="9-2-1-简单路由表"><a href="#9-2-1-简单路由表" class="headerlink" title="9.2.1 简单路由表"></a>9.2.1 简单路由表</h3><p>先执行带-r选项的netstat命令列出路由表，然后以-n选项再次执行该命令，以数字格式打印出IP地址</p>
<p>对于一个给定的路由器，可以打印出五种不同的标志（flag）：</p>
<ul>
<li>U 该路由可以使用。</li>
<li>G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。</li>
<li>H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址：一个网络号，或者网络号与子网号的组合。</li>
<li>D 该路由是由重定向报文创建的（9.5节）。</li>
<li>M 该路由已被重定向报文修改（9.5节）。</li>
</ul>
<p>G标志区分了直接路由和间接路由。但是H标志表明，目的地址是一个完整的主机地址。</p>
<p>参考记数Refcnt（Reference count）列给出的是正在使用路由的活动进程个数。面向连接的协议如TCP在建立连接时要固定路由。</p>
<p>下一列（“use”）显示的是通过该路由发送的分组数。</p>
<p>最后一列（interface）是本地接口的名字。</p>
<p>Host Requirements RFC文档特别说明，IP层必须支持多个默认路由。但是，许多实现系统并不支持这一点。当存在多个默认路由时，一种常用的技术是按轮转方式使用它们</p>
<p>由于内核知道每个路由表项对应的接口，而且每个接口都有一个对应的子网掩码，因此每个路由表项都有一个隐含的子网掩码。</p>
<p>主机路由表的复杂性取决于主机所在网络的拓扑结构</p>
<ul>
<li>主机连在一个局域网上，只能访问局域网上的主机。这时路由表包含两项：一项是环回接口，另一项是局域网（如以太网）。</li>
<li>如果主机能够通过单个路由器访问其他网络（如Internet）时，那么就要进行下一步。一般情况下增加一个默认表项指向该路由器。</li>
<li>如果要新增其他的特定主机或网络路由，那么就要进行最后一步。</li>
</ul>
<h4 id="例子已理解-7"><a href="#例子已理解-7" class="headerlink" title="例子已理解"></a>例子已理解</h4><h3 id="9-2-2-初始化路由表"><a href="#9-2-2-初始化路由表" class="headerlink" title="9.2.2 初始化路由表"></a>9.2.2 初始化路由表</h3><p>每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。</p>
<p>到达主机或网络的路由如果不是直接相连的，那么就必须加入路由表。一个常用的方法是在系统引导时显式地在初始化文件中运行route命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route add default sun 1</span><br><span class="line">route add slip bsdi 1</span><br></pre></td></tr></table></figure>
<p>第3个参数（default和slip）代表目的端，第4个参数代表网关（路由器），最后一个参数代表路由的度量(metric)。route命令在度量值大于0时要为该路由设置G标志，否则，当耗费值为0时就不设置G标志。</p>
<p>初始化路由表的其他方法是运行路由守护程序（第10章）或者用较新的路由器发现协议（9.6节）。</p>
<h3 id="9-2-3-较复杂的路由表"><a href="#9-2-3-较复杂的路由表" class="headerlink" title="9.2.3 较复杂的路由表"></a>9.2.3 较复杂的路由表</h3><p>路由表中的目的地址就是点对点链路的另一端，网关地址为外出接口的本地IP地址</p>
<p>默认的路由表项的网关地址是路由器的地址，而不是SLIP链路的本地IP地址。其原因还是因为是间接路由，不是直接路由。</p>
<h3 id="9-2-4-没有到达目的地的路由"><a href="#9-2-4-没有到达目的地的路由" class="headerlink" title="9.2.4 没有到达目的地的路由"></a>9.2.4 没有到达目的地的路由</h3><p>如果路由表中没有默认项，而又没有找到匹配项，这时会发生什么情况呢？</p>
<ul>
<li>如果数据报是由本地主机产生的，那么就给发送该数据报的应用程序返回一个“主机不可达差错”或者“网络不可达差错”。</li>
<li>如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文。</li>
</ul>
<h2 id="9-3-ICMP主机与网络不可达差错"><a href="#9-3-ICMP主机与网络不可达差错" class="headerlink" title="9.3 ICMP主机与网络不可达差错"></a>9.3 ICMP主机与网络不可达差错</h2><p>当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文</p>
<p>但令人感兴趣的是，我们可以看到在返回差错报文之前，分组要在Internet上传送多远：</p>
<h4 id="例子已理解-8"><a href="#例子已理解-8" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>许多路由器只能在局部范围内工作。</p>
<p>顶层选路域维护大多数Internet网站的路由信息，而不使用默认路由。在Internet上存在5个这样的顶层选路域：NSFNET主干网、商业互联网交换（Commercial Internet Exchange: CIX）、NASA科学互联网（NASA Science Internet: NSI）、SprintLink以及欧洲IP主干网（EBONE）。</p>
<h2 id="9-4-转发或不转发"><a href="#9-4-转发或不转发" class="headerlink" title="9.4 转发或不转发"></a>9.4 转发或不转发</h2><p>一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用。如何进行这样的配置呢？</p>
<p>大多数伯克利派生出来的系统都有一个内核变量ipforwarding</p>
<h2 id="9-5-ICMP重定向差错"><a href="#9-5-ICMP重定向差错" class="headerlink" title="9.5 ICMP重定向差错"></a>9.5 ICMP重定向差错</h2><p>当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给IP数据报的发送端。这在概念上是很简单的，正如图9-3所示的那样。只有当主机可以选择路由器发送分组的情况下，我们才可能看到ICMP重定向报文（回忆我们在图7-6中看过的例子）。</p>
<ol>
<li>我们假定主机发送一份IP数据报给R1。这种选路决策经常发生，因为R1是该主机的默认路由。</li>
<li>R1收到数据报并且检查它的路由表，发现R2是发送该数据报的下一站。当它把数据报发送给R2时，R1检测到它正在发送的接口与数据报到达接口是相同的（即主机和两个路由器所在的LAN）。这样就给路由器发送重定向报文给原始发送端提供了线索。</li>
<li>R1发送一份ICMP重定向报文给主机，告诉它以后把数据报发送给R2而不是R1。</li>
</ol>
<p>重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。<br>ICMP重定向允许TCP/IP主机在进行选路时不需要具备智能特性，而把所有的智能特性放在路由器端。<br>连在LAN上的所有主机在启动时只需一个默认路由，通过接收重定向报文来逐步学习。</p>
<h3 id="9-5-1-一个例子"><a href="#9-5-1-一个例子" class="headerlink" title="9.5.1 一个例子"></a>9.5.1 一个例子</h3><p>子网140.252.1上的主机是如何访问作者所在子网（图中底下的四台主机）的呢？</p>
<ol>
<li>首先，如果在SLIP链路的一端只有一台主机，那么就要使用代理ARP（<a href="#4-6-ARP%E4%BB%A3%E7%90%86">4.6节</a>）。这意味着位于拓扑图顶部的子网（140.252.1）中的主机不需要其他特殊条件就可以访问主机sun（140.252.1.29）。位于netb上的代理ARP软件处理这些事情。</li>
<li>但是，当网络位于SLIP链路的另一端时，就要涉及到选路了。</li>
</ol>
<ul>
<li>一个办法是让所有的主机和路由器都知道路由器netb是网络140.252.13的网关。这可以<ul>
<li>在每个主机的路由表中设置静态路由</li>
<li>或者在每个主机上运行守护程序来实现。</li>
</ul>
</li>
<li>另一个更简单的办法（也是实际采用的方法）是利用ICMP重定向报文来实现。</li>
</ul>
<p>如果为ping程序指定-v选项，可以看到主机接收到的任何ICMP报文。我们需要指定该选项以观察发送的重定向报文。<code>ICMP Host redirect from ... to ... for ...</code></p>
<h3 id="9-5-2-更多的细节"><a href="#9-5-2-更多的细节" class="headerlink" title="9.5.2 更多的细节"></a>9.5.2 更多的细节</h3><p>ICMP重定向报文的格式如图9-4所示。</p>
<p>有四种不同类型的重定向报文，有不同的代码值，如图9-5所示。</p>
<p>ICMP重定向报文的接收者必须查看三个IP地址：(1)导致重定向的IP地址（即ICMP重定向报文的数据网络重定向主机重定向位于IP数据报的首部）；(2)发送重定向报文的路由器的IP地址（包含重定向信息的IP数据报中的源地址；(3)应该采用的路由器IP地址（在ICMP报文中的4~7字节）。</p>
<p>关于ICMP重定向报文有很多规则。首先，重定向报文只能由路由器生成，而不能由主机生成。另外，重定向报文是为主机而不是为路由器使用的。假定路由器和其他一些路由器共同参与某一种选路协议，则该协议就能消除重定向的需要</p>
<p>路由器应该发送的只是对主机的重定向（代码1或3，如图9-5所示），而不是对网络的重定向。子网的存在使得难于准确指明何时应发送对网络的重定向而不是对主机的重定向。</p>
<h2 id="9-6-ICMP路由器发现报文"><a href="#9-6-ICMP路由器发现报文" class="headerlink" title="9.6 ICMP路由器发现报文"></a>9.6 ICMP路由器发现报文</h2><p>初始化路由表的方法</p>
<ul>
<li>在配置文件中指定静态路由.</li>
<li>利用ICMP路由器通告和请求报文。</li>
</ul>
<p>一般认为，主机在引导以后要广播或多播传送一份路由器请求报文。一台或更多台路由器响应一份路由器通告报文。另外，路由器定期地广播或多播传送它们的路由器通告报文，允许每个正在监听的主机相应地更新它们的路由表。</p>
<p>ICMP路由器请求报文的格式如图9-6所示。ICMP路由器通告报文的格式如图9-7所示。</p>
<p>路由器在一份报文中可以通告多个地址。地址数指的是报文中所含的地址数。地址项大小指的是每个路由器地址32 bit字的数目，始终为2。生存期指的是通告地址有效的时间（秒数）。</p>
<p>接下来是一对或多对IP地址和优先级。IP地址必须是发送路由器的某个地址。优先级是一个有符号的32 bit整数，指出该IP地址作为默认路由器地址的优先等级，这是与子网上的其他路由器相比较而言的。值越大说明优先级越高。优先级为0x80000000说明对应的地址不能作为默认路由器地址使用，尽管它也包含中通告报文中。优先级的默认值一般为0。</p>
<h3 id="9-6-1-路由器操作"><a href="#9-6-1-路由器操作" class="headerlink" title="9.6.1 路由器操作"></a>9.6.1 路由器操作</h3><p>当路由器启动时，它定期在所有广播或多播传送接口上发送通告报文。</p>
<p>当路由器上的某个接口被关闭时，路由器可以在该接口上发送最后一份通告报文，并把生命周期值设为0。</p>
<p>路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。</p>
<p>如果子网上有多台路由器，由系统管理员为每个路由器设置优先等级。</p>
<h3 id="9-6-2-主机操作"><a href="#9-6-2-主机操作" class="headerlink" title="9.6.2 主机操作"></a>9.6.2 主机操作</h3><p>主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。</p>
<p>主机也监听来自相邻路由器的请求报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。</p>
<p>只要有一般的默认路由器，该路由器就会每隔10分钟发送通告报文，报文的生命周期是30分钟。这说明主机的默认表项是不会超时的，即使错过一份或两份通告报文。</p>
<h3 id="9-6-3-实现"><a href="#9-6-3-实现" class="headerlink" title="9.6.3 实现"></a>9.6.3 实现</h3><p>路由器发现报文一般由用户进程（守护程序）创建和处理。</p>
<p>这两种ICMP报文是新加的，不是所有的系统都支持它们。</p>
<h2 id="9-7-小结"><a href="#9-7-小结" class="headerlink" title="9.7 小结"></a>9.7 小结</h2><p>路由表项的内容很简单，包括：5bit标志、目的IP地址（主机、网络或默认）、下一站路由器的IP地址（间接路由）或者本地接口的IP地址（直接路由）及指向本地接口的指针。</p>
<h2 id="ch09-习题"><a href="#ch09-习题" class="headerlink" title="ch09 习题"></a>ch09 习题</h2><ol>
<li>为什么你认为存在两类ICMP重定向报文—网络和主机？</li>
</ol>
<ul>
<li>答案：当ICMP标准第1次发布时，RFC 792 [Postel 1981b]所述的划分子网技术还没有使用。另外，使用一个网络重定向而不是N个主机重定向（对于目的网络中的所有N个主机）也节省了路由表的空间。</li>
</ul>
<ol>
<li>在9.2节开头列出的svr4主机上的路由表中，到主机slip（140.252.13.65）的特定路由是必需的吗？如果把这一项从路由表中删除会有什么变化？</li>
</ol>
<ul>
<li>答案：这一项并不需要，但是如果把它删除了，所有到slip的IP数据报将被发送到默认的路由器（sun），后者又将把它们送到路由器bsdi。既然sun将数据报从与接收数据报相同的接口转发出去，它把一个ICMP重定向到svr4。这样在svr4中又创建了我们删除过的同样的路由表项，尽管这一次是因为重定向而创建的，而不是在引导时增加的。</li>
</ul>
<ol>
<li>考虑有一电缆连接4.2BSD主机和4.3BSD主机。假定网络号是140.1。4.2BSD主机把主机号为全0的地址识别为广播地址(140.1.0.0)，而4.3BSD通常使用全1的主机号（140.1.255.255）发送广播。另外，4.2BSD主机在默认条件下要尽力转发接收到的数据报，尽管它们只有一个接口。请描述当4.2BSD主机收到一份目的地址为140.1.255.255的IP数据报时会发生什么事。</li>
</ol>
<ul>
<li>答案：当那个4.2BSD主机收到目的地址是140.1.255.255的数据报，发现它有一个通往该网络（140.1）的路由，因此就试图转发数据报。它发送一个ARP广播来寻找140.1.255.255。这个ARP请求没有收到任何应答，所以这个数据报最终被丢弃。如果在网线上有很多这样的4.2BSD主机，每一个都在差不多同一时刻发送ARP这个广播，将会暂时地阻塞网络。</li>
</ul>
<ol>
<li>继续前一个习题，假定有人在子网140.1上的某个系统ARP高速缓存中增加了一项（用arp命令）内容，指定IP地址140.1.255.255对应的以太网地址为全1（以太网广播地址）。请描述此时发生的情况。</li>
</ol>
<ul>
<li>答案：这次，每一个ARP请求都收到一个应答，告诉每个4.2BSD主机向一个指定的硬件地址（以太网广播）发送数据报。如果网线上有k个这样的4.2BSD主机，全部收到了它们自己的ARP应答，使得每一个生成了另一个广播。每个主机都收到了每一个目的地址为140.1.255.255的广播IP数据报，既然现在每个主机都有一个ARP缓存项，这个数据报又被转发给了广播地址。这个过程继续下去，就会产生一次以太网的熔毁(Ethernetmeltdown)。[Manber 1990]描述了网络中另一种形式的链式反应。</li>
</ul>
<ol>
<li>检查你所使用的系统上的路由表，并解释每一项内容。</li>
</ol>
<ul>
<li>无答案。已上机实验</li>
</ul>
<h1 id="ch10-动态选路协议"><a href="#ch10-动态选路协议" class="headerlink" title="ch10 动态选路协议"></a>ch10 动态选路协议</h1><h2 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言"></a>10.1 引言</h2><p>在前面各章中，我们讨论了静态选路。在配置接口时，以默认方式生成路由表项（对于直接连接的接口），并通过route命令增加表项（通常从系统自引导程序文件），或是通过ICMP重定向生成表项（通常是在默认方式出错的情况下）。</p>
<p>在网络很小，且与其他网络只有单个连接点且没有多余路由时（若主路由失败，可以使用备用路由），采用这种方法是可行的。如果上述三种情况不能全部满足，通常使用动态选路。</p>
<h2 id="10-2-动态选路"><a href="#10-2-动态选路" class="headerlink" title="10.2 动态选路"></a>10.2 动态选路</h2><p>动态选路并不改变我们在9.2节中所描述的内核在IP层的选路方式。这种选路方式称为选路机制（routing mechanism）。<br>仅仅是放置到路由表中的信息改变了</p>
<p>Internet是以一组自治系统(AS，Autonomous System)的方式组织的，每个自治系统通常由单个实体管理。</p>
<p>每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为内部网关协议IGP（Interior Gateway Protocol）或域内选路协议（intradomain routing protocol）。</p>
<h2 id="10-3-Unix选路守护程序"><a href="#10-3-Unix选路守护程序" class="headerlink" title="10.3 Unix选路守护程序"></a>10.3 Unix选路守护程序</h2><p>Unix系统上常常运行名为routed路由守护程序。</p>
<p>图10-1对routed和两种不同版本的gated所支持的不同选路协议进行了比较。大多数运行路由守护程序的系统都可以运行routed，除非它们需要支持gated所支持的其他协议。</p>
<h2 id="10-4-RIP：选路信息协议"><a href="#10-4-RIP：选路信息协议" class="headerlink" title="10.4 RIP：选路信息协议"></a>10.4 RIP：选路信息协议</h2><h3 id="10-4-1-报文格式"><a href="#10-4-1-报文格式" class="headerlink" title="10.4.1 报文格式"></a>10.4.1 报文格式</h3><p>RIP报文包含中在UDP数据报中</p>
<p>图10-3给出了使用IP地址时的RIP报文格式。</p>
<p>命令字段为1表示请求，2表示应答。还有两个舍弃不用的命令（3和4），两个非正式的命令：轮询（5）和轮询表项（6）。请求表示要求其他系统发送其全部或部分路由表。应答则包含发送者全部或部分路由表。</p>
<p>版本字段通常为1，而第2版RIP（10.5节）将此字段设置为2。</p>
<p>紧跟在后面的20字节指定地址系列（address family）（对于IP地址来说，其值是2）、IP地址以及相应的度量。在本节的后面可以看出，RIP的度量是以跳计数的。</p>
<p>采用这种20字节格式的RIP报文可以通告多达25条路由。<br>为了发送整个路由表，经常需要多个报文。</p>
<h3 id="10-4-2-正常运行"><a href="#10-4-2-正常运行" class="headerlink" title="10.4.2 正常运行"></a>10.4.2 正常运行</h3><p>让我们来看一下采用RIP协议的routed程序正常运行的结果。RIP常用的UDP端口号是520。</p>
<ul>
<li>初始化：在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。</li>
<li>接收到请求。如果这个请求是刚才提到的特殊请求，那么路由器就将完整的路由表发送给请求者。否则，就处理请求中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量置为16</li>
<li>接收到响应。使响应生效，可能会更新路由表。可能会增加新表项，对已有的表项进行修改，或是将已有表项删除。</li>
<li>定期选路更新。每过30秒，所有或部分路由器会将其完整路由表发送给相邻路由器。<br>触发更新。每当一条路由的度量发生变化时，就对它进行更新。不需要发送完整路由表，而只需要发送那些发生变化的表项。</li>
</ul>
<p>每条路由都有与之相关的定时器。如果运行RIP的系统发现一条路由在3分钟内未更新，就将该路由的度量设置成无穷大（16），并标注为删除。这意味着已经在6个30秒更新时间里没收到通告该路由的路由器的更新了。再过60秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。</p>
<h3 id="10-4-3-度量"><a href="#10-4-3-度量" class="headerlink" title="10.4.3 度量"></a>10.4.3 度量</h3><p>RIP所使用的度量是以跳(hop)计算的。所有直接连接接口的跳数为1。</p>
<p>度量为16表示到无路由到达该IP地址。</p>
<h3 id="10-4-4-问题"><a href="#10-4-4-问题" class="headerlink" title="10.4.4 问题"></a>10.4.4 问题</h3><p>这种方法看起来很简单，但它有一些缺陷。首先，RIP没有子网地址的概念。<br>有一些实现中通过接收到的RIP信息，来使用接口的网络掩码，而这有可能出错。</p>
<p>其次，在路由器或链路发生故障后，需要很长的一段时间才能稳定下来。这段时间通常需要几分钟。</p>
<h3 id="10-4-5-举例"><a href="#10-4-5-举例" class="headerlink" title="10.4.5 举例"></a>10.4.5 举例</h3><p>ripquery程序通过发送一个非正式请求（图10-3中命令字段为5的“poll”）给路由器，要求得到其完整的路由表。如果在5秒内未收到响应，则发送标准的RIP请求</p>
<p>我们为tcpdump程序指定-s600选项，以让它从网络中读取600个字节。采用-i s10选项指定SLIP接口。</p>
<p>英文输出</p>
<ul>
<li><code>metric 2</code>表示度量为2</li>
<li><code>rip-poll 24</code>表示RIP轮询命令；请求报文的长度为24</li>
<li><code>rip-req 24</code>表示常规的RIP请求；请求报文的长度为24</li>
<li><code>rip-resp 25</code>表示应答报文，又叫响应报文；包含了25个地址和度量对</li>
</ul>
<h3 id="10-4-6-另一个例子"><a href="#10-4-6-另一个例子" class="headerlink" title="10.4.6 另一个例子"></a>10.4.6 另一个例子</h3><p>snoop程序只捕获广播报文、多播报文以及发送给主机的报文。</p>
<p>-P标志以非混杂模式捕获报文，-tr打印出相应的时戳，而udp port 520只捕获信源或信宿端口号为520的UDP数据报。</p>
<p>加上-v参数来查看RIP报文的全部内容</p>
<p>snoop输出“BROADCAST”符号，它表示目的IP地址是有限的广播地址255.255.255.255（12.2节），而不是其他路由器用来指向子网的广播地址</p>
<h2 id="10-5-RIP版本2"><a href="#10-5-RIP版本2" class="headerlink" title="10.5 RIP版本2"></a>10.5 RIP版本2</h2><p>RIP-2并不改变协议本身，而是利用图10-3中的一些标注为“必须为0”的字段来传递一些额外的信息。</p>
<p>图10-10重新给出了由RIP-2定义的图。对于RIP-2来说，其版本字段为2。</p>
<p>选路域(routing domain)允许管理者在单个路由器上运行多个RIP实例，每个实例在一个选路域内运行。</p>
<p>选路标记(routing tag)是为了支持外部网关协议而存在的。它携带着一个EGP和BGP的自治系统号。</p>
<p>每个表项的子网掩码应用于相应的IP地址上。下一站IP地址指明发往目的IP地址的报文该发往哪里。该字段为0意味着发往目的地址的报文应该发给发送RIP报文的系统。</p>
<p>RIP-2提供了一种简单的鉴别机制。可以指定RIP报文的前20字节表项地址系列为0xffff，路由标记为2。表项中的其余16字节包含一个明文口令。</p>
<p>最后，RIP-2除了广播（第12章）外，还支持多播。这可以减少不收听RIP-2报文的主机的负载。</p>
<h2 id="10-6-OSPF：开放最短路径优先"><a href="#10-6-OSPF：开放最短路径优先" class="headerlink" title="10.6 OSPF：开放最短路径优先"></a>10.6 OSPF：开放最短路径优先</h2><p>与采用距离向量的RIP协议不同的是，OSPF是一个链路状态协议。</p>
<p>链路状态协议总是比距离向量协议收敛更快。</p>
<p>OSPF直接使用IP。也就是说，它并不使用UDP或TCP。对于IP首部的protocol字段，OSPF有其自己的值</p>
<p>OSPF还有着一些优于RIP的特点。</p>
<ul>
<li>OSPF可以对每个IP服务类型（图3-2）计算各自的路由集。这意味着对于任何目的，可以有多个路由表表项，每个表项对应着一个IP服务类型。</li>
<li>给每个接口指派一个无维数的费用。可以通过吞吐率、往返时间、可靠性或其他性能来进行指派。可以给每个IP服务类型指派一个单独的费用。</li>
<li>当对同一个目的地址存在着多个相同费用的路由时，OSPF在这些路由上平均分配流量。我们称之为流量平衡。</li>
<li>OSPF支持子网：子网掩码与每个通告路由相连。这样就允许将一个任何类型的IP地址分割成多个不同大小的子网（我们在3.7节中给出了这样的一个例子，称之为变长度子网）。到一个主机的路由是通过全1子网掩码进行通告的。默认路由是以IP地址为0.0.0.0、网络掩码为全0进行通告的。</li>
<li>路由器之间的点对点链路不需要每端都有一个IP地址，我们称之为无编号网络。这样可以节省IP地址—现在非常紧缺的一种资源。</li>
<li>采用了一种简单鉴别机制。可以采用类似于RIP-2机制（10.5节）的方法指定一个明文口令。</li>
<li>OSPF采用多播（第12章），而不是广播形式，以减少不参与OSPF的系统负载。</li>
</ul>
<h2 id="10-7-BGP：边界网关协议"><a href="#10-7-BGP：边界网关协议" class="headerlink" title="10.7 BGP：边界网关协议"></a>10.7 BGP：边界网关协议</h2><p>可以将Internet的总拓扑结构看成是由一些残桩自治系统、多接口自治系统以及转送自治系统的任意互连。残桩自治系统和多接口自治系统不需要使用BGP——它们通过运行EGP在自治系统之间交换可到达信息。</p>
<p>指定策略允许BGP实现在存在多个可选路径时选择路径，并控制信息的重发送。选路策略与政治、安全或经济因素有关。</p>
<p>BGP与RIP和OSPF的不同之处在于BGP使用TCP作为其传输层协议。</p>
<h2 id="10-8-CIDR：无类型域间选路"><a href="#10-8-CIDR：无类型域间选路" class="headerlink" title="10.8 CIDR：无类型域间选路"></a>10.8 CIDR：无类型域间选路</h2><p>每个C类网络都需要一个路由表表项。无类型域间选路（CIDR）是一个防止Internet路由表膨胀的方法，它也称为超网（supernetting）。</p>
<p>CIDR的基本观点是采用一种分配多个IP地址的方式，使其能够将路由表中的许多表项总和(summarization)成更少的数目。</p>
<p>要使用这种总和，必须满足以下三种特性：</p>
<ul>
<li>这些IP地址必须具有相同的高位地址比特。</li>
<li>路由表和选路算法必须扩展成根据32 bit IP地址和32 bit掩码做出选路决策。</li>
<li>必须扩展选路协议使其除了32 bit地址外，还要有32 bit掩码。OSPF（10.6节）和RIP-2（10.5节）都能够携带第4版BGP所提出的32 bit掩码。</li>
</ul>
<p>CIDR同时还使用一种技术，使最佳匹配总是最长的匹配</p>
<p>“无类型”的意思是现在的选路决策是基于整个32 bit IP地址的掩码操作，而不管其IP地址是A类、B类或是C类，都没有什么区别。</p>
<h2 id="10-9-小结"><a href="#10-9-小结" class="headerlink" title="10.9 小结"></a>10.9 小结</h2><ol>
<li>在图10-9中哪些路由是从路由器kpno进入gateway的？</li>
</ol>
<ul>
<li>答案：路由表中有13条来自于kpno：除了140.252.101.0和140.252.104.0之外的所有gateway直接相连的其他网络。</li>
</ul>
<ol>
<li>假设一个路由器要使用RIP通告30个路由，这需要一个包含25条路由和另一个包含5条路由的数据报。如果每过一个小时，第一个包含25条路由的数据报丢失一次，那么其结果如何？</li>
</ol>
<ul>
<li>答案：丢失的数据报中通告的25条路由需要60秒才能得到更新。这不成问题，因为一般来说一条路由如果连续3分钟没有得到更新，RIP才会声明它失效。</li>
</ul>
<ol>
<li>OSPF报文格式中有一个检验和字段，而RIP报文则没有此项，这是为什么？</li>
</ol>
<ul>
<li>答案：RIP运行在UDP上，而UDP提供了UDP数据报中数据部分的一个可选的检验和（11.3节）。然而，OSPF运行在IP上，IP的检验和只覆盖了IP首部，所以OSPF必须增加它自己的检验和字段。</li>
</ul>
<ol>
<li>像OSPF这样的负载平衡，对于传输层的影响是什么？</li>
</ol>
<ul>
<li>答案：负载平衡增加了分组被失序交付的机会，并且很可能使得运输层计算的环回时间出错。</li>
</ul>
<ol>
<li>查阅RFC1058 关于实现RIP的其他资料。在图10-8中，140.252.1网络的每个路由器只通告它所提供的路由，而它并不能通过其他路由器的广播中知道任何其他路由。这种技术的名称是什么？</li>
</ol>
<ul>
<li>答案：这叫作简单的分裂范围（split horizon）。</li>
</ul>
<ol>
<li>在3.4节中，我们说过除了图10-7中所示的8个路由器外，140.252.1子网上还有超过100个主机。那么这100个主机是如何处理每30秒到达它们的8个广播信息呢（图10-8）？</li>
</ol>
<ul>
<li>答案：在图12-1中，我们显示了100个主机的每一个都通过设备驱动程序、IP层和UDP层来处理这个广播的UDP数据报。当它们发现UDP端口520没有被使用时，这个广播数据报才最终被丢弃。</li>
</ul>
<h1 id="ch11-UDP：用户数据报协议"><a href="#ch11-UDP：用户数据报协议" class="headerlink" title="ch11 UDP：用户数据报协议"></a>ch11 UDP：用户数据报协议</h1><h2 id="11-1-引言"><a href="#11-1-引言" class="headerlink" title="11.1 引言"></a>11.1 引言</h2><p>UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP</p>
<h2 id="11-2-UDP首部"><a href="#11-2-UDP首部" class="headerlink" title="11.2 UDP首部"></a>11.2 UDP首部</h2><p>UDP首部的各字段如图11-2所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0            15 16            31</span><br><span class="line">+--------------+---------------+</span><br><span class="line">| 16位源端口号 | 16位目的端口号|</span><br><span class="line">+--------------+---------------+</span><br><span class="line">| 16位UDP长度  | 16位UDP检验和 |</span><br><span class="line">+--------------*---------------+</span><br><span class="line">|         数据（如果有）       |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure>
<p>端口号表示发送进程和接收进程。<br>IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值）</p>
<p>UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的UDP数据报是OK）。</p>
<h2 id="11-3-UDP检验和"><a href="#11-3-UDP检验和" class="headerlink" title="11.3 UDP检验和"></a>11.3 UDP检验和</h2><p>UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部</p>
<p>其次，UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）。UDP数据报中的伪首部格式如图11-3所示。</p>
<p>TCP的检验和是必需的。UDP的检验和是可选的。如果检验和的计算结果为0，则存入的值为全1（65535），这在二进制反码计算中是等效的。如果传送的检验和为0，说明发送端没有计算检验和。</p>
<h3 id="11-3-1-tcpdump输出"><a href="#11-3-1-tcpdump输出" class="headerlink" title="11.3.1 tcpdump输出"></a>11.3.1 tcpdump输出</h3><p>作者在tcpdump程序中增加了一个选项</p>
<p><code>udp 9 (UDP cksum=0)</code>表示包含9个字节数据的UDP数据报，它没有计算检验和</p>
<h3 id="11-3-2-一些统计结果"><a href="#11-3-2-一些统计结果" class="headerlink" title="11.3.2 一些统计结果"></a>11.3.2 一些统计结果</h3><p>TCP发生检验和差错的比例与UDP相比要高得多。这很可能是因为在该系统中的TCP连接经常是“远程”连接（经过许多路由器和网桥等中间设备），而UDP一般为本地通信。</p>
<h2 id="11-4-一个简单的例子"><a href="#11-4-一个简单的例子" class="headerlink" title="11.4 一个简单的例子"></a>11.4 一个简单的例子</h2><p>用我们自己编写的sock程序生成一些可以通过tcpdump观察的UDP数据报：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bsdi % sock -v -u -i -n4 svr4 discard</span><br><span class="line">connected on 140.252.13.35.1108 to 140.252.13.34.9</span><br><span class="line">bsdi % sock -v -u -i -n4 -w0 svr4 discard</span><br><span class="line">connected on 140.252.13.35.1110 to 140.252.13.34.9</span><br></pre></td></tr></table></figure>
<p>第1次执行这个程序时，我们指定verbose模式（-v）来观察ephemeral端口号，指定UDP（-u）而不是默认的TCP，并且指定源模式（-i）来发送数据，而不是读写标准的输入和输出。-n4选项指明输出4份数据报（默认条件下为1024），目的主机为svr4。在1.12节描述了丢弃服务。每次写操作的输出长度取默认值1024。</p>
<p>第2次运行该程序时我们指定-w0，意思是写长度为0的数据报。</p>
<p>每次运行程序时，源端的UDP端口号都发生变化。</p>
<h2 id="11-5-IP分片"><a href="#11-5-IP分片" class="headerlink" title="11.5 IP分片"></a>11.5 IP分片</h2><p>正如我们在2.8节描述的那样，物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</p>
<p>把一份IP数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。IP首部中包含的数据为分片和重新组装提供了足够的信息。</p>
<p>回忆IP首部（图3-1）的标志字段</p>
<ul>
<li>其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置1。片偏移字段指的是该片偏移原始数据报开始处的位置。另外，当数据报被分片后，每个片的总长度值要改为该片的长度值。</li>
<li>有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。相反把数据报丢弃并发送一个ICMP差错报文（“需要进行分片但设置了不分片比特”，见图6-3）给起始端。</li>
</ul>
<p>尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报。</p>
<p>如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。</p>
<p>我们可以用sock程序来增加数据报的长度，直到分片发生。</p>
<p>相应的tcpdump输出中，<code>(frag 36304:1480@0+)</code>表示IP首部中标识字段的值为26304，除IP首部外的片长为1480，位于@符号后的数字是从数据报开始处计算的片偏移值</p>
<p>任何运输层首部只出现在第1片数据中。</p>
<p>另外需要解释几个术语：IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后），分组是指在IP层和链路层之间传送的数据单元。一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。</p>
<h2 id="11-6-ICMP不可达差错（需要分片）"><a href="#11-6-ICMP不可达差错（需要分片）" class="headerlink" title="11.6 ICMP不可达差错（需要分片）"></a>11.6 ICMP不可达差错（需要分片）</h2><p>发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果某个程序需要判断到达目的端的路途中最小MTU是多少—称作路径MTU发现机制（2.9节），那么这个差错就可以被该程序使用。</p>
<p>这种情况下的ICMP不可达差错报文格式如图11-9所示。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在点到点的链路中，不要求两个方向的MTU为相同值。</p>
<p>所采用的技术是在主机solaris上运行ping程序到主机bsdi，增加数据分组长度，直到看见进入的分组被分片为止。</p>
<p>相应的tcpdump输出中</p>
<ul>
<li>(DF) 说明在IP首部中设置了不分片比特。</li>
<li>mtu=0 表示主机sun没有在ICMP不可达报文中返回出口MTU值</li>
</ul>
<p>DF标志被复制到回显应答报文中。这就带来了问题。</p>
<p>分组的路径如图11-12所示。</p>
<h2 id="11-7-用Traceroute确定路径MTU"><a href="#11-7-用Traceroute确定路径MTU" class="headerlink" title="11.7 用Traceroute确定路径MTU"></a>11.7 用Traceroute确定路径MTU</h2><p>尽管大多数的系统不支持路径MTU发现功能，但可以很容易地修改traceroute程序（第8章），用它来确定路径MTU。要做的是发送分组，并设置“不分片”标志比特。发送的第一个分组的长度正好与出口MTU相等，每次收到ICMP“不能分片”差错时（在上一节讨论的）就减小分组的长度。如果路由器发送的ICMP差错报文是新格式，包含出口的MTU，那么就用该MTU值来发送，否则就用下一个最小的MTU值来发送。</p>
<h4 id="例子已理解-9"><a href="#例子已理解-9" class="headerlink" title="例子已理解"></a>例子已理解</h4><h3 id="全球互联网"><a href="#全球互联网" class="headerlink" title="全球互联网"></a>全球互联网</h3><p>现在许多但不是所有的广域网都可以处理大于512字节的分组。利用路径MTU发现机制，应用程序就可以充分利用更大的MTU来发送报文。</p>
<h2 id="11-8-采用UDP的路径MTU发现"><a href="#11-8-采用UDP的路径MTU发现" class="headerlink" title="11.8 采用UDP的路径MTU发现"></a>11.8 采用UDP的路径MTU发现</h2><p>如果应用程序写了一个对于一些中间链路来说太长的数据报时会发生什么情况。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>可以用下面的命令行来产生650字节UDP数据报，每两个UDP数据报之间的间隔是5秒：<br><code>solaris %sock -u -i -n10 -w650 -p5 slip discard</code></p>
<p>在本例中，solaris不应该对外出数据报分片，它应该将DF比特置0，让具有最小MTU的路由器来完成分片工作。</p>
<h2 id="11-9-UDP和ARP之间的交互作用"><a href="#11-9-UDP和ARP之间的交互作用" class="headerlink" title="11.9 UDP和ARP之间的交互作用"></a>11.9 UDP和ARP之间的交互作用</h2><p>我们用sock程序来产生一个包含8192字节数据的UDP数据报。预测这将会在以太网上产生6个数据报片（见习题11.3）。同时也确保在运行该程序前，ARP缓存是清空的，这样，在发送第一个数据报片前必须交换ARP请求和应答。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bsdi % arp -a         #验证ARP高速缓存是空的</span><br><span class="line">bsdi % sock -u -i -nl -w8192 svr4 discard</span><br></pre></td></tr></table></figure>
<p>两个问题：在接收到ARP回答前，其余数据报片是否已经做好了发送准备？如果是这样，那么在ARP等待应答时，它会如何处理发往给定目的的多个报文？</p>
<ul>
<li>在第一个ARP应答返回以前，总共产生了6个ARP请求。我们认为其原因是IP很快地产生了6个数据报片，而每个数据报片都引发了一个ARP请求。</li>
<li>在接收到第一个ARP应答时（第7行），只发送最后一个数据报片（第9行）！看来似乎将前5个数据报片全都丢弃了。实际上，这是ARP的正常操作。<br>在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机。</li>
</ul>
<p>Host Requirements RFC要求实现中必须防止这种类型的ARP洪泛（ARP flooding，即以高速率重复发送到同一个IP地址的ARP请求）。建议最高速率是每秒一次。</p>
<p>在给定数据报的第一个到达数据报片出现时，IP层必须启动一个定时器。如果定时器超时而该数据报的所有数据报片未能全部到达，那么将这些数据报片丢弃。如果不这么做，那些永远不会到达的数据报片（正如我们在本例中所看到的那样）迟早会引起接收端缓存满。</p>
<p>最后要指出的是，在最后一个ARP应答返回后，并没有发送ICMP“组装超时”差错。原因有两个</p>
<ul>
<li>大多数从Berkeley派生的实现从不产生该差错！这些实现会设置定时器，也会在定时器溢出时将数据报片丢弃，但是不生成ICMP差错。</li>
<li>并未接收到包含UDP首部的偏移量为0的第一个数据报片</li>
</ul>
<h2 id="11-10-最大UDP数据报长度"><a href="#11-10-最大UDP数据报长度" class="headerlink" title="11.10 最大UDP数据报长度"></a>11.10 最大UDP数据报长度</h2><p>除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。</p>
<p>我们将遇到两个限制因素。</p>
<ul>
<li>第一，应用程序可能会受到其程序接口的限制。</li>
<li>第二个限制来自于TCP/IP的内核实现。</li>
</ul>
<p>在3.2节中提过，要求主机必须能够接收最短为576字节的IP数据报。在许多UDP应用程序的设计中，其应用程序数据被限制成512字节或更小，因此比这个限制值小。</p>
<h3 id="数据报截断"><a href="#数据报截断" class="headerlink" title="数据报截断"></a>数据报截断</h3><p>由于IP能够发送或接收特定长度的数据报并不意味着接收应用程序可以读取该长度的数据。因此，UDP编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？</p>
<p>不幸的是，该问题的答案取决于编程接口和实现。</p>
<h2 id="11-11-ICMP源站抑制差错"><a href="#11-11-ICMP源站抑制差错" class="headerlink" title="11.11 ICMP源站抑制差错"></a>11.11 ICMP源站抑制差错</h2><p>当一个系统（路由器或主机）接收数据报的速度比其处理速度快时，<strong>可能</strong>产生这个差错。</p>
<p>图11-18给出了ICMP源站抑制差错报文的格式。有一个很好的方案可以在我们的测试网络里产生该差错报文。</p>
<p><code>sock -u -i -w1024 -n100 solaris discard</code>从主机bsdi通过路由器sun发送100个1024字节长数据报给solaris。</p>
<p>相对应的tcpdump输出中，<code>icmp source quench</code>表示源站抑制差错报文</p>
<p>由于源站抑制要消耗网络带宽，且对于拥塞来说是一种无效而不公平的调整，因此现在人们对于源站抑制差错的态度是不支持的。</p>
<h2 id="11-12-UDP服务器的设计"><a href="#11-12-UDP服务器的设计" class="headerlink" title="11.12 UDP服务器的设计"></a>11.12 UDP服务器的设计</h2><h3 id="11-12-1-客户IP地址及端口号"><a href="#11-12-1-客户IP地址及端口号" class="headerlink" title="11.12.1 客户IP地址及端口号"></a>11.12.1 客户IP地址及端口号</h3><p>这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户发回应答。</p>
<h3 id="11-12-2-目的IP地址"><a href="#11-12-2-目的IP地址" class="headerlink" title="11.12.2 目的IP地址"></a>11.12.2 目的IP地址</h3><p>一些应用程序需要知道数据报是发送给谁的。</p>
<p>这就要求操作系统从接收到的UDP数据报中将目的IP地址交给应用程序。不幸的是，并非所有的实现都提供这个功能。</p>
<h3 id="11-12-3-UDP输入队列"><a href="#11-12-3-UDP输入队列" class="headerlink" title="11.12.3 UDP输入队列"></a>11.12.3 UDP输入队列</h3><p>我们在1.8节中说过，大多数UDP服务器是交互服务器。这意味着，单个服务器进程对单个UDP端口上（服务器上的名知端口）的所有客户请求进行处理。</p>
<p>通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。</p>
<p>然而，排队溢出造成内核中的UDP模块丢弃数据报的可能性是存在的。可以进行以下试验。我们在作为UDP服务器的bsdi主机上运行sock程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bsdi % sock -s -u -v -E -R256 -P30 6666</span><br><span class="line">from 140.252.13.33, to 140.252.13.63: 1111111111  从发送到广播地址</span><br><span class="line">from 140.252.13.34, to 140.252.13.35: 4444444444444  从svr4发送到单播地址</span><br></pre></td></tr></table></figure>
<p>我们指明以下标志：-s表示作为服务器运行，-u表示UDP，-v表示打印客户的IP地址，-E表示打印目的IP地址（该系统支持这个功能）。另外，我们将这个端口的UDP接收缓存设置为256字节（-R），其每次应用程序读取的大小也是这个数（-r）。标志-P30表示创建UDP端口后，先暂停30秒后再读取第一个数据报。这样，我们就有时间在另两台主机上启动客户程序，发送一些数据报，以查看接收队列是如何工作的。</p>
<ul>
<li>首先，应用程序并不知道其输入队列何时溢出。只是由UDP对超出数据报进行丢弃处理。</li>
<li>同时，从tcpdump输出结果，我们看到，没有发回任何信息告诉客户其数据报被丢弃。这里不存在像ICMP源站抑制这样发回发送端的消息。</li>
<li>最后，看来UDP输出队列是FIFO（先进先出）的，而我们在11.9节中所看到的ARP输入却是LIFO（后进先出）的。</li>
</ul>
<h3 id="11-12-4-限制本地IP地址"><a href="#11-12-4-限制本地IP地址" class="headerlink" title="11.12.4 限制本地IP地址"></a>11.12.4 限制本地IP地址</h3><p>大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符(wildcard)的特点。这就表明进入的UDP数据报如果其目的地为服务器端口，那么在任何本地接口均可接收到它。例如，我们以端口号777启动一个UDP服务器：<br><code>sun % sock -u -s 7777</code><br>然后，用netstat命令观察端点的状态：<br>-a选项表示报告所有网络端点的状态。-n选项表示以点数格式打印IP地址而不用DNS把地址转换成名字，打印数字端口号而不是服务名称。-finet选项表示只报告TCP和UDP端点。</p>
<p>当服务器创建端点时，它可以把其中一个主机本地IP地址包括广播地址指定为端点的本地IP地址。只有当目的IP地址与指定的地址相匹配时，进入的UDP数据报才能被送到这个端点。用我们的sock程序，如果在端口号之前指定一个IP地址，那么该IP地址就成为该端点的本地IP地址。例如：<br><code>sun % sock -u -s 140.252.1.29 7777</code><br>就限制服务器在SLIP接口(140.252.1.29)处接收数据报</p>
<p>有可能在相同的端口上启动不同的服务器，每个服务器具有不同的本地IP地址。但是<br>除了第一个以外，其他的服务器都必须以-A选项启动，告诉系统可以重用同一个端口号。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/11/images2/52im_net_27.png" alt="5个服务器的netstat输出结果"><br>使用sockets API时，必须指定SO_REUSEADDR socket选项。在sock程序中是通过-A选项来完成的。</p>
<h3 id="11-12-5-限制远端IP地址"><a href="#11-12-5-限制远端IP地址" class="headerlink" title="11.12.5 限制远端IP地址"></a>11.12.5 限制远端IP地址</h3><p>在前面所有的netstat输出结果中，远端IP地址和远端端口号都显示为*.*，其意思是该端点将接受来自任何IP地址和任何端口号的UDP数据报。大多数系统允许UDP端点对远端地址进行限制。</p>
<p>这说明端点将只能接收特定IP地址和端口号的UDP数据报。sock程序用-f选项来指定远端IP地址和端口号：<code>sun % sock -u -s -f 140.252.13.35.4444 5555</code><br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/11/images2/52im_net_28.png" alt="图11-22 为UDP服务器指定本地和远端IP地址及端口号"></p>
<h3 id="11-12-6-每个端口有多个接收者"><a href="#11-12-6-每个端口有多个接收者" class="headerlink" title="11.12.6 每个端口有多个接收者"></a>11.12.6 每个端口有多个接收者</h3><p>尽管在RFC中没有指明，但大多数的系统在某一时刻只允许一个程序端点与某个本地I P地址及UDP端口号相关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun % sock -u -s 9999</span><br><span class="line">sun % sock -u -s -A 9999</span><br></pre></td></tr></table></figure>
<p>如果启动另一个具有相同本地地址和端口号的服务器，那么它将不运行，尽管我们指定了-A选项</p>
<p>在一个支持多播的系统上（第12章），这种情况将发生变化。多个端点可以使用同一个IP地址和UDP端口号，尽管应用程序通常必须告诉API是可行的（如，用-A标志来指明SO_REUSEADDRsocket选项）。</p>
<p>当UDP数据报到达的目的IP地址为广播地址或多播地址，而且在目的IP地址和端口号处有多个端点时，就向每个端点传送一份数据报的复制（端点的本地IP地址可以含有星号，它可匹配任何目的IP地址）。但是，如果UDP数据报到达的是一个单播地址，那么只向其中一个端点传送一份数据报的复制。选择哪个端点传送数据取决于各个不同的系统实现。</p>
<h2 id="11-13-小结"><a href="#11-13-小结" class="headerlink" title="11.13 小结"></a>11.13 小结</h2><p>UDP向用户进程提供的服务位于IP层之上，包括端口号和可选的检验和。我们用UDP来检查检验和，并观察分片是如何进行的。</p>
<p>接着，我们讨论了ICMP不可达差错，它是新的路径MTU发现功能中的一部分（2.9节）。用Tr aceroute和UDP来观察路径MTU发现过程。还查看了UDP和ARP之间的接口，大多数的ARP实现在等待ARP应答时只保留最近传送给目的端的数据报。</p>
<p>当系统接收IP数据报的速率超过这些数据报被处理的速率时，系统可能发送ICMP源站抑制差错报文。</p>
<h2 id="ch11-习题"><a href="#ch11-习题" class="headerlink" title="ch11 习题"></a>ch11 习题</h2><ol>
<li>在11.5节中，向UDP数据报中写入1473字节用户数据时导致以太网数据报片的发生。在采用以太网IEEE 802封装格式时，导致分片的最小用户数据长度为多少？</li>
</ol>
<ul>
<li>答案是：因为使用IEEE 802封装时，存在8个额外的首部字节，所以1465个字节的用户数据是引起分片的最小长度。</li>
</ul>
<ol>
<li>阅读RFC 791 [Postel 1981a]，理解为什么除最后一片外，其他片中的数据长度均要求为8字节的整数倍？</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>假定有一个以太网和一份8192字节的UDP数据报，那么需要分成多少个数据报片，每个数据报片的偏移和长度为多少？</li>
</ol>
<ul>
<li>答案是：对于IP来说有8200字节的数据需要发送，8192字节的用户数据和8个字节的UDP首部。采用tcpdump记号，第1个分片是1480@0+（1480字节的数据，偏移为0，将“更多片”比特置1）。第2个是1480@1480+，第3个是1480@2960+，第4个是1480@4440+，第5个是1480@5920+，第6个是800@7400。1480×5+800=8200，正好是要发送的字节。</li>
</ul>
<ol>
<li>继续前一习题，假定这些数据报片要经过一条MTU为552的SLIP链路。必须记住每一个数据报片中的数据（除IP首部外）为8字节的整数倍。那么又将分成多少个数据报片？每个数据报片的偏移和长度为多少？</li>
</ol>
<ul>
<li>答案是：每个1480字节的数据报片被分成三小片：两个528字节和一个424字节。小于532（55220）的8的最大倍数是528。800字节的数据报片被分成两小片：一个528字节和一个272字节。这样，原来8192字节的数据报变成了SLIP链路上的17个帧。</li>
</ul>
<ol>
<li>一个用UDP发送数据报的应用程序，它把数据报分成4个数据报片。假定第1片和第2片到达目的端，而第3片和第4片丢失了。应用程序在10秒钟后超时重发该UDP数据报，并且被分成相同的4片（相同的偏移和长度）。假定这一次接收主机重新组装的时间为60秒，那么当重发的第3片和第4片到达目的端时，原先收到的第1片和第2片还没有被丢弃。接收端能否把这4片数据重新组装成一份IP数据报？</li>
</ol>
<ul>
<li>答案是：不。问题是当应用程序超时重传时，重传产生的IP数据报有一个新的标识字段。而重新装配只针对那些具有相同标识字段的分段。</li>
</ul>
<ol>
<li>你是如何知道图11-15中的片实际上与图11-14中第5行和第6行相对应？</li>
</ol>
<ul>
<li>答案是：IP首部中的标识字段（47942）是一样的。</li>
</ul>
<ol>
<li>主机gemini开机33天后，netstat程序显示48 000 000份IP数据报中由于首部检验和差错被丢弃129份，在30 000 000个TCP段中由于TCP检验和差错而被丢弃20个。但是，在大约18 000 000份UDP数据报中，因为UDP检验和差错而被丢弃的数据报一份也没有。请说明两个方面的原因（提示：参见图11-4）。</li>
</ol>
<ul>
<li>答案是：第一，从图11-4我们看到gemini没有使能输出UDP的检验和。如果输出UDP的检验和没有被使能，这个主机上的操作系统（SunOS 4.1.1）就不会验证一个进入UDP的检验和。第二，大多数的UDP通信量都是本地的，而不是WA N的，因此没有服从所有的WA N特征。</li>
</ul>
<ol>
<li>在讨论分片时没有提及任何关于IP首部中的选项——它们是否也要被复制到每个数据报片中，或者只留在第一个数据报片中？我们已经讨论过下面这些IP选项：记录路由（7.3节）、时间戳（7.4节）、严格和宽松的源站选路（8.5节）。你希望分片如何处理这些选项？对照RFC 791检查你的答案。</li>
</ol>
<ul>
<li>答案是：<strong>不严格的和严格的源站选路选项被复制到每一个数据报片中。</strong>时间戳选项和记录路由选项没有被复制到每一个数据报片中—它们只出现在第1个数据报片中。</li>
</ul>
<ol>
<li>在图1-8中，我们说UDP数据报是根据目的UDP端口号进行分配的。这正确吗？</li>
</ol>
<ul>
<li>答案是：不。在11.12节中，我们看到很多实现可以根据目的IP地址、源IP地址和源端口号来过滤送往一个给定UDP端口号的输入数据报。</li>
</ul>
<h1 id="ch12-广播和多播"><a href="#ch12-广播和多播" class="headerlink" title="ch12 广播和多播"></a>ch12 广播和多播</h1><h2 id="12-1-引言"><a href="#12-1-引言" class="headerlink" title="12.1 引言"></a>12.1 引言</h2><p>广播和多播仅应用于UDP</p>
<p>为了弄清广播和多播，需要了解主机对由信道传送过来帧的过滤过程。图12-1说明了这一过程。</p>
<p>首先，网卡查看由信道传送过来的帧，确定是否接收该帧，若接收后就将它传往设备驱动程序。通常网卡仅接收那些目的地址为网卡物理地址或广播地址的帧。另外，多数接口均被设置为混合模式，这种模式能接收每个帧的一个复制。作为一个例子，tcpdump使用这种模式。</p>
<p>目前，大多数的网卡经过配置都能接收目的地址为多播地址或某些子网多播地址的帧。对于以太网，当地址中最高字节的最低位设置为1时表示该地址是一个多播地址，用十六进制可表示为01:00:00:00:00:00（以太网广播地址ff:ff:ff:ff:ff:ff可看作是以太网多播地址的特例）。</p>
<p>如果网卡收到一个帧，这个帧将被传送给设备驱动程序（如果帧检验和错，网卡将丢弃该帧）。设备驱动程序将进行另外的帧过滤。首先，帧类型中必须指定要使用的协议（IP、ARP等等）。其次，进行多播过滤来检测该主机是否属于多播地址说明的多播组。</p>
<p>设备驱动程序随后将数据帧传送给下一层，比如，当帧类型指定为IP数据报时，就传往IP层。IP根据IP地址中的源地址和目的地址进行更多的过滤检测。如果正常，就将数据报传送给下一层（如TCP或UDP）。</p>
<p>每次UDP收到由IP传送来的数据报，就根据目的端口号，有时还有源端口号进行数据报过滤。如果当前没有进程使用该目的端口号，就丢弃该数据报并产生一个ICMP不可达报文（TCP根据它的端口号作相似的过滤）。如果UDP数据报存在检验和错，将被丢弃。</p>
<p>使用广播的问题在于它增加了对广播数据不感兴趣主机的处理负荷。拿一个使用UDP广播应用作为例子。如果网内有50个主机，但仅有20个参与该应用，每次这20个主机中的一个发送UDP广播数据时，其余30个主机不得不处理这些广播数据报。一直到UDP层，收到的UDP广播数据报才会被丢弃。</p>
<p>多播的出现减少了对应用不感兴趣主机的处理负荷。使用多播，主机可加入一个或多个多播组。这样，网卡将获悉该主机属于哪个多播组，然后仅接收主机所在多播组的那些多播帧。</p>
<h2 id="12-2-广播"><a href="#12-2-广播" class="headerlink" title="12.2 广播"></a>12.2 广播</h2><h3 id="12-2-1-受限的广播"><a href="#12-2-1-受限的广播" class="headerlink" title="12.2.1 受限的广播"></a>12.2.1 受限的广播</h3><p>受限的广播地址是255.255.255.255。</p>
<p>路由器不转发目的地址为受限的广播地址的数据报</p>
<p>如果一个主机是多接口的，广播是否应该将数据报发送到每个相连的接口上？<br>大多数BSD系统将255.255.255.255看作是配置后第一个接口的广播地址，并且不提供向所属具备广播能力的接口传送数据报的功能。</p>
<h3 id="12-2-2-指向网络的广播"><a href="#12-2-2-指向网络的广播" class="headerlink" title="12.2.2 指向网络的广播"></a>12.2.2 指向网络的广播</h3><p>指向网络的广播地址是主机号为全1的地址。A类网络广播地址为netid.255.255.255</p>
<p>一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p>
<h3 id="12-2-3-指向子网的广播"><a href="#12-2-3-指向子网的广播" class="headerlink" title="12.2.3 指向子网的广播"></a>12.2.3 指向子网的广播</h3><p>指向子网的广播地址为主机号为全1且有特定子网号的地址。</p>
<h3 id="12-2-4-指向所有子网的广播"><a href="#12-2-4-指向所有子网的广播" class="headerlink" title="12.2.4 指向所有子网的广播"></a>12.2.4 指向所有子网的广播</h3><p>指向所有子网的广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。</p>
<h2 id="12-3-广播的例子"><a href="#12-3-广播的例子" class="headerlink" title="12.3 广播的例子"></a>12.3 广播的例子</h2><p><code>ping 255.255.255.255</code>无法进行，原因在于本网广播地址（255.255.255.255）也被当作存在差错而返回-1。</p>
<p>指向子网的广播是我们应该使用的。IP通过目的地址（140.252.13.63）来确定，这是指向子网的广播地址</p>
<p>广播与ARP之间的相互作用。执行ping命令前ARP缓存是空的，而执行后是满的</p>
<p>如果使用tcpdump来观察ping的执行过程，可以看到广播数据帧的接收者在发送它的响应之前，首先产生一个对sun主机的ARP请求，因为它的应答是单播的。在4.5节我们介绍了一个ARP请求的接收者（该例中是sun）通常在发送ARP应答外，还将请求主机的IP地址和物理地址加入到ARP缓存中去。</p>
<p>如果使用不支持广播的应用如TFTP，程序立即产生了一个差错，但不向网络发送任何信息。产生这一切的原因在于，插口提供的应用程序接口API只有在进程明确打算进行广播时才允许它向广播地址发送UDP数据报。</p>
<p>下一个问题是是否转发广播数据。有些系统内核和路由器有一选项来控制允许或禁止这一特性（见附录E）。</p>
<p>如果让路由器bsdi能够转发广播数据，然后在主机slip上运行ping程序，就能够观察到由路由器bsdi转发的子网广播数据报。</p>
<p>BSD系统中的ping程序检查重复的数据报序列号。如果出现重复序列号的数据报就显示DUP!，这意味着一个数据报已经在某处重复了，然而它正是我们所期望看到的，因为我们正向一个广播地址发送数据。</p>
<p>广播是一种应该谨慎使用的功能。在许多情况下，IP多播被证明是一个更好的解决办法。</p>
<h2 id="12-4-多播"><a href="#12-4-多播" class="headerlink" title="12.4 多播"></a>12.4 多播</h2><p>IP多播提供两类服务：</p>
<ul>
<li>向多个目的地址传送数据。</li>
<li>客户对服务器的请求。例如，无盘工作站需要确定启动引导服务器。目前，这项服务是通过广播来提供的（正如第16章的BOOTP），但是使用多播可降低不提供这项服务主机的负担。</li>
</ul>
<h3 id="12-4-1-多播组地址"><a href="#12-4-1-多播组地址" class="headerlink" title="12.4.1 多播组地址"></a>12.4.1 多播组地址</h3><p>能够接收发往一个特定多播组地址数据的主机集合称为主机组(host group)。一个主机组可跨越多个网络。主机组中成员可随时加入或离开主机组。主机组中对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送信息。</p>
<p>一些多播组地址被IANA确定为知名地址。它们也被当作永久主机组，这和TCP及UDP中的熟知端口相似。同样，这些知名多播地址在RFC最新分配数字中列出。注意这些多播地址所代表的组是永久组，而它们的组成员却不是永久的。</p>
<h3 id="12-4-2-多播组地址到以太网地址的转换"><a href="#12-4-2-多播组地址到以太网地址的转换" class="headerlink" title="12.4.2 多播组地址到以太网地址的转换"></a>12.4.2 多播组地址到以太网地址的转换</h3><p>IANA拥有一个以太网地址块，即高位24 bit为00:00:5e（十六进制表示），这意味着该地址块所拥有的地址范围从00:00:5e:00:00:00到00:00:5e:ff:ff:ff。IANA将其中的一半分配为多播地址。为了指明一个多播地址，任何一个以太网地址的首字节必须是01，这意味着与IP多播相对应的以太网地址范围从01:00:5e:00:00:00到01:00:5e:7f:ff:ff。</p>
<p>这种地址分配将使以太网多播地址中的23bit与IP多播组号对应起来，通过将多播组号中的低位23bit映射到以太网地址中的低位23bit实现，这个过程如图12-3所示。</p>
<p>由于多播组号中的最高5bit在映射过程中被忽略，因此每个以太网多播地址对应的多播组是不唯一的。32个不同的多播组号被映射为一个以太网地址。例如，多播地址224.128.64.32（十六进制e0.80.40.20）和224.0.64.32（十六进制e0.00.40.20）都映射为同一以太网地址01:00:5e:00:40:20。</p>
<p>既然地址映射是不唯一的，那么设备驱动程序或IP层（见图12-1）就必须对数据报进行过滤。因为网卡可能接收到主机不想接收的多播数据帧。另外，如果网卡不提供足够的多播数据帧过滤功能，设备驱动程序就必须接收所有多播数据帧，然后对它们进行过滤。</p>
<p>局域网网卡趋向两种处理类型：一种是网卡根据对多播地址的散列值实行多播过滤，这意味仍会接收到不想接收的多播数据；另一种是网卡只接收一些固定数目的多播地址，这意味着当主机想接收超过网卡预先支持多播地址以外的多播地址时，必须将网卡设置为“多播混杂(multicast promiscuous)”模式。因此，这两种类型的网卡仍需要设备驱动程序检查收到的帧是否真是主机所需要的。</p>
<p>即使网卡实现了完美的多播过滤（基于48 bit的硬件地址），由于从D类IP地址到48 bit的硬件地址的映射不是一对一的，过滤过程仍是必要的。尽管存在地址映射不完美和需要硬件过滤的不足，多播仍然比广播好。</p>
<p>单个物理网络的多播是简单的。多播进程将目的IP地址指明为多播地址，设备驱动程序将它转换为相应的以太网地址，然后把数据发送出去。这些接收进程必须通知它们的IP层，它们想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧。这个过程就是“加入一个多播组”（使用“接收进程”复数形式的原因在于对一确定的多播信息，在同一主机或多个主机上存在多个接收者，这也是为什么要首先使用多播的原因）。当一个主机收到多播数据报时，它必须向属于那个多播组的每个进程均传送一个复制。这和单个进程收到单播UDP数据报的UDP不同。使用多播，一个主机上可能存在多个属于同一多播组的进程。</p>
<p>当把多播扩展到单个物理网络以外需要通过路由器转发多播数据时，复杂性就增加了。需要有一个协议让多播路由器了解确定网络中属于确定多播组的任何一个主机。这个协议就是Internet组管理协议（IGMP），也是下一章介绍的内容。</p>
<h3 id="12-4-3-FDDI和令牌环网络中的多播"><a href="#12-4-3-FDDI和令牌环网络中的多播" class="headerlink" title="12.4.3 FDDI和令牌环网络中的多播"></a>12.4.3 FDDI和令牌环网络中的多播</h3><p>FDDI网络使用相同的D类IP地址到48 bit FDDI地址的映射过程[Katz 1990]。令牌环网络通常使用不同的地址映射方法，这是因为大多数令牌控制中的限制。</p>
<h2 id="12-5-小结"><a href="#12-5-小结" class="headerlink" title="12.5 小结"></a>12.5 小结</h2><p>目前有四种类型的广播地址：受限的广播、指向网络的广播、指向子网的广播和指向所有子网的广播。最常用的是指向子网的广播。受限的广播通常只在系统初始启动时才会用到。</p>
<h2 id="ch12-习题"><a href="#ch12-习题" class="headerlink" title="ch12 习题"></a>ch12 习题</h2><ol>
<li>广播是否增加了网络通信量？</li>
</ol>
<ul>
<li>答案是：广播本身不会增加网络通信量，但它增加了额外的主机处理时间。如果接收主机不正确地响应了诸如ICMP端口不可达之类的差错，那么广播也可能导致额外的网络通信量。路由器一般不转发广播分组，而网桥一般转发，所以在一个桥接网络上的广播分组可能比在一个路由网络上走得更远。</li>
</ul>
<ol>
<li>考虑一个拥有50台主机的以太网：20台运行TCP/IP，其他30台运行其他的协议族。主机如何处理来自运行另一个协议族主机的广播？</li>
</ol>
<ul>
<li>答案是：每个主机都收到了所有广播分组的一个副本。接口层收到了帧，把它传递给设备驱动程序。如果类型字段指的是其他协议，设备驱动程序就会丢弃该帧。</li>
</ul>
<ol>
<li>登录到一个过去从来没有用过的Unix系统，并且打算找出所有支持广播的接口的指向子网的广播地址。如何做到这点？</li>
</ol>
<ul>
<li>答案是：首先执行netstat -r来看一下路由表，结果显示了所有接口的名字。然后对每个接口执行ifconfig（3.8节）：标志指出了一个接口是否支持广播，如果支持，相应的广播地址也会被输出。</li>
</ul>
<ol>
<li>如果我们用ping程序向一个广播地址发送一个长的分组，如<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/12/images2/52im_net_7.png"><br>它正常工作，但将分组的长度再增加一个字节后出现如下差错：<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/12/images2/52im_net_8.png"><br>究竟出了什么问题?</li>
</ol>
<ul>
<li>答案是：伯克利演变的实现不允许对一个广播数据报进行分片。当我们说明了1472字节的长度，产生的IP数据报将是1500字节，正好是以太网的MTU。不允许分片一个广播数据报是一个策略上的决定—没有技术上的原因（并不是想要减少广播分组的数目）。</li>
</ul>
<ol>
<li>重做习题10.6，假定8个RIP报文是通过多播而不是广播（使用RIP版本2）。有什么变化？</li>
</ol>
<ul>
<li>答案是：依赖于100个主机上不同的以太网接口卡的多播支持，多播数据报可能被接口卡忽略，或者被设备驱动程序丢弃。</li>
</ul>
<h1 id="ch13-IGMP：Internet组管理协议"><a href="#ch13-IGMP：Internet组管理协议" class="headerlink" title="ch13 IGMP：Internet组管理协议"></a>ch13 IGMP：Internet组管理协议</h1><h2 id="13-1-引言"><a href="#13-1-引言" class="headerlink" title="13.1 引言"></a>13.1 引言</h2><p>本章将介绍用于支持主机和路由器进行多播的Internet组管理协议（IGMP）。它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。</p>
<p>不像我们已经见到的其他协议，IGMP有固定的报文长度，没有可选数据。</p>
<h2 id="13-2-IGMP报文"><a href="#13-2-IGMP报文" class="headerlink" title="13.2 IGMP报文"></a>13.2 IGMP报文</h2><p>图13-2显示了长度为8字节的IGMP报文格式。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/13/images2/52im_net_2.png" alt="图13-2 IGMP报文的字段格式"><br>这是版本为1的IGMP。IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文。检验和的计算和ICMP协议相同。</p>
<p>组地址为D类IP地址。在查询报文中组地址设置为0，在报告报文中组地址为要参加的组地址。</p>
<h2 id="13-3-IGMP协议"><a href="#13-3-IGMP协议" class="headerlink" title="13.3 IGMP协议"></a>13.3 IGMP协议</h2><h3 id="13-3-1-加入一个多播组"><a href="#13-3-1-加入一个多播组" class="headerlink" title="13.3.1 加入一个多播组"></a>13.3.1 加入一个多播组</h3><p>进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加入的多播组。这些是一个支持多播主机中任何API所必需的部分。</p>
<h3 id="13-3-2-IGMP报告和查询"><a href="#13-3-2-IGMP报告和查询" class="headerlink" title="13.3.2 IGMP报告和查询"></a>13.3.2 IGMP报告和查询</h3><p>多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下：</p>
<ul>
<li>当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。</li>
<li>进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。</li>
<li>多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0。</li>
<li>主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。<br>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。<h3 id="13-3-3-实现细节"><a href="#13-3-3-实现细节" class="headerlink" title="13.3.3 实现细节"></a>13.3.3 实现细节</h3>如果一个主机在等待发送报告的过程中，却收到了发自其他主机的相同报告，则该主机的响应就可以不必发送了。因为多播路由器并不关心有多少主机属于该组，而只关心该组是否还至少拥有一个主机。的确，一个多播路由器甚至不关心哪个主机属于一个多播组。</li>
</ul>
<p>在没有任何多播路由器的单个物理网络中，仅有的IGMP通信量就是在主机加入一个新的多播组时，支持IP多播的主机所发出的报告。</p>
<h3 id="13-3-4-生存时间字段"><a href="#13-3-4-生存时间字段" class="headerlink" title="13.3.4 生存时间字段"></a>13.3.4 生存时间字段</h3><p>在默认情况下，待传多播数据报的TTL被设置为1，这将使多播数据报仅局限在同一子网内传送。更大的TTL值能被多播路由器转发。</p>
<p>回顾6.2节，对发往一个多播地址的数据报从不会产生ICMP差错。</p>
<p>通过增加TTL值的方法，一个应用程序可实现对一个特定服务器的扩展环搜索(expanding ring search)。</p>
<p>从224.0.0.0到224.0.0.255的特殊地址空间是打算用于多播范围不超过1跳的应用。不管TTL值是多少，多播路由器均不转发目的地址为这些地址中的任何一个地址的数据报。</p>
<h3 id="13-3-5-所有主机组"><a href="#13-3-5-所有主机组" class="headerlink" title="13.3.5 所有主机组"></a>13.3.5 所有主机组</h3><p>在图13-3中，我们看到了路由器的IGMP查询被送到目的IP地址224.0.0.1。该地址被称为所有主机组地址。它涉及在一个物理网络中的所有具备多播能力的主机和路由器。当接口初始化后，所有具备多播能力接口上的主机均自动加入这个多播组。这个组的成员无需发送IGMP报告。</p>
<h2 id="13-4-一个例子"><a href="#13-4-一个例子" class="headerlink" title="13.4 一个例子"></a>13.4 一个例子</h2><p>采用一个经过修改的netstat命令来报告每个接口上的多播组成员情况</p>
<p>其中，-n参数将以数字形式显示IP地址（而不是按名字来显示它们），-i参数将显示接口的统计结果，-a参数将显示所有配置的接口。</p>
<p><code>netstat -rn</code>显示IP路由表，用于多播的路由表同正常的路由表一样。黑体表项显示了所有传往224.0.0.0的数据报均被送往以太网</p>
<p>现在使用一个测试程序来让我们能在一个接口上加入一个多播组</p>
<p>加入多播组只发生在一个接口上。</p>
<p>相对应的tcpdump输出中，加入多播组和IGMP报告都显示<code>igmp report 224.1.2.3 [ttl 1]</code></p>
<p>个多播路由器必须接收在它所有接口上的所有多播数据报。路由器无法确定主机可能加入哪个多播组。</p>
<h3 id="多播路由器的例子"><a href="#多播路由器的例子" class="headerlink" title="多播路由器的例子"></a>多播路由器的例子</h3><p>相对应的tcpdump输出中，<code>igmp query</code>表示IGMP查询的目的IP地址为224.0.0.1（所有主机组）</p>
<h2 id="13-5-小结"><a href="#13-5-小结" class="headerlink" title="13.5 小结"></a>13.5 小结</h2><p>简单的主机成员报告协议(IGMP)是多播的基本模块。</p>
<p>在一个局域网中或跨越邻近局域网的多播需要使用本章介绍的技术。</p>
<p>然而，多播还未解决的一个问题是在广域网内的多播。</p>
<h2 id="ch13-习题"><a href="#ch13-习题" class="headerlink" title="ch13 习题"></a>ch13 习题</h2><ol>
<li>我们知道主机通过设置随机时延来调度IGMP的发送。一个局域网中的主机采取什么措施才能避免两台主机产生相同的随机时延？</li>
</ol>
<ul>
<li>答案是：生成随机数时要使用对于主机唯一的值。IP地址和链路层地址是每个主机都应该不一样的两个值。日期时间是一个不好的选择，尤其是在所有的主机都运行了一个类似于NTP的协议来同步它们的时钟的情况下。</li>
</ul>
<ol>
<li>在[Casner and Deering 1992]中，他们提到UDP缺少两个通过MBONE传送音频采样数据的条件：分组失序检测和分组重复检测。你怎样在UDP上增加这些功能？</li>
</ol>
<ul>
<li>答案是：他们增加了一个包括一个序号和一个时间戳的应用协议首部。</li>
</ul>
<h1 id="ch14-DNS：域名系统"><a href="#ch14-DNS：域名系统" class="headerlink" title="ch14 DNS：域名系统"></a>ch14 DNS：域名系统</h1><h2 id="14-1-引言"><a href="#14-1-引言" class="headerlink" title="14.1 引言"></a>14.1 引言</h2><p>DNS是用于TCP/IP的分布式数据库。<br>每个站点（如大学、公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供Internet上的其他系统查询。</p>
<p>在一个应用程序请求TCP打开一个连接或使用UDP发送一个数据报之前。心须将一个主机名转换为一个IP地址。操作系统内核中的TCP/IP协议族对于DNS一点都不知道。</p>
<h2 id="14-2-DNS基础"><a href="#14-2-DNS基础" class="headerlink" title="14.2 DNS基础"></a>14.2 DNS基础</h2><p>顶级域名被分为三个部分</p>
<ul>
<li>arpa用作地址到名字的转换（<a href="#14-5-%E6%8C%87%E9%92%88%E6%9F%A5%E8%AF%A2">CF：14.5节</a>）</li>
<li>7个3字符长的普通域com、org等等，也称为组织域</li>
<li>所有2字符长的域均是国家域或地理域</li>
</ul>
<p>通常认为3字符长的普通域仅用于美国的组织机构，但情况并不总是这样。普通域中只有gov和mil域局限于美国。</p>
<p>NIC负责分配顶级域和委派其他指定地域的授权机构。<br>一个独立管理的DNS子树被称为一个区域(zone)</p>
<p>一旦一个区域的授权机构被委派后，由它负责向该区域提供多个名字服务器。<br>一个名字服务器负责一个或多个区域。一个区域的管理者必须为该区域提供一个主名字服务器和至少一个辅助名字服务器。</p>
<p>当一个新主机加入一个区域时，区域管理者将适当的信息（最少包括名字和IP地址）加入到运行在主名字服务器上的一个磁盘文件中，然后通知主名字服务器重新调入它的配置文件。辅名字服务器定时（通常是每隔3小时）向主名字服务器询问是否有新数据。如果有新数据，则通过区域传送方式获得新数据。</p>
<h2 id="14-3-DNS的报文格式"><a href="#14-3-DNS的报文格式" class="headerlink" title="14.3 DNS的报文格式"></a>14.3 DNS的报文格式</h2><p>DNS定义了一个用于查询和响应的报文格式。图14-3显示这个报文的总体格式。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_3.png" alt="图14-3 DNS查询和响应的一般格式"><br>这个报文由12字节长的首部和4个长度可变的字段组成。</p>
<ul>
<li>查询问题</li>
<li>回答</li>
<li>授权</li>
<li>额外信息</li>
</ul>
<p>标识字段由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配。</p>
<p>16 bit的标志字段被划分为若干子字段，如图14-4所示。</p>
<ul>
<li>QR是1bit字段：0表示查询报文，1表示响应报文。</li>
<li>opcode是一个4bit字段：通常值为0（标准查询），其他值为1（反向查询）和2（服务器状态请求）。</li>
<li>AA是1bit标志，表示“授权回答(authoritative answer)”。该名字服务器是授权于该域的。</li>
<li>TC是1bit字段，表示“可截断的(truncated)”。使用UDP时，它表示当应答的总长度超过512字节时，只返回前512个字节。</li>
<li>RD是1bit字段表示“期望递归（recursion desired）”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个递归查询。如果该位为0，且被请求的名字服务器没有一个授权回答，它就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询。在后面的例子中，我们将看到这两种类型查询的例子。</li>
<li>RA是1bit字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为1。在后面的例子中可看到大多数名字服务器都提供递归查询，除了某些根服务器。</li>
<li>随后的3bit字段必须为0。</li>
<li>rcode是一个4bit的返回码字段。通常的值为0（没有差错）和3（名字差错）。名字差错只有从一个授权名字服务器上返回，它表示在查询中制定的域名不存在。<br>随后的4个16 bit字段说明最后4个变长字段中包含的条目数。对于查询报文，问题(question)数通常是1，而其他3项则均为0。类似地，对于应答报文，回答数至少是1，剩下的两项可以是0或非0。</li>
</ul>
<h3 id="14-3-1-DNS查询报文中的问题部分"><a href="#14-3-1-DNS查询报文中的问题部分" class="headerlink" title="14.3.1 DNS查询报文中的问题部分"></a>14.3.1 DNS查询报文中的问题部分</h3><p>问题部分中的每个问题的格式如图14-5所示，通常只有一个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0                             31</span><br><span class="line">+-----------------------------+</span><br><span class="line">|            查询名            |</span><br><span class="line">+---------------*-------------+</span><br><span class="line">|    查询类型    |    查询类    |</span><br><span class="line">+---------------+-------------+</span><br><span class="line">             图14-5</span><br></pre></td></tr></table></figure>
<ul>
<li>查询名是要查找的名字，它是一个或多个标识符的序列。每个标识符以首字节的计数值来说明随后标识符的字节长度，每个名字以最后字节为0结束。</li>
<li>每个问题有一个查询类型，而每个响应也有一个类型。最常用的查询类型是A类型，表示期望获得查询名的IP地址</li>
<li>查询类通常是1，指互联网地址。</li>
</ul>
<h3 id="14-3-2-DNS响应报文中的资源记录部分"><a href="#14-3-2-DNS响应报文中的资源记录部分" class="headerlink" title="14.3.2 DNS响应报文中的资源记录部分"></a>14.3.2 DNS响应报文中的资源记录部分</h3><p>回答字段、授权字段和附加信息字段均采用一种称为资源记录RR的相同格式。图14-8显示了资源记录的格式。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_8.png" alt="图14-8 DNS资源记录格式"><br>域名是记录中资源数据对应的名字。它的格式和前面介绍的查询名字段格式（图14-6）相同。</p>
<p>类型说明RR的类型码。它的值和前面介绍的查询类型值是一样的。类通常为1，指Internet数据。</p>
<p>生存时间字段是客户程序保留该资源记录的秒数。资源记录通常的生存时间值为2天。</p>
<p>资源数据长度说明资源数据的数量。该数据的格式依赖于类型字段的值。对于类型1（A记录）资源数据是4字节的IP地址。</p>
<h2 id="14-4-一个简单的例子"><a href="#14-4-一个简单的例子" class="headerlink" title="14.4 一个简单的例子"></a>14.4 一个简单的例子</h2><p>在sun上执行<code>telnet gemini daytime</code></p>
<p>sun主机上的文件/etc/resolv.conf将告诉名字解析器做什么</p>
<p>第1行给出名字服务器—主机noao.edu的IP地址。最多可说明3个名字服务器行来提供足够的后备以防名字服务器故障或不可达。域名行说明默认域名。如果要查找的域名不是一个完全合格的域名（没有以句点结束），那末默认的域名.tuc.noao.edu将加到待查名后。</p>
<p>图14-10显示了名字解析器与名字服务器之间的分组交换。相应的tcpdump输出中</p>
<ul>
<li>第1行中冒号后的字段（1+）表示标识字段为1，加号“+”表示RD标志（期望递归）为1。默认情况下，名字解析器要求递归查询方式。</li>
<li>下一个字段为A?，表示查询类型为A（我们需要一个IP地址），该问号指明它是一个查询（不是一个响应）。待查名字显示在后面：gemini.tuc.noao.edu.。名字解析器在待查名字后加上句点号指明它是一个绝对字段名。</li>
<li>在UDP数据报中的用户数据长度显示为37字节：12字节为固定长度的报文首部（图14-3）；21字节为查询名字（图14-6），以及用于查询类型和查询类的4个字节。在DNS报文中无需填充数据。</li>
<li>tcpdump程序的第2行显示的是从名字服务器发回的响应。1*是标识字段，星号表示设置AA标志（授权回答）（该服务器是noao.edu域的主域名服务器，其回答在该域内是可相信的。）</li>
<li>输出结果2/0/0表示在响应报文中最后3个变长字段的资源记录数：回答RR数为2，授权RR和附加信息RR数均为0。tcpdump仅显示第一个回答，回答类型为A（IP地址），值为140.252.1.11。 </li>
</ul>
<p>为什么我们的查询会得到两个回答？这是因为gemini是多接口主机，因此得到两个IP地址。事实上，另一个有用的DNS工具是一个称为host的公开程序，它能将查询传递给名字服务器，并显示返回的结果。如果使用这个程序，就能看到这个多地址主机的两个IP地址：</p>
<p>如果在输入Telnet命令后间隔很长时间才显示IP地址，这个时延是由名字解析器和名字服务器在由域名到IP地址的解析所引起的。而显示Trying到显示Connectedto的时延则是由客户与服务器建立TCP连接所引起的，与DNS无关。</p>
<h2 id="14-5-指针查询"><a href="#14-5-指针查询" class="headerlink" title="14.5 指针查询"></a>14.5 指针查询</h2><p>指针查询，即给定一个IP地址，返回与改地址对应的域名。</p>
<p>当一个组织加入Internet，并获得DNS域名空间的授权，如noao.edu，则它们也获得了对应IP地址的in-addr.arpa域名空间的授权。<br>如果DNS树中没有独立出arpa来处理指针查询，将需要数天或数周的时间来从树根开始依次尝试每个顶级域。</p>
<h3 id="14-5-1-举例"><a href="#14-5-1-举例" class="headerlink" title="14.5.1 举例"></a>14.5.1 举例</h3><p>使用host程序完成一个指针查询，并使用tcpdump程序来观察这些分组。例子中的设置和图14-9相同，在sun主机上运行host程序，名字服务器在主机noao.edu上。我们指明svr4主机的IP地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun % host 140.252.13.34</span><br><span class="line">Name: svr4.tuc.noao.edu</span><br><span class="line">Address: 140.252.13.34</span><br></pre></td></tr></table></figure>
<p>既然IP地址是仅有的命令行参数，host程序将自动产生指针查询。相应的tcpdump输出中</p>
<ul>
<li>第1行显示标识符为1，期望递归标志设置为1（加号“+”），查询类型为PTR（应注意：问号“？”表示它是一个查询而不是响应）。44字节的数据包括12字节的DNS报文首部、28字节的域名标识符和4字节的查询类型和查询类。</li>
<li>查询结果包含一个回答RR，且为授权回答比特置1（带星号）。RR的类型是PTR，资源数据中包含该域名。</li>
</ul>
<h3 id="14-5-2-主机名检查"><a href="#14-5-2-主机名检查" class="headerlink" title="14.5.2 主机名检查"></a>14.5.2 主机名检查</h3><p>当一个IP数据报到达一个作为服务器的主机时，无论是UDP数据报还是TCP连接请求，服务器进程所能获得的是客户的IP地址和端口号（UDP或TCP）。某些服务器需要客户的IP地址来获得在DNS中的指针记录。在27.3节会看到这样的例子，从未知的IP地址使用匿名FTP访问服务器。</p>
<p>其他的一些服务器如Rlogin服务器（第26章）不但需要客户的IP地址来获得指针记录，还要向DNS询问该IP地址所对应的域名，并检查返回的地址中是否有地址与收到的数据报中的源IP地址匹配。该检查是因为.rhosts文件（见26.2节）中的条目仅包含主机名，而没有IP地址，因此主机需要证实该主机名是否对应源IP地址。</p>
<p>某些厂商将该项检查自动并入其名字解析器的例程中，特别是函数gethostbyaddr。这使得任何使用名字解析器的程序均可获得这种检查，而无需在应用中人为地进行这项检查。</p>
<p>来看一个使用SunOS 4.13名字解析器库的例子。我们编制了一个简单的程序通过调用函数gethostbyaddr来完成一个指针查询。我们已在文件/etc/resolv.conf中将名字服务器设置为noao.edu，sun主机通过SLIP链路与它相连。图14-13显示了当调用函数gethostbyaddr获取与IP地址140.252.1.29（sun主机）对应的名字时，tcpdump在SLIP链路上收到的内容。</p>
<p>第1行是预期的指针查询，第2行是预期的响应。但第3行显示了该名字解析器函数自动对第2行返回的名字发出一个IP地址查询。既然sun主机有两个IP地址，第4行的响应就包括两个回答记录。如果这两个地址中没有与gethostbyaddr输入参数匹配的地址，函数会向系统的日志发送一条报文，并向应用程序返回差错。</p>
<h2 id="14-6-资源记录"><a href="#14-6-资源记录" class="headerlink" title="14.6 资源记录"></a>14.6 资源记录</h2><p>IP地址查询为A类型，指针查询为类型PTR。此外还有</p>
<ul>
<li>CNAME：规范名字</li>
<li>HINFO：主机信息</li>
<li>MX：邮件交换记录</li>
<li>NS：名字服务器记录<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_x3.png"><br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_x4.png"></li>
</ul>
<h2 id="14-7-高速缓存"><a href="#14-7-高速缓存" class="headerlink" title="14.7 高速缓存"></a>14.7 高速缓存</h2><p>所有的名字服务器均使用高速缓存</p>
<p>使用host命令执行下列查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun % host ftp.uu.net</span><br><span class="line">ftp.uu.net    A    192.48.96.9</span><br></pre></td></tr></table></figure>
<p>这次在tcpdump中使用了新的选项。使用-w选项来收集进出UDP或TCP 53号端口的所有数据。将这些原始数据记录在一个文件中供以后处理，同时防止tcpdump试图调用名字解析器来显示与那个IP地址相对应的域名。执行查询后，终止tcpdump并使用-r选项再次运行它。它会读取含有原始数据的文件并产生正式的输出显示（如图1414）。这个过程要花费几秒钟，因为tcpdump调用了它自己的名字解析器。</p>
<p>相应的tcpdump输出中要注意的第一点是标识符(identifier)是小整数（2和3）。这是因为我们关闭这个名字服务器，后又重新启动它来强制清空它的高速缓存。当名字服务器启动时，它将标识符初始化为1。</p>
<p>当键入查询，查找主机ftp.uu.net的IP地址，该名字服务器就同8个根名字服务器中的一个ns.nic.ddn.mil（第1行）取得联系。这是以前见到的正常的A类型查询，但要注意的是它的期望递归表示没有说明（如果该标志被设置，在标识符2的后边会跟着一个加号）。在以前的例子中，经常看到名字解析器设置期望递归标志，但这里的名字服务器在与某个根服务器联系时没有设置这个标志。这是因为不应该向根名字服务器发出期望递归的查询，它们仅用来寻找其他授权名字服务器的地址。</p>
<p>第2行显示返回的响应中没有回答资源记录，而包含5个授权资源记录和5个附加信息资源记录。标识符2后的减号表示期望递归标志（RA）没有被设置。即使我们要求进行递归查询，这个根名字服务器也不会回答期望递归查询。</p>
<p>尽管tcpdump没有显示返回的10个资源记录，我们也能执行host命令来查看高速缓存的内容：</p>
<p>这次采用-v选项查看的不仅仅只是A记录。它显示出对于域uu.net有5个授权名字服务器，而由根名字服务器返回的5个附加信息资源记录中含有这5个名字服务器的IP地址。这避免了在查找其中的某个名字服务器的地址时，无需再次与根名字服务器联系。这是DNS中的另一个实现优化。</p>
<p>host命令指出这个回答不是授权的，这是因为这个回答来自名字服务器的高速缓存，而不是来自授权名字服务器。</p>
<h4 id="例子未理解"><a href="#例子未理解" class="headerlink" title="例子未理解"></a>例子未理解</h4><h2 id="14-8-用UDP还是用TCP"><a href="#14-8-用UDP还是用TCP" class="headerlink" title="14.8 用UDP还是用TCP"></a>14.8 用UDP还是用TCP</h2><p>TCP：主、辅服务器之间执行区域传送时，返回的响应超过512字节时</p>
<p>DNS主要使用UDP，必须自己处理超时和重传。</p>
<p>DNS查询和响应通常经过广域网。端口号都是53。</p>
<h2 id="14-9-另一个例子"><a href="#14-9-另一个例子" class="headerlink" title="14.9 另一个例子"></a>14.9 另一个例子</h2><p>让我们通过另一个例子将已经介绍的许多DNS特性作一个综合性回顾。先启动Rlogin客户程序，然后连接到一个位于其他域的Rlogin服务器。图14-16显示了发生的分组交换过程。下面发生的11个步骤都假定客户和服务器的高速缓存中没有任何信息。<br>1.客户程序启动后，调用它的名字解析器函数将我们键入的主机名转换为一个IP地址。一个A类型的查询请求被送往一个根服务器。<br>2.由根服务器返回的响应中包含为该服务器所在域服务的名字服务器名。<br>3.客户端的名字解析器将向该服务器的名字服务器重发上述A类型查询，这个查询通常是将期望递归标志设置为1。<br>4.返回的应答中包含Rlogin服务器的IP地址。<br>5.Rlogin客户和Rlogin服务器建立一个TCP连接（第18章将提供该步骤的细节）。客户和服务器的TCP模块间将交换3个分组。<br>Rlogin服务器收到来自客户的连接请求后，调用它的名字解析器通过TCP连接请求中的IP地址获得客户主机名。这是一个PTR查询请求，由一个根名字服务器处理。这个根名字服务器可以不同于步骤1中客户使用的根名字服务器。<br>7.这个根名字服务器的响应中含有为客户的in-addr.arpa域的名字服务器。<br>8.服务器上的名字解析器将向客户的名字服务器重传上述PTR查询。<br>9.返回的PTR应答中含有客户主机的FQDN。<br>10.服务器的名字解析器向客户的名字服务器发送一个A类型查询请求，查找前一步返回的名字对应的IP地址。这可能由服务器中的gethostbyaddr函数自动完成，正如我们在14.5节中介绍的那样，否则Rlogin服务器将完成这一步。此外，客户的名字服务器常常就是客户的in-addr.arpa名字服务器，但这不是必需的。<br>11.从客户的名字服务器返回的响应含有客户主机的A记录。Rlogin服务器将客户的TCP连接请求中的IP地址与A记录作比较。<br>高速缓存将减少这个图中交换的分组数目。</p>
<h2 id="14-10-小结"><a href="#14-10-小结" class="headerlink" title="14.10 小结"></a>14.10 小结</h2><p>名字解析器将向一个本地名字服务器发出查询请求，这个名字服务器可能通过某个根名字服务器或其他名字服务器来完成这个查询。</p>
<p>所有的DNS查询和响应都有相同的报文格式。通过许多例子能了解名字解析器的配置文件以及DNS的优化措施。</p>
<h2 id="ch14-习题"><a href="#ch14-习题" class="headerlink" title="ch14 习题"></a>ch14 习题</h2><ol>
<li>14.1讨论一个DNS名字解析器和一个DNS名字服务器作为客户程序、服务器或同时作为客户和服务器的情况。</li>
</ol>
<ul>
<li>答案是：一个解析器总是一个客户，但一个名字服务器既是一个客户又是一个服务器。</li>
</ul>
<ol>
<li>说明图14-12中构成响应的75个字节的含义。</li>
</ol>
<ul>
<li>答案是：问题被返回，它占用了前44个字节。一个回答占用了剩下来的31个字节：2个字节指向域名的指针（即，指向问题中域名的一个指针），10字节固定长度的字段（类型、种类、TTL和资源长度），19字节的资源数据（一个域名）。注意到资源数据中的域名（svr4.tuc.noao.edu.）没有共享问题（34.13.252.140.in-addr.arpa.）中域名的后缀，所以不能使用一个指针。</li>
</ul>
<ol>
<li>在12.3节我们指出，一个既可接受点分十进制形式的IP地址、也可接收主机名的应用程序，应先假定输入的是IP地址，如果失败，再假定是主机名。如果改变这个测试顺序会出现什么情况？</li>
</ol>
<ul>
<li>答案是：将顺序颠倒意味着首先使用DNS，如果使用DNS失败，然后才将参数翻转过来作为一个点分十进制数。这就是说每次说明一个点分十进制数，都要使用DNS，涉及一个名字服务器。这是对资源的一种浪费。</li>
</ul>
<ol>
<li>每个UDP数据报有一个相应的长度。一个接收UDP数据报的进程将被告知这个长度。当名字解析器使用TCP而不是UDP来处理查询请求时，由于TCP是没有任何记录标记的字节流，那么应用程序是如何知道有多少数据返回？注意在DNS的报文首部（图14-3）中没有任何长度字段（提示：查阅 RFC 1035）</li>
</ol>
<ul>
<li>答案是：RFC 1035的4.2.2节说明了在实际的DNS报文之前的两个字节长度的字段。</li>
</ul>
<ol>
<li>我们说一个名字服务器必须知道根名字服务器的IP地址，这一信息可通过匿名FTP获得。不幸的是当根名字服务器表发生变化时，并不是所有的系统管理员都会更新他们的DNS配置文件（根名字服务表的确会发生变化，尽管不是经常的）你认为DNS如何处理这个问题？</li>
</ol>
<ul>
<li>答案是：当一个名字服务器启动时，它一般从一个磁盘文件中读出一个根服务器列表（可能已经过时了）。然后尝试和这些根服务器中的一个联系，请求根域的名字服务器记录（一个NS的查询类型）。这个请求返回了当前最新的根服务器列表。启动磁盘文件中根服务器项中至少需要一个是有效的。</li>
</ul>
<ol>
<li>利用习题1.8指明的文件来确定谁应负责维护根名字服务器。名字服务器更新的频度是怎样的？</li>
</ol>
<ul>
<li>答案是：InterNIC的注册服务每一周更新三次根服务器。</li>
</ul>
<ol>
<li>维护一个名字服务器和一个无状态的名字解析器高速缓存的问题分别是什么？</li>
</ol>
<ul>
<li>答案是：就像应用是不定的一样，解析器也是不定的。如果系统配置成使用多个名字服务器，而且解析器是无状态的，那么解析器就不能记住不同的名字服务器的往返时间。这样定时太短的解析器将会超时，引起不必要的重传。</li>
</ul>
<ol>
<li>在图14-10的讨论中，我们指出名字服务器将对A类型记录进行排序以便在公共网中的地址先出现。谁对A类型记录进行这种排序，是名字服务器还是名字解析器?</li>
</ol>
<ul>
<li>答案是：对A记录的排序应该由解析器来执行，而不是名字服务器，因为解析器一般比服务器了解更多的客户的网络拓扑（更新版本的BIND提供了解析器对A记录排序的功能）。</li>
</ul>
<h1 id="ch15-TFTP：简单文件传送协议"><a href="#ch15-TFTP：简单文件传送协议" class="headerlink" title="ch15 TFTP：简单文件传送协议"></a>ch15 TFTP：简单文件传送协议</h1><h2 id="15-1-引言"><a href="#15-1-引言" class="headerlink" title="15.1 引言"></a>15.1 引言</h2><p>TFTP(Trivial File Transfer Protocol)即简单文件传送协议，最初打算用于引导无盘系统（通常是工作站或X终端）。<br>为了保持简单和短小，TFTP将使用UDP。TFTP的代码（和它所需要的UDP、IP和设备驱动程序）都能适合只读存储器。</p>
<h2 id="15-2-协议"><a href="#15-2-协议" class="headerlink" title="15.2 协议"></a>15.2 协议</h2><p>在开始工作时，TFTP的客户与服务器交换信息，客户发送一个读请求或写请求给服务器。在一个无盘系统进行系统引导的正常情况下，第一个请求是读请求（RRQ）。图15-1显示了5种TFTP报文格式（操作码为1和2的报文使用相同的格式）。</p>
<p>TFTP报文的头两个字节表示操作码。对于读请求和写请求（WRQ），文件名字段说明客户要读或写的位于服务器上的文件。这个文件字段以0字节作为结束（见图15-1）。模式字段是一个ASCII码串netascii或octet（可大小写任意组合），同样以0字节结束。netascii表示数据是以成行的ASCII码字符组成，以两个字节—回车字符后跟换行字符（称为CR/LF）作为行结束符。这两个行结束字符在这种格式和本地主机使用的行定界符之间进行转化。octet则将数据看作8bit一组的字节流而不作任何解释。</p>
<p>每个数据分组包含一个块编号字段，它以后要在确认分组中使用。以读一个文件作为例子，TFTP客户需要发送一个读请求说明要读的文件名和文件模式(mode)。如果这个文件能被这个客户读取，TFTP服务器就返回一个块编号为1的数据分组。TFTP客户又发送一个块编号为1的ACK。TFTP服务器随后发送块编号为2的数据。TFTP客户发回块编号为2的ACK。重复这个过程直到这个文件传送完。除了最后一个数据分组可含有不足512字节的数据，其他每个数据分组均含有512字节的数据。当TFTP客户收到一个不足512字节的数据分组，就知道它收到最后一个数据分组。</p>
<p>在写请求的情况下，TFTP客户发送WRQ指明文件名和模式。如果该文件能被该客户写，TFTP服务器就返回块编号为0的ACK包。该客户就将文件的头512字节以块编号为1发出。服务器则返回块编号为1的ACK。</p>
<p>这种类型的数据传输称为停止等待协议。它只用在一些简单的协议如TFTP中。在20.3节中将看到TCP提供了不同形式的确认，能提供更高的系统吞吐量。TFTP的优点在于实现的简单而不是高的系统吞吐量。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/15/images2/52im_net_1.png" alt="图15-1 5种TFTP报文格式"><br>最后一种TFTP报文类型是差错报文，它的操作码为5。它用于服务器不能处理读请求或写请求的情况。在文件传输过程中的读和写差错也会导致传送这种报文，接着停止传输。差错编号字段给出一个数字的差错码，跟着是一个ASCII表示的差错报文字段，可能包含额外的操作系统说明的信息。</p>
<p>既然TFTP使用不可靠的UDP，TFTP就必须处理分组丢失和分组重复。分组丢失可通过发送方的超时与重传机制解决（注意存在一种称为“魔术新手综合症(sorcerer’s apprentice syndrome)”的潜在问题，如果双方都超时与重传，就可能出现这个问题。12.2节 [Stevens 1990] 介绍了这个问题是如何发生的)。和许多UDP应用程序一样，TFTP报文中没有检验和，它假定任何数据差错都将被UDP的检验和检测到（参见11.3节）。</p>
<h2 id="15-3-一个例子"><a href="#15-3-一个例子" class="headerlink" title="15.3 一个例子"></a>15.3 一个例子</h2><p>让我们通过观察协议的工作情况来了解TFTP。在bsdi主机上运行TFTP客户程序，并从主机svr4读取一个文本文件：<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/15/images2/52im_net_2.png"><br>最先引起我们注意的是在Unix系统下接收的文件长度是914字节，而TFTP则传送了962个字节。使用wc程序我们看到文件共有48行，因此48个Unix的换行符被转化成48个CR/CF对，因为默认情况下TFTP使用netascii模式传送。</p>
<p>图15-2显示了发生的分组交换过程。</p>
<p>由于目的UDP端口是TFTP熟知端口（69），tcpdump将解释TFTP分组，并显示RRQ和文件名。而不是简单地输出<code>udp 字节数</code></p>
<p>TFTP协议需要客户进程向服务器进程的UDP熟知端口（69）发送第一个分组（RRQ或WRQ）。之后服务器进程便向服务器主机申请一个尚未使用的端口</p>
<p>服务器进程端口变化的原因是这个熟知端口要留出来供其他的TFTP客户进程发送它们的请求。</p>
<p>回顾图10-6，当RIP服务器向客户发送的数据超过512字节，两个UDP数据报都使用服务器的熟知端口。在那个例子中，即使服务器进程必须写多个数据报以便将所有数据发回，服务器进程也是先写一个，再写一个，它们都使用它的熟知端口。然而，TFTP协议与它不同，因为客户与服务器间的连接需要持续一个较长的时间（可能是数秒或数分钟）。如果一个服务器进程使用熟知端口来进行文件传输，那么在文件传输期间，它要么拒绝任何来自其他客户的请求，要么一个服务器进程在同一端口（69）同时对多个客户进程进行多个文件传输。</p>
<h2 id="15-4-安全性"><a href="#15-4-安全性" class="headerlink" title="15.4 安全性"></a>15.4 安全性</h2><p>注意在TFTP分组（图15-1）中并不提供用户名和口令。</p>
<h2 id="15-5-小结"><a href="#15-5-小结" class="headerlink" title="15.5 小结"></a>15.5 小结</h2><p>TFTP协议没有提供安全特性。大多数执行指望TFTP服务器的系统管理员来限制客户的访问，只允许它们访问引导所必须的文件。</p>
<h2 id="ch15-习题"><a href="#ch15-习题" class="headerlink" title="ch15 习题"></a>ch15 习题</h2><ol>
<li>阅读Host Requirements RFC，了解如果一个TFTP服务器收到的请求的目的IP地址是一个广播地址，它将做什么。</li>
</ol>
<ul>
<li>答案是：送往广播地址的TFTP请求应该被忽略。正像Host Requirements RFC所描述的，对一个广播请求的响应可能产生一个非常严重的安全漏洞。但是，问题是并不是所有的实现和API都对接收一个UDP数据报的进程提供了该数据报的目的地址（11.12节）。因为这个原因，很多TFTP服务器没有严格遵守这个限制。</li>
</ul>
<ol>
<li>当TFTP块号由65535跳回到0时，你认为会发生什么？RFC 1350提到了如何处理这一问题吗？</li>
</ol>
<ul>
<li>答案是：不幸的是，RFC没有提到这个块数目环绕问题。具体实现时应该能够传输最大为33 553 920（65535×512）字节的文件。但是当文件的长度超过16 776 704（32767×512）时，很多实现都会失败，因为它们将块数目错误地表示为一个有符号的16位整数，而不是一个无符号的整数。</li>
</ul>
<ol>
<li>TFTP发送方采用超时重发来处理分组丢失。当TFTP作为引导进程的一部分时，这种方法对TFTP的使用有何影响？</li>
</ol>
<ul>
<li>答案是：这样简化了编写一个适合于只读内存的TFTP客户的工作，因为服务器是引导文件的发送者，所以服务器必须实现超时和重传机制。</li>
</ul>
<ol>
<li>使用TFTP时，影响传输文件所需时间的限制性因素是什么？</li>
</ol>
<ul>
<li>答案是：利用它的停止等待协议，TFTP可以在每一次客户与服务器的往返过程中最多传输512字节的数据。TFTP的最大吞吐量就是512字节除以客户与服务器之间的往返时间。在以太网上，假设一个往返时间为3ms，那么最大的吞吐量就是大约170 000字节/秒。</li>
</ul>
<h1 id="ch16-BOOTP：引导程序协议"><a href="#ch16-BOOTP：引导程序协议" class="headerlink" title="ch16 BOOTP：引导程序协议"></a>ch16 BOOTP：引导程序协议</h1><h2 id="16-1-引言"><a href="#16-1-引言" class="headerlink" title="16.1 引言"></a>16.1 引言</h2><p>在第5章我们介绍了一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：</p>
<ul>
<li>IP地址是返回的唯一结果；</li>
<li>既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。<br>本章将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。</li>
</ul>
<p>BOOTP使用UDP，且通常需与TFTP（参见第15章）协同工作。</p>
<h2 id="16-2-BOOTP的分组格式"><a href="#16-2-BOOTP的分组格式" class="headerlink" title="16.2 BOOTP的分组格式"></a>16.2 BOOTP的分组格式</h2><p>图16-2显示了长度为300字节的BOOTP请求和应答的格式。</p>
<p>“操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答（图4-3）中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。</p>
<p>“跳数”字段由客户设置为0，但也能被一个代理服务器设置（参见16.5节）。</p>
<p>“事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。</p>
<p>客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。</p>
<p>如果该客户已经知道自身的IP地址，它将写入“客户IP地址”字段。否则，它将该字段设置为0。对于后面这种情况，服务器用该客户的IP地址写入“你的IP地址”字段。“服务器IP地址”字段则由服务器填写。如果使用了某个代理服务器（见16.5节），则该代理服务器就填写“网关IP地址”字段。</p>
<p>客户必须设置它的“客户硬件地址”字段。尽管这个值与以太网数据帧头中的值相同，UDP数据报中也设置这个字段，但任何接收这个数据报的用户进程能很容易地获得它（例如一个BOOTP服务器）。一个进程通过查看UDP数据报来确定以太网帧首部中的该字段通常是很困难的（或者说是不可能的）。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_2.png" alt="图16-2 BOOTP请求和应答的格式"><br>“服务器主机名”字段是一个空值终止串，由服务器填写。服务器还将在“引导文件名字段”填入包括用于系统引导的文件名及其所在位置的路径全名。</p>
<p>“特定厂商区域”字段用于对BOOTP进行不同的扩展。16.6节将介绍这些扩展中的一些。</p>
<p>当一个客户使用BOOTP（操作码为1）进行系统引导时，引导请求通常是采用链路层广播，IP首部中的目的IP地址为255.255.255.255（受限的广播，12.2节）。源IP地址通常是0.0.0.0，因为此时客户还不知道它本身的IP地址。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>BOOTP有两个熟知端口：BOOTP服务器为67，BOOTP客户为68。这意味着BOOTP客户不会选择未用的临时端口，而只用端口68。选择两个端口而不是仅选择一个端口为BOOTP服务器用的原因是：服务器的应答可以进行广播（但通常是不用广播的）。</p>
<p>如果服务器的应答是通过广播传送的，同时客户又选择未用的临时端口，那么这些广播也能被其他的主机中碰巧使用相同临时端口的应用进程接收到。因此，采用随机端口（即临时端口）对广播来说是一个不好的选择。</p>
<p>如果客户也使用服务器的知名端口（67）作为它的端口，那么网络内的所有服务器会被唤醒来查看每个广播应答（如果所有的服务器都被唤醒，它们将检查操作码，如果是一个应答而不是请求，就不作处理）。因此可以让所有的客户使用与服务器知名端口不同的同一知名端口。</p>
<p>如果多个客户同时进行系统引导，并且服务器广播所有应答，这样每个客户都会收到其他客户的应答。客户可以通过BOOTP首部中的事务标识字段来确认应答是否与请求匹配，或者可以通过检查返回的客户硬件地址加以区分。</p>
<h2 id="16-3-一个例子"><a href="#16-3-一个例子" class="headerlink" title="16.3 一个例子"></a>16.3 一个例子</h2><p>让我们看一个用BOOTP引导一个X终端的例子。图16-3显示了tcpdump的输出结果（例中客户名为proteus，服务器名为mercury。这个tcpdump的输出是在不同的网络上获得的，这个应用程序是其他例子中一直使用的）。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_3.png" alt="图16-3 用BOOTP引导一个X终端的例子"><br>在第1行中，我们看到客户请求来自0.0.0.0.68，发送目的站是255.255.255.255.67。该客户已经填写的字段是秒数和自身的以太网地址。我们看到客户通常将秒数设置为1 0 0。tcpdump没有显示跳数和事务标识，因为它们均为0(事务标识为0表示该客户忽略这个字段，因为如果打算对返回响应进行验证，它将把这个字段设置为一个随机数值)。</p>
<p>第2行是服务器返回的应答。由服务器填写的字段是该客户的IP地址（tcpdump显示为名字proteus）、服务器的IP地址（显示为名字mercury）、网关的IP地址（显示为名字mercury）和引导文件名。</p>
<p>在收到BOOTP应答后，该客户立即发送一个ARP请求来了解网络中其他主机是否有IP地址。跟在who-has后的名字proteus对应目的IP地址（图4-3），发送者的IP地址被设置为0.0.0.0。它在0.5秒后再发一个相同的ARP请求，之后再过0.5秒又发一个。在第3个ARP请求（第5行）中，它将发送者的IP地址改变为它自己的IP地址。这是一个没有意义的ARP请求（见4.7节）。</p>
<p>第6行显示该客户在等待另一个0.5秒后，广播另一个BOOTP请求。这个请求与第1行的唯一不同是此时客户将它的IP地址写入IP首部中。它收到来自同一个服务器的相同应答（第7行）。该客户在等待2秒后，又广播一个BOOTP请求（第8行），同样收到来自同一服务器的相同应答。</p>
<p>该客户等待2秒后，向它的服务器mercury发送一个ARP请求（第10行）。收到这个ARP应答后，它立即发送一个TFTP读请求，请求读取它的引导文件（第12行）。文件传送过程包括2464个TFTP数据分组和确认，传送的数据量为512×2463+224=1261 280字节。这将操作系统调入X终端。我们已在图16-3中删除了大多数TFTP行。</p>
<p>当和图15-2比较TFTP的数据交换过程时，要注意的是这儿的客户在整个传输过程中使用TFTP的知名端口（69）。既然通信双方中的一方使用了端口69，tcpdump就知道这些分组是TFTP报文，因此它能用TFTP协议来解释每个分组。这就是为什么图16-3能指明哪些包含有数据，哪些包含有确认，以及每个分组的块编号。在图15-2中我们并不能获得这些额外的信息，因为通信双方均没有使用TFTP的知名端口进行数据传送。由于TFTP服务器作为一个多用户系统，且使用TFTP的知名端口，因此通常TFTP客户不能使用那个端口。但这里的系统处于正被引导的过程中，无法提供一个TFTP服务器，因此允许该客户在传输期间使用TFTP的知名端口。这也暗示在mercury上的TFTP服务器并不关心客户的端口号是什么—它只将数据传送到客户的端口上，而不管发生了什么。</p>
<p>从图16-3可以看出在9秒内共传送了1261 280字节。<strong>数据速率大约为140 000 bps。这比大多数以FTP文件传送形式访问一个以太网要慢，但对于一个简单的停止等待协议如TFTP来说已经很好了。</strong></p>
<p>X终端系统引导后，还需使用TFTP传送终端的字体文件、某些DNS名字服务器查询，然后进行X协议的初始化。图16-3中的所有步骤大概需要15秒钟，其余的步骤需要6秒钟，这样无盘X终端系统引导的总时间是21秒。</p>
<h2 id="16-4-BOOTP服务器的设计"><a href="#16-4-BOOTP服务器的设计" class="headerlink" title="16.4 BOOTP服务器的设计"></a>16.4 BOOTP服务器的设计</h2><p>BOOTP客户通常固化在无盘系统只读存储器中，因此了解BOOTP服务器的实现将更有意义。</p>
<p>首先，BOOTP服务器将从它的熟知端口（67）读取UDP数据报。这没有特别的地方。它不同于RARP服务器（5.4节），它必须读取类型字段为“RARP请求”的以太网帧。BOOTP协议通过将客户的硬件地址放入BOOTP分组中，使得服务器很容易获取客户的硬件地址(图16-2)。</p>
<p>TFTP服务器如何能将一个响应直接送回BOOTP客户？有两种解决办法：</p>
<ul>
<li>为该客户在ARP高速缓存中设置一个条目</li>
<li>服务器广播这个BOOTP应答而不直接将应答发回该客户。</li>
</ul>
<h2 id="16-5-BOOTP穿越路由器"><a href="#16-5-BOOTP穿越路由器" class="headerlink" title="16.5 BOOTP穿越路由器"></a>16.5 BOOTP穿越路由器</h2><p>我们在5.4节中提到RARP的一个缺点就是它使用链路层广播，这种广播通常不会由路由器转发。这就需要在每个物理网络内设置一个RARP服务器。如果路由器支持BOOTP协议，那么BOOTP能够由路由器转发（绝大多数路由器厂商的产品都支持这个功能）。</p>
<p>这个功能主要用于无盘路由器，因为如果在磁盘的多用户系统被用作路由器，它就能够自己运行BOOTP服务器。此外，常用的Unix BOOTP服务器（附录F）支持这种中继模式（relay mode）。但如果在这个物理网络内运行一个BOOTP服务器，通常没有必要将BOOTP请求转发到在另外网络中的另一个服务器。</p>
<h2 id="16-6-特定厂商信息"><a href="#16-6-特定厂商信息" class="headerlink" title="16.6 特定厂商信息"></a>16.6 特定厂商信息</h2><p>在图16-2中我们看到了64字节的“特定厂商区域”。RFC 1533 [Alexander and Droms 1993]定义了这个区域的格式。这个区域含有服务器返回客户的可选信息。</p>
<p>如果有信息要提供，这个区域的前4个字节被设置为IP地址99.130.83.99。这可称作魔术甜饼(magic cookie)，表示该区域内包含信息。</p>
<p>这个区域的其余部分是一个条目表。每个条目的开始是1字节标志字段。其中的两个条目仅有标志字段：标志为0的条目作为填充字节（为使后面的条目有更好的字节边界），标志为255的条目表示结尾条目。第一个结尾条目后剩余的字节都应设置为这个数值（255）。</p>
<p>除了这两个1字节的条目，其他的条目还包含一个单字节的长度字段，后面是相应的信息。图16-4显示了厂商说明区域中一些条目的格式。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_4.png" alt="图16-4 厂商说明区域中一些条目的格式"><br>子网掩码条目和时间值条目都是定长条目，因为它们的值总是占4个字节。时间偏移值是从1900年1月1日0时以来的秒数（UTC）。</p>
<p>网关条目是变长条目。长度通常是4的倍数，这个值是一个或多个供客户使用的网关（路由器）的IP地址。返回的第一个必须是首选的网关。</p>
<p>RFC 1533还定义了其他14个条目。其中最重要的可能是DNS名字服务器的IP地址条目，条目的志为6。其他的条目包括打印服务器、时间服务器等的IP地址。详细情况可参考RFC文档。</p>
<p>回到在图16-3中的例子，我们从未看到客户广播一个ICMP地址掩码请求（6.3节）来获取它的子网掩码。尽管tcpdump不能显示出来，但我们可认为客户所在网络的子网掩码在返回的BOOTP应答的厂商说明区域内。</p>
<p>Host Requirements RFC文档推荐一个系统使用BOOTP来获悉它的子网掩码，而不是采用ICMP。</p>
<p>厂商说明区域的大小被限制为64字节。这对某些应用是个约束。一个新的称为动态主机配置协议DHCP（Dynamic Host Configuration Protocol）已经出现，但它不是替代BOOTP的。DHCP将这个区域的长度扩展到312字节，它在RFC 1541 [Droms 1993] 中定义。</p>
<h2 id="16-7-小结"><a href="#16-7-小结" class="headerlink" title="16.7 小结"></a>16.7 小结</h2><p>BOOTP使用UDP，它为引导无盘系统获得它的IP地址提供了除RARP外的另外一种选择。BOOTP还能返回其他的信息，如路由器的IP地址、客户的子网掩码和名字服务器的IP地址。</p>
<p>既然BOOTP用于系统引导过程，一个无盘系统需要下列协议才能在只读存储器中完成：BOOTP、TFTP、UDP、IP和一个局域网的驱动程序。</p>
<p>BOOTP服务器比RARP服务器更易于实现，因为BOOTP请求和应答是在UDP数据报中，而不是特殊的数据链路层帧。一个路由器还能作为真正BOOTP服务器的代理，向位于不同网络的真正BOOTP服务器转发客户的BOOTP请求。</p>
<h2 id="ch16-习题"><a href="#ch16-习题" class="headerlink" title="ch16 习题"></a>ch16 习题</h2><ol>
<li>我们说BOOTP优于RARP的一个方面是BOOTP能穿越路由器，而RARP由于使用链路层广播则不能。在16.5节为使BOOTP穿越路由器，我们必须定义特殊的方式。如果在路由器中增加允许转发RARP请求的功能会发生什么？</li>
</ol>
<ul>
<li>答案是：16.1一个路由器可以转发一个RARP请求到路由器连接的其他网络上的任何一台主机上。但是发送应答就成问题了，路由器还必须转发RARP应答。</li>
<li>BOOTP没有这个应答问题，因为应答的地址是路由器知道如何转发的一般IP地址。问题是RARP只使用了链路层地址，路由器一般不知道在其他的、没有连接在路由器的网络上主机的链路层地址。</li>
</ul>
<ol>
<li>我们说过，当有多个客户程序同时向一个服务器发出引导请求时，因为服务器要广播多个BOOTP应答，BOOTP客户就必须使用事务标识来使响应与请求相匹配。但在图16-3中，事务标识为0，表示这个客户不考虑事务标识。你认为这个客户将如何将这些响应与其请求匹配。</li>
</ol>
<ul>
<li>答案是：它可能使用了自己的硬件地址。该地址应该是唯一的，在请求报文中设置，在应答中返回。</li>
</ul>
<h1 id="ch17-TCP：传输控制协议"><a href="#ch17-TCP：传输控制协议" class="headerlink" title="ch17 TCP：传输控制协议"></a>ch17 TCP：传输控制协议</h1><h2 id="17-1-引言"><a href="#17-1-引言" class="headerlink" title="17.1 引言"></a>17.1 引言</h2><p>第18章描述如可建立和终止一个TCP连接，第19和第20章将了解正常的数据传输过程，包括交互使用（远程登录）和成块数据传送（文件传输）。第21张提供TCP超时及重传的技术细节，第22和第23张将介绍两种其他的定时器。最后，第24章概述TCP新的特性以及TCP的性能。</p>
<h2 id="17-2-TCP的服务"><a href="#17-2-TCP的服务" class="headerlink" title="17.2 TCP的服务"></a>17.2 TCP的服务</h2><p>TCP连接中仅有两方，不能广播和多播</p>
<p>除了可靠性，TCP还能提供流量控制</p>
<p>TCP对字节流的内容不作任何解释</p>
<h2 id="17-3-TCP的首部"><a href="#17-3-TCP的首部" class="headerlink" title="17.3 TCP的首部"></a>17.3 TCP的首部</h2><p>不计任选字段，TCP首部通常是20个字节，最多60字节。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/images2/52im_net_2.png" alt="图17-2 TCP包首部"><br>一个IP地址和一个端口号也称为一个 socket</p>
<p>源端和目的端的 socket 唯一地标识了一个TCP连接</p>
<p>序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个<strong>报文段</strong>中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达2^32－1后又从0开始。</p>
<p>当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号（将在下章详细介绍如何建立和终止连接，届时我们将看到FIN标志也要占用一个序号）。</p>
<p>既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志（下面介绍）为1时确认序号字段才有效。</p>
<p>发送ACK无需任何代价，因为32 bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置，ACK标志也总是被设置为1。</p>
<p>TCP为应用层提供全双工服务。数据能在两个方向上独立地进行传输。连接的每一段必须保持每个方向上的传输数据序号。</p>
<p>当前还无法对数据流中选定的部分进行确认或否认</p>
<p>6个标志比特在随后的章节有更详细的介绍<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/images2/52im_net_x1.png"><br>流量控制由每一端通过声明的窗口大小来提供。窗口大小起始于确认序号字段指明的值。</p>
<p>检验和覆盖了TCP首部和TCP数据，是一个强制性的字段。</p>
<p>最常见的可选字段是最长报文大小，又称为MSS</p>
<h2 id="17-4-小结"><a href="#17-4-小结" class="headerlink" title="17.4 小结"></a>17.4 小结</h2><p>TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。</p>
<h2 id="ch17-习题"><a href="#ch17-习题" class="headerlink" title="ch17 习题"></a>ch17 习题</h2><ol>
<li>我们已经介绍了以下几种分组格式：IP、ICMP、IGMP、UDP和TCP。每一种格式的首部中均包含一个检验和。对每种分组，说明检验和包括IP数据报中的哪些部分，以及该检验和是强制的还是可选的。</li>
</ol>
<ul>
<li>答案是：除了UDP的检验和，其他都是必需的。IP检验和只覆盖了IP首部，而其他字段都紧接着IP首部开始。</li>
</ul>
<ol>
<li>为什么我们已经讨论的所有Internet协议（IP,ICMP,IGMP,UDP,TCP）收到有检验和错的分组都仅作丢弃处理？</li>
</ol>
<ul>
<li>答案是：源IP地址、源端口号或者协议字段可能被破坏了。</li>
</ul>
<ol>
<li>TCP提供了一种字节流服务，而收发双方都不保持记录的边界。应用程序如何提供它们自己的记录标识？</li>
</ol>
<ul>
<li>答案是：很多Internet应用使用一个回车和换行来标记每个应用记录的结束。这是NVT ASCII采用的编码（26.4节）。另外一种技术是在每个记录之前加上一个记录的字节计数，DNS（习题14.4）和Sun RPC（29.2节）采用了这种技术。</li>
</ul>
<ol>
<li>为什么在TCP首部的开始便是源和目的的端口号？</li>
</ol>
<ul>
<li>答案是：就像我们在6.5节所看到的，一个ICMP差错报文必须至少返回引起差错的IP数据报中除了IP首部的前8个字节。当TCP收到一个ICMP差错报文时，它需要检查两个端口号以决定差错对应于哪个连接。因此，端口号必须包含在TCP首部的前8个字节里。</li>
</ul>
<ol>
<li>为什么TCP首部有一个首部长度字段而UDP首部（图11-2）中却没有？</li>
</ol>
<ul>
<li>答：UDP首部的长度是固定的。答案是：TCP首部的最后有一些选项，但UDP首部中没有选项。</li>
</ul>
<h1 id="ch18-TCP连接的建立与终止"><a href="#ch18-TCP连接的建立与终止" class="headerlink" title="ch18 TCP连接的建立与终止"></a>ch18 TCP连接的建立与终止</h1><h2 id="18-1-引言"><a href="#18-1-引言" class="headerlink" title="18.1 引言"></a>18.1 引言</h2><p>本章将详细讨论一个TCP连接是如何建立的以及通信结束后是如何终止的。</p>
<h2 id="18-2-连接的建立与终止"><a href="#18-2-连接的建立与终止" class="headerlink" title="18.2 连接的建立与终止"></a>18.2 连接的建立与终止</h2><p><code>telnet bsdi discard</code>与主机bsdi中的9端口建立discard服务</p>
<h3 id="18-2-1-tcpdump的输出"><a href="#18-2-1-tcpdump的输出" class="headerlink" title="18.2.1 tcpdump的输出"></a>18.2.1 tcpdump的输出</h3><p>TCP报文段在tcpdump上的输出格式为<code>源 &gt; 目的: 标志</code><br>这里的标志代表TCP首部中的6个标志比特中的4个。ACK和URG将作特殊显示</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">3字符缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">SYN</td>
<td>同步序号</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">FIN</td>
<td>发送方完成数据发送</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">RST</td>
<td>复位连接</td>
</tr>
<tr>
<td align="center">P</td>
<td align="center">PSH</td>
<td>尽快将数据送往接收进程</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center"></td>
<td>以上四个标志比特均置0</td>
</tr>
</tbody></table>
<p>上述4个标志比特中的多个可能同时出现在一个报文段中，但通常一次只能见到一个。</p>
<p>相应的tcpdump输出中</p>
<ul>
<li>win 4096    表示<strong>默认</strong>窗口大小</li>
<li>&lt;mss 1024&gt;    表示最大报文段长度</li>
<li>ack 1        表示确认序号与初始序号的相对偏移值为1</li>
<li>1415531521:1415531521(0)    表示分组序号和数据字节数</li>
<li>[tos 0x10]    这是IP数据报内的服务类型（TOS）字段（参见图3-2）。BSD/386中的Telnet客户进程将这个字段设置为最小时延。</li>
</ul>
<h3 id="18-2-2-时间系列"><a href="#18-2-2-时间系列" class="headerlink" title="18.2.2 时间系列"></a>18.2.2 时间系列</h3><h3 id="18-2-3-三次握手"><a href="#18-2-3-三次握手" class="headerlink" title="18.2.3 三次握手"></a>18.2.3 三次握手</h3><ol>
<li>客户发送SYN段指明打算连接到的端口、初始序号（ISN）</li>
<li>服务器发回包含服务器的ISN的SYN报文段作为应答。同时，将确认序号设置为客户的ISN+1以对客户的SYN报文段进行确认</li>
<li>客户必须将确认序号设置为服务器的ISN+1以对服务器的SYN报文段进行确认</li>
</ol>
<p>ISN可看作是一个32比特的计数器，每4ms加1。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它作错误的解释。</p>
<h3 id="18-2-4-四次挥手"><a href="#18-2-4-四次挥手" class="headerlink" title="18.2.4 四次挥手"></a>18.2.4 四次挥手</h3><p>正常关闭：当服务器收到FIN，它发回ACK，同时TCP服务器还向应用程序传送一个文件结束符。接着这个服务器程序就关闭它的连接，导致他的TCP段发送一个FIN，客户必须发回一个确认。</p>
<p>连接通常是由客户端发起的，一般由客户端决定何时终止连接。</p>
<h3 id="18-2-5-正常的tcpdump输出"><a href="#18-2-5-正常的tcpdump输出" class="headerlink" title="18.2.5 正常的tcpdump输出"></a>18.2.5 正常的tcpdump输出</h3><p>默认情况下tcpdump只在显示SYN报文段时显示完整的序号，而对其后的序号则显示它们与初始序号的相对偏移值</p>
<h2 id="18-3-连接建立的超时"><a href="#18-3-连接建立的超时" class="headerlink" title="18.3 连接建立的超时"></a>18.3 连接建立的超时</h2><p>首次超时间隔约6秒，第二次超时间隔非常接近24秒</p>
<p>这是因为BSD版的TCP软件采用一种500 ms的定时器。</p>
<h2 id="18-4-最大报文段长度"><a href="#18-4-最大报文段长度" class="headerlink" title="18.4 最大报文段长度"></a>18.4 最大报文段长度</h2><p>在有些书中，将它看作可“协商”选项。它并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（MSS选项只能出现在SYN报文段中）。如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报)。</p>
<h4 id="例子已理解-10"><a href="#例子已理解-10" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>由于slip知道它外出接口的MTU长度为296，即使sun已经通告它的MSS为1460，但为避免将数据分段，它不会发送超过256字节数据的报文段。系统允许发送的数据长度小于另一端的MSS值。</p>
<h2 id="18-5-TCP的半关闭"><a href="#18-5-TCP的半关闭" class="headerlink" title="18.5 TCP的半关闭"></a>18.5 TCP的半关闭</h2><p>半关闭：一个TCP连接在收到一个FIN后仍能发送数据，但在实际应用中只有很少的TCP应用程序这样做。</p>
<h4 id="例子已理解-11"><a href="#例子已理解-11" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>sort程序只有读取到所有输入数据后才能产生输出。所有的原始数据通过TCP连接从rsh客户端传送到sort服务器进行排序。当输入（datafile）到达文件尾时，rsh客户端执行这个TCP连接的半关闭。</p>
<h2 id="18-6-TCP的状态变迁图"><a href="#18-6-TCP的状态变迁图" class="headerlink" title="18.6 TCP的状态变迁图"></a>18.6 TCP的状态变迁图</h2><p><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_14.png" alt="图18-12 TCP的状态变迁图"><br>在这个图中要注意的第一点是一个状态变迁的子集是“典型的”。我们用粗的实线箭头表示正常的客户端状态变迁，用粗的虚线箭头表示正常的服务器状态变迁。</p>
<h3 id="18-6-1-2MSL等待状态"><a href="#18-6-1-2MSL等待状态" class="headerlink" title="18.6.1 2MSL等待状态"></a>18.6.1 2MSL等待状态</h3><p>TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>大多数TCP实现在2MSL等待期间不能使用本地端口，任何迟到的报文段将被丢弃</p>
<p>客户执行主动关闭并进入TIME_WAIT是正常的。服务器通常执行被动关闭，不会进入TIME_WAIT状态。如果终止一个已经建立连接的服务器程序，并立即重新启动这个服务器程序，将不能把它的这个熟知端口赋值给它的端点，要等1~4分钟。</p>
<p>可以通过sock程序看到这一切。我们启动服务器程序，从一个客户程序进行连接，然后停止这个服务器程序。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_17.png"><br>当重新启动服务器程序时，程序报告一个差错信息说明不能绑定它的熟知端口，因为该端口已被使用（即它处于2MSL等待）。</p>
<p>运行netstat程序来查看连接的状态，以证实它的确处于2MSL等待状态。</p>
<p>尽管许多具体的实现中允许一个进程重新使用仍处于2MSL等待的端口（通常是设置选项SO_REUSEADDR），但TCP不能允许一个新的连接建立在相同的插口对上。可通过下面的试验来看到这一点：</p>
<h4 id="例子已理解-12"><a href="#例子已理解-12" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>大多数伯克利半实现允许一个新的连接请求到达仍处于TIME_WAIT状态的连接，只要新的序号大于该链接前一个替身的最后序号。这违反了TCP规范</p>
<h3 id="18-6-2-平静时间的概念"><a href="#18-6-2-平静时间的概念" class="headerlink" title="18.6.2 平静时间的概念"></a>18.6.2 平静时间的概念</h3><p>对于来自某个连接的较早替身的迟到报文段，2MSL等待可防止将它解释成使用相同插口对的新连接的一部分。但这只有在处于2MSL等待连接中的主机处于正常工作状态时才有效。</p>
<p>如果使用处于2MSL等待端口的主机出现故障，它会在MSL秒内重新启动，并立即使用故障前仍处于2MSL的插口对来建立一个新的连接吗？如果是这样，在故障前从这个连接发出而迟到的报文段会被错误地当作属于重启后新连接的报文段。无论如何选择重启后新连接的初始序号，都会发生这种情况。</p>
<p>为了防止这种情况，RFC 793指出TCP在重启动后的MSL秒内不能建立任何连接。这就称为平静时间(quiet time)。</p>
<p>只有极少的实现版遵守这一原则，因为大多数主机重启动的时间都比MSL秒要长。</p>
<h3 id="18-6-3-FIN-WAIT-2状态"><a href="#18-6-3-FIN-WAIT-2状态" class="headerlink" title="18.6.3 FIN_WAIT_2状态"></a>18.6.3 FIN_WAIT_2状态</h3><p>在FIN_WAIT_2状态我们已经发出了FIN，并且另一端也已对它进行确认。除非我们在实行半关闭，否则将等待另一端的应用层意识到它已收到一个文件结束符说明，并向我们发一个FIN来关闭另一方向的连接。只有当另一端的进程完成这个关闭，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。</p>
<p>这意味着我们这端可能永远保持这个状态。另一端也将处于CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭。</p>
<h2 id="18-7-复位报文段（RTS）"><a href="#18-7-复位报文段（RTS）" class="headerlink" title="18.7 复位报文段（RTS）"></a>18.7 复位报文段（RTS）</h2><p>发往基准的连接出现错误就会发出复位报文段</p>
<h3 id="18-7-1-到不存在的端口的连接请求"><a href="#18-7-1-到不存在的端口的连接请求" class="headerlink" title="18.7.1 到不存在的端口的连接请求"></a>18.7.1 到不存在的端口的连接请求</h3><p>产生复位的一种常见情况是目的端口没有进程正在听。对于UDP，将产生ICMP端口不可达的信息；而TCP则使用复位。</p>
<h4 id="例子已理解-13"><a href="#例子已理解-13" class="headerlink" title="例子已理解"></a>例子已理解</h4><h3 id="18-7-2-异常终止一个连接"><a href="#18-7-2-异常终止一个连接" class="headerlink" title="18.7.2 异常终止一个连接"></a>18.7.2 异常终止一个连接</h3><p>异常释放：不用FIN来释放连接，而是发送复位报文段。</p>
<p>RTS报文段不会导致另一端产生任何响应，不进行确认，直接通知应用层连接复位</p>
<p>异常终止一个连接对应用程序来说有两个优点：（1）丢弃任何待发数据并立即发送复位报文段；（2）RST的接收方会区分另一端执行的是异常关闭还是正常关闭。应用程序使用的API必须提供产生异常关闭而不是正常关闭的手段。</p>
<h4 id="例子已理解-14"><a href="#例子已理解-14" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>使用sock程序能够观察这种异常关闭的过程。Socket API通过“linger on close”选项（SO_LINGER）提供了这种异常关闭的能力。我们加上-L选项并将停留时间设为0。这将导致连接关闭时进行复位而不是正常的FIN。</p>
<h3 id="18-7-3-检测半打开连接"><a href="#18-7-3-检测半打开连接" class="headerlink" title="18.7.3 检测半打开连接"></a>18.7.3 检测半打开连接</h3><p>半打开连接：一方已经关闭或异常终止连接而另一方却还不知道。注意<strong>区分半打开连接与半关闭连接</strong></p>
<p>PC断电时，服务器将永远不知道客户程序已经消失了。</p>
<h4 id="例子已理解-15"><a href="#例子已理解-15" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="18-8-同时打开"><a href="#18-8-同时打开" class="headerlink" title="18.8 同时打开"></a>18.8 同时打开</h2><p>两个应用程序同事彼此执行主动打开的情况是可能的，尽管发生的可能性极小。每一方必须发送一个SYN，且这些SYN必须传递给对方。这需要每一方使用一个对方熟知的端口作为本地端口。这又称为同时打开（simultaneous open）。</p>
<p>这与下面的情况不同：主机A中的Telnet客户程序和主机B中Telnet的服务器程序建立连接，与此同时，主机B中的Telnet客户程序与主机A的Telnet服务器程序也建立连接。在这个Telnet例子中，两个Telnet服务器都执行被动打开，而不是主动打开，并且Telnet客户选择的本地端口不是另一端Te lnet服务器进程所熟悉的端口。</p>
<p>TCP对于同时打开，仅建立一条连接而不是两条连接</p>
<p>图18-17显示了这些状态变迁过程。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>尽管很难，但仍有可能产生一个同时打开的连接。两端必须几乎在同时启动，以便收到彼此的SYN。只要两端有较长的往返时间就能保证这一点。</p>
<p>带-v标志的sock程序来验证连接两端的IP地址和端口号。这个选项也显示每一端的MSS值。</p>
<h4 id="例子已理解-16"><a href="#例子已理解-16" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="18-9-同时关闭"><a href="#18-9-同时关闭" class="headerlink" title="18.9 同时关闭"></a>18.9 同时关闭</h2><p>图18-19总结了这些状态的变化。</p>
<p>同时关闭与正常关闭使用的段交换数目相同</p>
<h2 id="18-10-TCP选项"><a href="#18-10-TCP选项" class="headerlink" title="18.10 TCP选项"></a>18.10 TCP选项</h2><p>TCP首部可以包含选项部分。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_32.png" alt="图18-20 TCP选项"><br>每个选项的开始是1字节kind字段，说明选项的类型。kind字段为0和1的选项仅占1个字节。其他的选项在kind字节后还有len字节。它说明的长度是指总长度，包括kind字节和len字节。</p>
<p>设置无操作选项的原因在于允许发方填充字段为4字节的倍数。如果我们使用4.4BSD系统进行初始化TCP连接，tcpdump将在初始的SYN上显示下面TCP选项：<code>&lt;mss 512, nop, wscale 0, nop, nop, timestamp 146647 0&gt;</code></p>
<p>MSS选项设置为512，后面是NOP，接着是窗口扩大选项。第一个NOP用来将窗口扩大选项填充为4字节的边界。同样，10字节的时间戳选项放在两个NOP后，占12字节，同时使两个4字节的时间戳满足4字节边界。</p>
<p>其他kind值为4、5、6和7的四个选项称为选择ACK及回显选项。由于回显选项已被时间戳选项取代，而目前定义的选择ACK选项仍未定论，并未包括在RFC 1323中，因此图18-20没有将它们列出。另外，作为TCP事务（第24.7节）的T/TCP建议也指明kind为11,12和13的三个选项。</p>
<h2 id="TCP服务器的设计"><a href="#TCP服务器的设计" class="headerlink" title="TCP服务器的设计"></a>TCP服务器的设计</h2><p>大多数TCP服务器进程是并发的。</p>
<p>问题：如何处理端口？多个请求同时到达会怎样？</p>
<h3 id="18-11-1-TCP服务器端口号"><a href="#18-11-1-TCP服务器端口号" class="headerlink" title="18.11.1 TCP服务器端口号"></a>18.11.1 TCP服务器端口号</h3><p>使用netstat命令来观察Telnet服务器<br>-a标志将显示网络中的所有主机端，而不仅仅是处于ESTABLISHED的主机端。-n标志将以点分十进制的形式显示IP地址，而不是通过DNS将地址转化为主机名，同时还要求显示端口号（例如为23）而不是服务名称（如Te lnet）。-f inet选项则仅要求显示使用TCP或UDP的主机。</p>
<p>显示的本地地址为*.23，星号通常又称为通配符。这表示传入的连接请求（即SYN）将被任何一个本地接口所接收。如果该主机是多接口主机，我们将制定其中的一个IP地址为本地IP地址，并且只接收来自这个接口的连接</p>
<p>远端地址显示为*.*，表示还不知道远端IP地址和端口号，因为该端还处于LISTEN状态，正等待连接请求的到达。</p>
<p>现在我们在主机slip（140.252.13.65）启动一个Telnet客户程序来连接这个Telnet服务器。以下是netstat程序的输出行：<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_34.png"><br>端口为23的第1行表示处于ESTABLISHED状态的连接。另外还显示了这个连接的本地IP地址、本地端口号、远端IP地址和远端端口号。本地IP地址为该连接请求到达的接口（以太网接口，140.252.13.33）。</p>
<p>处于LISTEN状态的服务器进程仍然存在。这个服务器进程是当前Te lnet服务器用于接收其他的连接请求。当传入的连接请求到达并被接收时，系统内核中的TCP模块就创建一个处于ESTABLISHED状态的进程。另外，注意处于ESTABLISHED状态的连接的端口不会变化：也是23，与处于LISTEN状态的进程相同。<br>这个例子再次重申TCP使用由本地地址和远端地址组成的4元组：目的IP地址、目的端口号、源IP地址和源端口号来处理传入的多个连接请求。TCP仅通过目的端口号无法确定那个进程接收了一个连接请求。另外，在三个使用端口23的进程中，只有处于LISTEN的进程能够接收新的连接请求。处于ESTABLISHED的进程将不能接收SYN报文段，而处于LISTEN的进程将不能接收数据报文段。</p>
<h3 id="18-11-2-限定的本地IP地址"><a href="#18-11-2-限定的本地IP地址" class="headerlink" title="18.11.2 限定的本地IP地址"></a>18.11.2 限定的本地IP地址</h3><p>我们来看看当服务器不能任选其本地IP地址而必须使用特定的IP地址时的情况。如果我们为sock程序指明一个IP地址（或主机名），并将它作为服务器，那么该IP地址就成为处于LISTEN服务器的本地IP地址。例如<code>sun % sock -s 140.252.1.29 8888</code></p>
<p>使这个服务器程序的连接仅局限于来自SLIP接口（140.252.1.29）。</p>
<p>如果我们试图从以太网（140.252.13）中的主机与这个服务器进行连接，连接请求将被TCP模块拒绝。如果使用tcpdump来观察这一切，对连接请求SYN的响应是一个如图18-21所示的RST。</p>
<h3 id="18-11-3-限定的远端IP地址"><a href="#18-11-3-限定的远端IP地址" class="headerlink" title="18.11.3 限定的远端IP地址"></a>18.11.3 限定的远端IP地址</h3><p>在11.12节，我们知道UDP服务器通常在指定IP本地地址和本地端口外，还能指定远端IP地址和远端端口。RFC 793中显示的接口函数允许一个服务器在执行被动打开时，可指明远端插口（等待一个特定的客户执行主动打开），也可不指明远端插口（等待任何客户）。</p>
<p>遗憾的是，大多数API都不支持这么做。服务器必须不指明远端插口，而等待连接请求的到来，然后检查客户端的IP地址和端口号。</p>
<p>图18-22总结了TCP服务器进行连接时三种类型的地址绑定。在三种情况中，lport是服务器的熟知端口，而localIP必须是一个本地接口的IP地址。表中行的顺序正是TCP模块在收到一个连接请求时确定本地地址的顺序。最常使用的绑定（第1行，如果支持的话）将最先尝试，最不常用的（最后一行两端的IP地址都没有制定）将最后尝试。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_40.png" alt="图18-22 TCP服务器本地和远端IP地址及端口号的规范"></p>
<h3 id="18-11-4-呼入连接请求队列"><a href="#18-11-4-呼入连接请求队列" class="headerlink" title="18.11.4 呼入连接请求队列"></a>18.11.4 呼入连接请求队列</h3><ul>
<li>该队列中的连接已通过三次握手，但还没有被应用层所接受</li>
<li>大多数应用程序都把该队列的最大长度（积压值）说明为5</li>
<li>积压值说明的是TCP监听的端点已被TCP接受而等待应用层接受的最大连接数。这个积压值对系统所允许的最大连接数，或者并发服务器所能并发处理的客户数，并无影响。</li>
<li>如果对于新的连接请求，该TCP监听的端点的连接队列中还有空间（基于图18-23），TCP模块将对SYN进行确认并完成连接的建立。但应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接</li>
<li>如果对于新的连接请求，连接队列中已没有空间，TCP将不理会收到的SYN。也不发回任何报文段（即不发回RST）。如果应用层不能及时接受已被TCP接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。</li>
</ul>
<p>通过sock程序能了解这种情况。我们调用它，并使用新的选项（-O）。让它在创建一个新的服务器进程后而没有接受任何连接请求之前暂停下来。如果在它暂停期间又调用了多个客户进程，它将导致接受连接队列被填满，通过tcpdump能够看到这一切。<code>bsdi % sock -s -v -q1 -O30 5555</code></p>
<h4 id="例子已理解-17"><a href="#例子已理解-17" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>-q1选项将服务器端的积压值置1。</p>
<h2 id="18-12-小结"><a href="#18-12-小结" class="headerlink" title="18.12 小结"></a>18.12 小结</h2><p>无论何时关闭一个连接，一端必须保持这个连接，我们看到TIME_WAIT状态将处理这个问题。处理的原则是执行主动打开的一端在进入这个状态时要保持的时间为TCP实现中规定的MSL值的两倍。</p>
<h2 id="ch18-习题"><a href="#ch18-习题" class="headerlink" title="ch18 习题"></a>ch18 习题</h2><p>在18.2节我们说初始序号（ISN）正常情况下由1开始，并且每0.5秒增加64000，每次执行一个主动打开。这意味着ISN的最低三位通常总是001。但在图18-3中，两个方向上ISN中的最低三位都是521。究竟是怎么回事?<br>在图18-15中，我们键入12个字符，看到TCP发送了13个字节。在图18-16中我们键入8个字符，但TCP发送了10个字符。为什么在第1种情况下增加1个字节，而在第2种情况下增加2个字节？<br>半打开连接和半关闭连接的区别是什么？<br>如果启动sock程序作为一个服务器程序，然后终止它（还没有客户进程与它相连接），我们能立即重新启动这个服务器程序。这意味着它没有经历2MSL等待状态。用状态变迁来解释这一切。<br>在18.6节我们知道一个客户进程不能重新使用同一个本地端口，如果该端口是仍处于2MSL等待连接的一部分。但如果sock程序作为客户程序连续运行两次，并且连接到daytime服务器上，我们就能重新使用同一本地端口。另外，对一个仍处于2MSL等待的连接，也能为它创建一个替身。这将如何做？<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_43.png"><br>在18.6节的最后，我们介绍了FIN_WAIT_2状态，提到如果应用程序仅过11分钟后实行完全关闭（不是半关闭），许多具体的实现都将一个连接由这个状态转移到CLOSED状态。如果另一端（处于CLOSE_WAIT状态）在宣布关闭（即发送FIN）之前等待了12分钟，这一端的TCP将如何响应这个FIN？<br>对于一个电话交谈，哪一方是主动打开，哪一方是被动打开？是否允许同时打开？是否允许同时关闭？<br>在图18-6中，我们没有见到一个ARP请求或一个ARP应答。显然主机svr4的硬件地址一定在bsdi的ARP高速缓存中。如果这个ARP高速缓存不存在，这个图会有什么变化？<br>解释如下的tcpdump输出，并和图18-13进行比较。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_44.png"><br>为什么图18-4中的服务器不将对客户FIN的ACK与自己的FIN合并，从而将报文段数减少为3个？<br>在图18-16中，RST的序号为什么是26368002？<br>TCP向链路层查询MTU是否违反分层的规则？<br>假定在图14.16中，每个DNS使用TCP而不是UDP进行查询，试问需要交换多少个报文段？<br>假定MSL为120秒，试问系统能够初始化一个新连接然后进行主动关闭的最大速率是多少？<br>阅读RFC 793，分析处于TIME_WAIT状态的主机收到使其进入此状态的重复的FIN时所发生的情况。<br>阅读RFC793，分析处于TIME_WAIT状态的主机收到一个RST时所发生的情况。<br>阅读Host Requirements RFC并找出半双工TCP关闭的定义。<br>在图1-8中，我们曾提到到来的TCP报文段可根据其目的端口号进行分用，请问这种说法是否正确？</p>
<h1 id="ch19-TCP的交互数据流"><a href="#ch19-TCP的交互数据流" class="headerlink" title="ch19 TCP的交互数据流"></a>ch19 TCP的交互数据流</h1><h2 id="19-1-引言"><a href="#19-1-引言" class="headerlink" title="19.1 引言"></a>19.1 引言</h2><ul>
<li>成块数据：如FTP、电子邮件和Usenet新闻</li>
<li>交互数据：如Telnet和Rlogin，它们俩的分组中约90%的分组数据小于10字节</li>
</ul>
<h2 id="19-2-交互式输入"><a href="#19-2-交互式输入" class="headerlink" title="19.2 交互式输入"></a>19.2 交互式输入</h2><p>在Rlogin上键入交互命令时，通常每个按键都会产生一个数据分组，而不是每行。</p>
<p>4个报文段（我们一般可以将2和3合并）</p>
<ol>
<li>来自客户的交换件</li>
<li>来自服务器的按键确认</li>
<li>来自服务器的按键回显</li>
<li>来自客户的按键回显确认</li>
</ol>
<p>Telnet有一个选项允许客户发送一行到服务器</p>
<h2 id="19-3-经受时延的确认"><a href="#19-3-经受时延的确认" class="headerlink" title="19.3 经受时延的确认"></a>19.3 经受时延的确认</h2><p>数据捎带ACK：通常TCP在接收到数据时并不立即发送ACK，以便将ACK与需要沿该方向发送的数据一起发送。绝大多数实现采用的时延为200ms</p>
<h2 id="19-4-Nagle算法"><a href="#19-4-Nagle算法" class="headerlink" title="19.4 Nagle算法"></a>19.4 Nagle算法</h2><p>在广域网上，小分组会增加拥塞出现的可能</p>
<p>Nagle算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。</p>
<p>在以太网上一个字节被发送、确认和回显的平均往返时间约为16ms。为了产生比这个速度更快的数据，我们每秒键入的字符必须多于60个。这表明局域网下很少使用这个算法。</p>
<h3 id="19-4-1-关闭Nagle算法"><a href="#19-4-1-关闭Nagle算法" class="headerlink" title="19.4.1 关闭Nagle算法"></a>19.4.1 关闭Nagle算法</h3><p>X窗口系统服务器中的鼠标移动必须无时延地发送。<br>插口API用户可以使用TCP_NODELAY选项来关闭Nagle算法</p>
<h2 id="19-5-窗口大小通告"><a href="#19-5-窗口大小通告" class="headerlink" title="19.5 窗口大小通告"></a>19.5 窗口大小通告</h2><h1 id="ch20-TCP的成块数据流"><a href="#ch20-TCP的成块数据流" class="headerlink" title="ch20 TCP的成块数据流"></a>ch20 TCP的成块数据流</h1><h2 id="20-1-引言"><a href="#20-1-引言" class="headerlink" title="20.1 引言"></a>20.1 引言</h2><p>滑动窗口协议：允许发送方在停止并等待确认前可以连续发送多个分组。<br>本章还介绍PUSH标志、慢启动和吞吐量</p>
<h2 id="20-2-正常数据流"><a href="#20-2-正常数据流" class="headerlink" title="20.2 正常数据流"></a>20.2 正常数据流</h2><h2 id="20-3-滑动窗口"><a href="#20-3-滑动窗口" class="headerlink" title="20.3 滑动窗口"></a>20.3 滑动窗口</h2><p>图20-4用可视化的方法显示了我们<strong>在前一节</strong>观察到的滑动窗口协议</p>
<h2 id="20-4-窗口大小"><a href="#20-4-窗口大小" class="headerlink" title="20.4 窗口大小"></a>20.4 窗口大小</h2><p>下面我们可以看到更多的滑动窗口协议动态变化的例子</p>
<h2 id="20-5-PUSH标志"><a href="#20-5-PUSH标志" class="headerlink" title="20.5 PUSH标志"></a>20.5 PUSH标志</h2><p>发送方使用PUSH标志通知接收方将所收到的数据全部提交给接收进程。</p>
<p>目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。的确，许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志。</p>
<h2 id="20-6-慢启动"><a href="#20-6-慢启动" class="headerlink" title="20.6 慢启动"></a>20.6 慢启动</h2><p>慢启动算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。</p>
<p>慢启动为发送方的TCP增加了另一个窗口：拥塞窗口，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（<strong>即另一端通告的报文段大小</strong>）。每收到一个ACK，拥塞窗口就增加一个报文段。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</p>
<p>拥塞避免<a href="#21-6-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95">CF:21.6节</a></p>
<h2 id="20-7-成块数据吞吐量"><a href="#20-7-成块数据吞吐量" class="headerlink" title="20.7 成块数据吞吐量"></a>20.7 成块数据吞吐量</h2><h3 id="20-7-2-拥塞"><a href="#20-7-2-拥塞" class="headerlink" title="20.7.2 拥塞"></a>20.7.2 拥塞</h3><p>当数据到达一个大的管道并向一个较小的管道发送时便会发生拥塞。</p>
<h2 id="20-8-紧急方式"><a href="#20-8-紧急方式" class="headerlink" title="20.8 紧急方式"></a>20.8 紧急方式</h2><p>通知紧急数据：把TCP首部中的URG比特置1，并把16bit的紧急指针置为一个正的偏移量。</p>
<p>紧急方式有什么用呢？两个最常见的例子是Telnet和Rlogin中当交互用户键入中断键时；另一个例子是FTP用户放弃一个文件的传输时。</p>
<p>如果在接收方处理第一个紧急指针之前，发送方多次进入紧急方式会发生什么情况？接收方只有一个紧急指针，每当对方有新的值到达时它将被覆盖。</p>
<h2 id="20-9-小结"><a href="#20-9-小结" class="headerlink" title="20.9 小结"></a>20.9 小结</h2><p>应用程序使用的有关紧急数据部分的编程接口常常都不是最佳的，从而导致更多的混乱。</p>
<h1 id="ch21-TCP的超时与重传"><a href="#ch21-TCP的超时与重传" class="headerlink" title="ch21 TCP的超时与重传"></a>ch21 TCP的超时与重传</h1><h2 id="21-1-引言"><a href="#21-1-引言" class="headerlink" title="21.1 引言"></a>21.1 引言</h2><p>对每个连接，TCP管理4个不同的定时器</p>
<ol>
<li>重传定时器</li>
<li>坚持定时器</li>
<li>保活定时器</li>
<li>2MSL定时器</li>
</ol>
<h2 id="21-2-超时与重传的简单例子"><a href="#21-2-超时与重传的简单例子" class="headerlink" title="21.2 超时与重传的简单例子"></a>21.2 超时与重传的简单例子</h2><p>拔掉电缆后检查连续重传之间不同的时间差，它们取整后分别为1、3、6、12、24、48和多个64秒。设置的超时时间实际上为1.5秒，此后该时间在每次重传时增加一倍并直至64秒。</p>
<p>这个倍乘关系被称为“指数退避(exponential backoff)”。而6.5节中的TFTP的重传间隔总是5秒。</p>
<p>首次分组传输与复位信号传输之间的时间差约为9分钟，该时间在目前的TCP实现中是不可变的。</p>
<h2 id="21-3-往返时间测量"><a href="#21-3-往返时间测量" class="headerlink" title="21.3 往返时间测量"></a>21.3 往返时间测量</h2><p>TCP超时与重传中最重要的部分就是对一个给定连接的往返时间(RTT)的测量。由于路由器和网络流量均会变化，RTT可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。</p>
<p>首先TCP必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT。<br>每次进行新测量的时候，被平滑的RTT估计器将得到更新。</p>
<h3 id="Karn算法"><a href="#Karn算法" class="headerlink" title="Karn算法"></a>Karn算法</h3><p>重传多义性问题：重传后才收到的ACK是针对哪个分组的呢？</p>
<p>Karn规定，当一个超时和重传发生时，不能更新RTT估计器，因为我们并不知道ACK对应哪次传输</p>
<h2 id="21-4-往返时间RTT的例子"><a href="#21-4-往返时间RTT的例子" class="headerlink" title="21.4 往返时间RTT的例子"></a>21.4 往返时间RTT的例子</h2><h2 id="21-5-拥塞举例"><a href="#21-5-拥塞举例" class="headerlink" title="21.5 拥塞举例"></a>21.5 拥塞举例</h2><h2 id="21-6-拥塞避免算法"><a href="#21-6-拥塞避免算法" class="headerlink" title="21.6 拥塞避免算法"></a>21.6 拥塞避免算法</h2><p>该算法假定由于分组受到损坏引起的丢失是非常少的（远小于1%），因此分组丢失就意味着在源主机和目的主机之间的某处网络发生了拥塞。有两种分组丢失的指示：</p>
<ol>
<li>发生超时</li>
<li>接收到重复的确认</li>
</ol>
<p>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来做到这一点。在实际中这两个算法通常一起实现。</p>
<p>算法需要对每个连接维持两个变量</p>
<ul>
<li>cwnd：拥塞窗口</li>
<li>ssthresh：慢启动门限</li>
</ul>
<p>算法实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cwnd &lt;- 1</span><br><span class="line">ssthresh &lt;- 65535</span><br><span class="line"></span><br><span class="line">TCP输出例程的输出不能超过min(cwnd, 接收方win)</span><br><span class="line"></span><br><span class="line">if(拥塞发生)</span><br><span class="line">	ssthresh &lt;- max( 2 , half( min(cwnd, 接收方win) ) )</span><br><span class="line">	if(是超时引起了拥塞)</span><br><span class="line">		cwnd &lt;- 1	&#x2F;&#x2F;慢启动</span><br><span class="line"></span><br><span class="line">when(新的数据被对方确认)	&#x2F;&#x2F;增加cwnd</span><br><span class="line">	if( cwnd &lt;&#x3D; ssthresh )</span><br><span class="line">		cwnd +&#x3D; 1个报文段大小	&#x2F;&#x2F;指数增加</span><br><span class="line">	else</span><br><span class="line">		cwnd +&#x3D; 1&#x2F;cwnd	&#x2F;&#x2F;加性增长；</span><br></pre></td></tr></table></figure>
<p><a href="#21-8-%E6%8B%A5%E5%A1%9E%E4%B8%BE%E4%BE%8B%EF%BC%88%E7%BB%AD%EF%BC%89">CF：21.8节</a></p>
<h2 id="21-7-快速重传与快速恢复算法"><a href="#21-7-快速重传与快速恢复算法" class="headerlink" title="21.7 快速重传与快速恢复算法"></a>21.7 快速重传与快速恢复算法</h2><p>当收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）。这个重复的ACK不应该被迟延。</p>
<p>由于我们不知道一个重复的ACK是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来。</p>
<ol>
<li>重新排序：只可能产生1~2个重复的ACK</li>
<li>如果一连串收到3个或3个以上的重复ACK，就非常可能是一个<strong>报文段丢失</strong>了</li>
</ol>
<ul>
<li>快速重传算法：无需等待超时定时器一处，直接重传丢失的数据报文段</li>
<li>快速恢复算法：接下来执行的不是慢启动算法而是拥塞避免算法<br>算法实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">when(收到第3个重复的ACK）</span><br><span class="line">	ssthresh &#x3D; half(cwnd)</span><br><span class="line">	cwnd &#x3D; 3*ssthresh</span><br><span class="line">when(收到另一个重复的ACK)</span><br><span class="line">	cwnd +&#x3D; 1个报文段大小</span><br><span class="line">	发送一个分组()</span><br><span class="line">when(下一个确认新数据的ACK到达)</span><br><span class="line">	cwnd &lt;- ssthresh</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="21-8-拥塞举例（续）"><a href="#21-8-拥塞举例（续）" class="headerlink" title="21.8 拥塞举例（续）"></a>21.8 拥塞举例（续）</h2><p>假定不会发生拥塞，则最终拥塞窗口将超过接收方的通告窗口，意味着通告窗口将对数据流进行控制。</p>
<p>cwnd实际上以字节而非以报文段来维护，因此前面提到的<code>cwnd+=1/cwnd</code>实际上是<br><code>cwnd += segsize*segsize/cwnd + segsize/8</code></p>
<h2 id="21-9-按每条路由进行度量"><a href="#21-9-按每条路由进行度量" class="headerlink" title="21.9 按每条路由进行度量"></a>21.9 按每条路由进行度量</h2><p>较新的TCP实现在<strong>路由表项</strong>中维持许多我们在本章已经介绍过的指标。当一个TCP连接关闭时，如果已经发送了16个窗口的数据，且目的节点的路由表项不是一个默认的表项，那么下列信息就保存在路由表项中以备下次使用：</p>
<ul>
<li>被平滑的RTT</li>
<li>被平滑的均值偏差</li>
<li>慢启动门限</li>
</ul>
<h2 id="21-10-ICMP的差错"><a href="#21-10-ICMP的差错" class="headerlink" title="21.10 ICMP的差错"></a>21.10 ICMP的差错</h2><p>TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达。<br>当前基于伯克利的实现对这些错误的处理是</p>
<ul>
<li>源站抑制：cwnd置1，ssthresh不变</li>
<li>主机不可达和网络不可达都被忽略，因为这两个差错都被认为是短暂现象</li>
</ul>
<h2 id="21-11-重新分组"><a href="#21-11-重新分组" class="headerlink" title="21.11 重新分组"></a>21.11 重新分组</h2><p>当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能。在协议中这是允许的，因为TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。</p>
<h1 id="ch22-TCP的坚持定时器"><a href="#ch22-TCP的坚持定时器" class="headerlink" title="ch22 TCP的坚持定时器"></a>ch22 TCP的坚持定时器</h1><h2 id="22-1-引言"><a href="#22-1-引言" class="headerlink" title="22.1 引言"></a>22.1 引言</h2><p>窗口大小为0将有效地组织发送方传送数据，直到窗口变为非0为止。</p>
<p>如果报文段8关闭了窗口，TCP必须能够处理报文段9丢失的情况。因为ACK的传输并不可靠。</p>
<p>窗口探查：为防止这种死锁情况的发生，发送方使用一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已增大。</p>
<h2 id="22-2-一个例子"><a href="#22-2-一个例子" class="headerlink" title="22.2 一个例子"></a>22.2 一个例子</h2><p>窗口探查包含一个字节的数据。TCP总是允许发送已关闭窗口之后一个字节的数据。</p>
<p>坚持状态与重传超时之前的一个不同的特点就是TCP从不放弃发送窗口探查。这个过程建持续到窗口被打开或者应用进程使用的连接被终止。</p>
<h2 id="22-3-糊涂窗口综合症"><a href="#22-3-糊涂窗口综合症" class="headerlink" title="22.3 糊涂窗口综合症"></a>22.3 糊涂窗口综合症</h2><p>基于窗口的流量控制方案会导致糊涂窗口综合症SWS</p>
<p>该现象可发生在两端中的任何一端</p>
<ul>
<li>接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告）</li>
<li>发送方也可以发送少量的数据（而不是等待其他的数据一并发送一个大的报文段）</li>
</ul>
<p>可以在任何一端采取措施避免出现糊涂窗口综合症</p>
<ol>
<li>接收方不通告小窗口。通常的算法是</li>
</ol>
<ul>
<li>仅在窗口可以增加1个MSS时才通告</li>
<li>增加接收方缓存空间的一半，不论实际有多少</li>
</ul>
<ol start="2">
<li>发送方只在以下条件之一满足时才发送数据</li>
</ol>
<ul>
<li>可以发送一个满长度的报文段</li>
<li>可以发送至少是接收方通告窗口大小一半的报文段</li>
<li>能够发送手头的所有数据并且不希望接收ACK或者该连接禁止了Nagle算法（<a href="#19-4-Nagle%E7%AE%97%E6%B3%95">CF：19.4节</a>）</li>
</ul>
<h1 id="ch23-TCP的保活定时器"><a href="#ch23-TCP的保活定时器" class="headerlink" title="ch23 TCP的保活定时器"></a>ch23 TCP的保活定时器</h1><h2 id="23-1-引言"><a href="#23-1-引言" class="headerlink" title="23.1 引言"></a>23.1 引言</h2><p>可以没有任何数据流通过一个空闲的TCP连接。</p>
<p>然而，许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力。</p>
<p>保活并不是TCP规范中的一部分。Host Requirements RFC提供了3个不使用保活定时器的理由。然而，许多实现提供了保活定时器。</p>
<p>在连接两个端系统的网络出现临时故障的时候，保活选项会引起一个实际上很好的连接终止。</p>
<p>保活功能主要是为服务器应用程序提供的。服务器应用程序可能会代表客户绑定一些资源，因此希望知道客户主机是否崩溃。</p>
<h2 id="23-2-描述"><a href="#23-2-描述" class="headerlink" title="23.2 描述"></a>23.2 描述</h2><p>如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段。客户主机必然处于以下4个状态之一</p>
<ol>
<li>正常运行并从服务器可达：正常响应，定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动：无响应，每隔75秒探查一次，总共10次无响应就终止连接。</li>
<li>客户主机正常运行，但是从服务器不可达：与状态2相同，都是无响应。</li>
<li>客户主机已经崩溃并重新启动：响应是一个复位，使得服务器终止这个连接。<br>服务器不用关注客户主机被操作员关闭和重新启动的情况。正常关机会使客户的TCP在连接上发出一个FIN。</li>
</ol>
<h1 id="ch24-TCP的未来和性能"><a href="#ch24-TCP的未来和性能" class="headerlink" title="ch24 TCP的未来和性能"></a>ch24 TCP的未来和性能</h1><h2 id="24-1-引言"><a href="#24-1-引言" class="headerlink" title="24.1 引言"></a>24.1 引言</h2><p>本章讨论TCP的一些修改建议，这些建议可以使TCP在高速率环境中获得最大的吞吐量。</p>
<h2 id="24-2-路径MTU发现"><a href="#24-2-路径MTU发现" class="headerlink" title="24.2 路径MTU发现"></a>24.2 路径MTU发现</h2><p>在2.9节我们描述了路径MTU的概念。在11.8节我们看到UDP是怎样处理路径MTU发现的。在本节我们将讨论这个机制是如何按照RFC1191中规定的那样在TCP中进行使用的。</p>
<p>选定起始的报文段大小：min( 对端声明的MSS（默认为536）, 输出接口的MSS )</p>
<p>一旦选定了起始的报文段大小，在该连接上的所有被TCP发送的IP数据报都将被设置DF比特。如果某个中间路由器需要对一个设置了DF标志比特的数据报进行分片，他就丢弃这个数据报，并产生一个我们在11.6节介绍的ICMP的“不能分片”差错。</p>
<p>如果收到这个ICMP差错，TCP就减少段大小并进行重传。具体做法取决于新旧</p>
<h3 id="24-2-1-一个例子"><a href="#24-2-1-一个例子" class="headerlink" title="24.2.1 一个例子"></a>24.2.1 一个例子</h3><h3 id="24-2-2-大分组还是小分组"><a href="#24-2-2-大分组还是小分组" class="headerlink" title="24.2.2 大分组还是小分组"></a>24.2.2 大分组还是小分组</h3><h2 id="24-3-长肥管道"><a href="#24-3-长肥管道" class="headerlink" title="24.3 长肥管道"></a>24.3 长肥管道</h2><p>一个连接的容量被称为带宽时延乘积，也可称它为两端的管道大小。</p>
<p>具有大的带宽时延乘积的网络被称为长肥网络（LFN）。使用长肥网络会遇到多种问题</p>
<ol>
<li>窗口被限制在65535个字节内。在<a href="#24-4-%E7%AA%97%E5%8F%A3%E6%89%A9%E5%A4%A7%E9%80%89%E9%A1%B9">24.4节</a>介绍的窗口扩大选项可以解决这个问题</li>
<li>在一个长肥网络LFN内的分组丢失会使吞吐量急剧减少。</li>
<li>我们在第21.4节看到许多TCP实现对每个窗口的RTT仅进行一次测量。在一个长肥网络LFN上需要更好的RTT测量机制。我们将在<a href="#24-5-%E6%97%B6%E9%97%B4%E6%88%B3%E9%80%89%E9%A1%B9">24.5节</a>介绍时间戳选项，它允许更多的报文段被计时，包括重传。</li>
<li>TCP序号空间有限。在一个千兆比网络只要34秒就会发生序号的回绕。在<a href="#24-6-PAWS%EF%BC%9A%E9%98%B2%E6%AD%A2%E5%9B%9E%E7%BB%95%E7%9A%84%E5%BA%8F%E5%8F%B7">24.6节</a>我们将介绍一种对付这种情况的办法：使用TCP时间戳选项的PAWS算法（保护回绕的序号）</li>
</ol>
<p>4.4BSD包含了我们将要在下面介绍的所有选项和算法。许多供应商也正在开始支持这些选项。</p>
<h3 id="千兆比网络"><a href="#千兆比网络" class="headerlink" title="千兆比网络"></a>千兆比网络</h3><p>时延和带宽的差别</p>
<p>考虑通过美国发送一个100万字节的文件的情况，假定时延都为30ms。图24-6显示了两种情况，当30ms以后数据的第1个比特都已到达对端时</p>
<ul>
<li>使用1.544Mb/s电话线：发送方仍然有994210个字节等待发送</li>
<li>使用1Gb/s网络：整个文件仅使用了25%左右的带宽，此时文件的最后一个比特已经到达第1个字节后8ms处。</li>
</ul>
<p>在千兆比速率下，时延限制占据了主要地位，而带宽不再成为限制。当我们考虑到分组需要建立和终止一个连接时，这个固定时延起的作用就更糟糕了。千兆比网络会引起一些需要不同看待的观点。</p>
<h2 id="24-4-窗口扩大选项"><a href="#24-4-窗口扩大选项" class="headerlink" title="24.4 窗口扩大选项"></a>24.4 窗口扩大选项</h2><p>通过定义一个选项实现对16bit的窗口定义扩大为32bit</p>
<p>这个选项只能够出现在一个SYN报文段中。<br>主动建立连接的一方在其SYN中发送这个选项，但是被动建立连接的一方只能够在收到带有这个选项的SYN之后才可以发送这个选项。每个方向上的扩大因子可以不同。</p>
<p>如果主动连接的一方发送一个非零的扩大因子，但是没有从另一端收到一个窗口扩大选项，它就将发送和接收的移位计数器置为0。这就允许较新的系统能与较旧、不理解新选项的系统进行互操作。</p>
<h2 id="24-5-时间戳选项"><a href="#24-5-时间戳选项" class="headerlink" title="24.5 时间戳选项"></a>24.5 时间戳选项</h2><p>时间戳选项使发送方在每个报文段中放置一个时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT。<br>较大的窗口需要进行更好的RTT计算。</p>
<p>如果接收方发送一个确认了两个报文段的ACK，那么哪一个收到的时间戳应当放回显应答字段中来发回去呢？<br>为了减少任一端所维持的状态数量，对于每个连接只保持一个时间戳的数值。</p>
<ol>
<li>如果ACK被接收方迟延，则作为回显值的时间戳值应该对应于最早被确认的报文段。</li>
<li>如果一个收到的报文段虽然在窗口范围内但同时又是失序，这就表明前面的报文段已经丢失。当那个丢失的报文段到达时，它的时间戳将被回显。</li>
</ol>
<p>尽管时间戳选项能够更好地计算RTT，它还为发送方提供了一种方法，以避免接收到旧的报文段，并认为它们是现在的数据的一部分。下一节将对此进行描述。</p>
<h2 id="24-6-PAWS：防止回绕的序号"><a href="#24-6-PAWS：防止回绕的序号" class="headerlink" title="24.6 PAWS：防止回绕的序号"></a>24.6 PAWS：防止回绕的序号</h2><p>接收方将时间戳视为序列号的一个32bit的扩展。比最近有效的时间戳要小的报文段会被PAWS算法丢弃。</p>
<h2 id="24-7-T-TCP：为事务用的TCP扩展"><a href="#24-7-T-TCP：为事务用的TCP扩展" class="headerlink" title="24.7 T/TCP：为事务用的TCP扩展"></a>24.7 T/TCP：为事务用的TCP扩展</h2><p>TCP提供的是一种虚电路方式的运输服务。<br>这种虚电路服务非常适合诸如远程注册和文件传输之类的应用。</p>
<p>事务服务符合以下特征</p>
<ol>
<li>避免连接建立和连接终止的开销</li>
<li>等待时间应当减少到 RTT + SPT</li>
<li>服务器应当能够检测出重复的请求</li>
</ol>
<p>如今一个应用程序设计人员面对的一种选择是使用TCP还是UDP。TCP提供了过多的事务特征，而UDP提供的则不够。通常应用程序使用UDP来构造（避免TCP连接的开销），而许多需要的特征（如动态超时和重传、拥塞避免等）被放置在应用层，一遍又一遍的重新设计和实现。</p>
<p>一个较好的解决办法是提供一个能够提供足够多的事务处理功能的运输层。称为T/TCP。</p>
<p>T/TCP的特征中吸引人的地方在于它对现有协议进行了最小的修改，同时又兼容了现有的实现。它还利用了TCP中现有的工程特征，而不是迫使应用进程来处理这些问题。</p>
<p>一个可作为替换的事务协议是通用报文事务协议VMTP。<br>VMTP是使用IP的一个完整的运输层。</p>
<h2 id="24-8-TCP的性能"><a href="#24-8-TCP的性能" class="headerlink" title="24.8 TCP的性能"></a>24.8 TCP的性能</h2><p>在10Mb/s的以太网上的理论上的最大吞吐量是1.18MB/s</p>
<p>实际限制：</p>
<ol>
<li>不能比最慢的链路运行得更快。</li>
<li>不能比最慢的及其的内存运行得更快。这假定实现是只使用一遍数据，如果不是这样，那么将运行地更慢。</li>
<li>不能比由接收方提供的窗口大小除以往返时间所得结果运行得更快。</li>
</ol>
<p>TCP的理论性能仅受最大的1千兆字节窗口和光速的限制。许多协议性能问题在于实现中的缺陷而不是协议所固有的一些限制。</p>
<h2 id="24-9-小结"><a href="#24-9-小结" class="headerlink" title="24.9 小结"></a>24.9 小结</h2><p>路径MTU发现在MTU较大时，对于非本地连接，允许TCP使用比默认的536大的窗口。</p>
<p>窗口扩大选项使最大的TCP窗口从65535增加到1千兆字节以上。<br>时间戳选项允许多个报文段被精确计时，并允许接收方提供序号回绕保护（PAWS）。</p>
<p>为事务用的TCP扩展允许一个请求-应答序列在通常的情况下只使用三个报文段来完成。它避免使用三次握手，并缩短了TIME_WAIT状态，其方法是为每个主机高速缓存少量的信息，这些信息曾用来建立过一个连接。它还在包含数据报文段中使用SYN和FIN标志。</p>
<p>除了在一个ICMP报文中为路径MTU发现增加了一个额外字段之外，这些新的选项只需要在那些需要使用它们的端系统中进行实现。</p>
<h1 id="ch25-SNMP：简单网络管理协议"><a href="#ch25-SNMP：简单网络管理协议" class="headerlink" title="ch25 SNMP：简单网络管理协议"></a>ch25 SNMP：简单网络管理协议</h1><h2 id="25-1-引言"><a href="#25-1-引言" class="headerlink" title="25.1 引言"></a>25.1 引言</h2><p>基于TCP/IP的网络管理包含两个部分：</p>
<ul>
<li>网络管理站（也叫管理进程，manager）</li>
<li>被管的网络单元（也叫被管设备），例如：路由器、X终端、终端服务器和打印机等</li>
</ul>
<p>被管设备端和管理相关的软件叫做代理程序或代理进程。<br>管理站一般都是带有彩色监视器的工作站，可以显示所有被管设备的状态。</p>
<p>管理进程和代理进程之间的通信</p>
<ul>
<li>询问和要求改变一个具体的参数值</li>
<li>报告有某些重要的事情发生</li>
</ul>
<p>基于TCP/IP的网络管理包含3个组成部分</p>
<ol>
<li>管理信息库MIB：包含所有代理进程的所有可被查询和修改的参数。</li>
<li>管理信息结构SMI：关于MIB的一套公用的结构和表示符号</li>
<li>简单网络管理协议SNMP：管理进程和代理进程之间的通信协议，用的最多的是UDP</li>
</ol>
<h2 id="25-2-协议"><a href="#25-2-协议" class="headerlink" title="25.2 协议"></a>25.2 协议</h2><p>关于交互信息，SNMP定义了5种报文</p>
<ol>
<li>get-request</li>
<li>get-next-request</li>
<li>set-request</li>
<li>get-response：代理进程返回一个或多个参数值</li>
<li>trap：代理进程主动通知管理进程有某些事情发生</li>
</ol>
<p>前3种操作采用UDP的161窗口，代理进程发出的Trap操作采用UDP的162端口。一个系统可以同时为管理进程和代理进程。</p>
<h2 id="25-3-管理信息结构"><a href="#25-3-管理信息结构" class="headerlink" title="25.3 管理信息结构"></a>25.3 管理信息结构</h2><p>本节讨论数据类型</p>
<h2 id="25-4-对象标识符"><a href="#25-4-对象标识符" class="headerlink" title="25.4 对象标识符"></a>25.4 对象标识符</h2><p>对象标识是一个整数序列，以点分隔。</p>
<p>所有的MIB变量都从1.3.6.1.2.1这个标识符开始。</p>
<p>树上的每个结点同时还有一个文字名，方便阅读</p>
<p>1.3.6.1.4.1是给厂家自定义而预留的</p>
<h2 id="25-5-管理信息库介绍"><a href="#25-5-管理信息库介绍" class="headerlink" title="25.5 管理信息库介绍"></a>25.5 管理信息库介绍</h2><p>MIB就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</p>
<h2 id="25-6-实例标识"><a href="#25-6-实例标识" class="headerlink" title="25.6 实例标识"></a>25.6 实例标识</h2><p>只有叶子节点是可操作的。SNMP没法处理表格的一整行或一整列</p>
<h3 id="25-6-1-简单变量"><a href="#25-6-1-简单变量" class="headerlink" title="25.6.1 简单变量"></a>25.6.1 简单变量</h3><p>在其对象标识后面添加<code>.0</code><br>例如1.3.6.1.2.1.7.1.0，通常可以缩写为udpInDatagrams.0</p>
<h3 id="25-6-2-表格"><a href="#25-6-2-表格" class="headerlink" title="25.6.2 表格"></a>25.6.2 表格</h3><p>对于UDP监听表来说，MIB定义了包含两个变量的联合索引：udpLocalAddress、udpLocalPort。</p>
<h3 id="25-6-3-字典式排序"><a href="#25-6-3-字典式排序" class="headerlink" title="25.6.3 字典式排序"></a>25.6.3 字典式排序</h3><p>是MIB按照对象标识进行排序的隐含规则。</p>
<h2 id="25-7-一些简单的例子"><a href="#25-7-一些简单的例子" class="headerlink" title="25.7 一些简单的例子"></a>25.7 一些简单的例子</h2><p><code>snmpi -a gateway -c secret</code><br>其中-a选项代表要和之通信的代理进程名称，-c选项标识SNMP的共同体名。<br>代理进程允许客户进程用只读共同体名对变量进行读操作，用读写共同体名对变量进行读和写操作。</p>
<h2 id="25-7-1-简单变量"><a href="#25-7-1-简单变量" class="headerlink" title="25.7.1 简单变量"></a>25.7.1 简单变量</h2><p><code>get udpInDatagrams.0 udpLocalPorts.0</code></p>
<h2 id="25-7-2-get-next操作"><a href="#25-7-2-get-next操作" class="headerlink" title="25.7.2 get-next操作"></a>25.7.2 get-next操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next udp</span><br><span class="line">next udpInDatagrams.0</span><br><span class="line">next udpNoPorts.0</span><br></pre></td></tr></table></figure>
<h3 id="25-7-3-表格的访问"><a href="#25-7-3-表格的访问" class="headerlink" title="25.7.3 表格的访问"></a>25.7.3 表格的访问</h3><p>udpTable不是叶子对象，但是get-next操作依然能够返回表格中的下一个对象。</p>
<p>当返回结果超出表格之外的下一个变量时，管理进程就可以发现变量的名称发生了较大的变化。</p>
<h2 id="25-8-管理信息库（续）"><a href="#25-8-管理信息库（续）" class="headerlink" title="25.8 管理信息库（续）"></a>25.8 管理信息库（续）</h2><p>本节介绍下列MIB组：system（系统标识）、if（接口）、at（地址转换）、ip、icmp和tcp。</p>
<h2 id="25-9-其他一些例子"><a href="#25-9-其他一些例子" class="headerlink" title="25.9 其他一些例子"></a>25.9 其他一些例子</h2><p>本节回答了11.6节和14.4节中没有回答的问题</p>
<h2 id="图25-30-trap的类型"><a href="#图25-30-trap的类型" class="headerlink" title="图25-30 trap的类型"></a>图25-30 trap的类型</h2><h2 id="25-11-ASN-1和BER"><a href="#25-11-ASN-1和BER" class="headerlink" title="25.11 ASN.1和BER"></a>25.11 ASN.1和BER</h2><p>SNMP采用ASN.1语法和BER编码</p>
<p>ASN.1和BER这两个繁琐的概念仅仅在实现SNMP的时候才重要</p>
<h2 id="25-12-SNMPv2"><a href="#25-12-SNMPv2" class="headerlink" title="25.12 SNMPv2"></a>25.12 SNMPv2</h2><p>第二版区别</p>
<ol>
<li>新的分组类型get-bulk-request，它高效率地从代理进程读取大块数据。</li>
<li>新的分组类型inform-request，它使一个进程可以向另一个进程发送信息。</li>
<li>定义了两个新的MIB</li>
<li>安全性大有提高，提供鉴别和加密</li>
</ol>
<h1 id="ch26-Telnet和Rlogin：远程登录"><a href="#ch26-Telnet和Rlogin：远程登录" class="headerlink" title="ch26 Telnet和Rlogin：远程登录"></a>ch26 Telnet和Rlogin：远程登录</h1><h2 id="26-1-引言"><a href="#26-1-引言" class="headerlink" title="26.1 引言"></a>26.1 引言</h2><p>我们可以先登录到一台主机然后再通过网络远程登录到任何其他一台网络主机上去。</p>
<ul>
<li>Telnet是标准的提供远程登录功能的应用</li>
<li>Rlogin比较简单，首先介绍</li>
</ul>
<h2 id="26-2-Rlogin协议"><a href="#26-2-Rlogin协议" class="headerlink" title="26.2 Rlogin协议"></a>26.2 Rlogin协议</h2><h3 id="26-2-1-应用进程的启动"><a href="#26-2-1-应用进程的启动" class="headerlink" title="26.2.1 应用进程的启动"></a>26.2.1 应用进程的启动</h3><p>用ZeroByte表示一个字节的0。当TCP连接建立完毕</p>
<ol>
<li>客户发送4个字符串：</li>
</ol>
<ul>
<li>ZeroByte</li>
<li>用户登录进客户进程主机的登录名，以ZeroByte结束</li>
<li>登录服务器进程端主机的登录名，以ZeroByte结束</li>
<li>用户终端类型名，紧跟一个<code>/</code>，然后是终端速率，以ZeroByte结束</li>
</ul>
<ol>
<li>服务器返回ZeroByte</li>
<li>服务器进程可以选择是否要求用户输入口令</li>
<li>服务器进程通常要给客户进程发送请求，询问终端的窗口大小</li>
</ol>
<h3 id="26-2-2-流量控制"><a href="#26-2-2-流量控制" class="headerlink" title="26.2.2 流量控制"></a>26.2.2 流量控制</h3><p>客户进程能够识别用户键入的Control_S和Control_Q，并且终止或启动终端的输出。</p>
<p>emacs把Control_S和Control_Q作为自己的命令。解决这个问题的办法就是由服务器告诉客户是否要进行流量控制。</p>
<h3 id="26-2-3-客户的中断键"><a href="#26-2-3-客户的中断键" class="headerlink" title="26.2.3 客户的中断键"></a>26.2.3 客户的中断键</h3><p>当我们为中断服务器正在运行的进程而键入一个中断字符时，会发生和流量控制相同的问题。</p>
<p>从客户输出到服务器的特殊输入字符不需要采用TCP的紧急方式。</p>
<h3 id="26-2-4-窗口大小的改变"><a href="#26-2-4-窗口大小的改变" class="headerlink" title="26.2.4 窗口大小的改变"></a>26.2.4 窗口大小的改变</h3><p>Rlogin的客户需要采用某些方法来通知服务器窗口大小变化的情况以及新窗口的大小。</p>
<h3 id="26-2-5-服务器到客户的命令"><a href="#26-2-5-服务器到客户的命令" class="headerlink" title="26.2.5 服务器到客户的命令"></a>26.2.5 服务器到客户的命令</h3><p>当服务器要给客户发送命令时，服务器就进入紧急方式，并且把命令放在紧急数据的最后一个字节中。</p>
<p>采用TCP紧急方式发送这些命令的一个原因是“清仓输出”命令需要立即发送给客户，即使服务器到客户的数据流被窗口流量控制所终止。其他的3个命令实时性并不特别强，但为了简单起见，也采用了和“清仓输出”相同的技术。</p>
<ul>
<li>服务器到客户的输出被流量控制所终止的情况是经常发生的，这是因为运行在服务器的进程的输出速率通常大于客户终端的显示速率。</li>
<li>客户到服务器的数据流很少被流量控制所终止，因为这个方向的数据流仅仅包含用户所键入的字符。</li>
</ul>
<h3 id="26-2-6-客户到服务器的命令"><a href="#26-2-6-客户到服务器的命令" class="headerlink" title="26.2.6 客户到服务器的命令"></a>26.2.6 客户到服务器的命令</h3><p>客户可以发送窗口大小命令将当前窗口大小发送给服务器</p>
<p>发送方法是在两个字节的0xff后面紧跟着两个<code>s</code>，之后是4个16bit长的数据，分别是：行数，每列的字符数，X方向的像素数量，Y方向的像素数量。通常情况下，后两个16bit是0。</p>
<ul>
<li>带内信令：命令字节和其他的普通数据一起传输</li>
<li>带外信令：客户进程不需要检查收到的每个字节。即使在紧急方式下，客户进程也仅仅需要留意紧急指针所指向的字节。</li>
</ul>
<p>由于从客户到服务器的数据流量和相反方向的数据流量之比为1:20，这就暗示带内信令适合数据量小的情况，而带外信令适合数据量比较大的情况。</p>
<h3 id="26-2-7-客户的转义符"><a href="#26-2-7-客户的转义符" class="headerlink" title="26.2.7 客户的转义符"></a>26.2.7 客户的转义符</h3><p>和Rlogin<strong>客户</strong>进程直接通信的方法是在一行的开头键入<code>~</code>，紧跟着是下列4个字符之一</p>
<ul>
<li>以句号结束客户进程</li>
<li>以Control_D结束客户进程</li>
<li>以Control_Z挂起客户进程</li>
<li>以Control_Y来挂起仅仅是客户进程的输入。适合运行长时间程序。</li>
</ul>
<h2 id="26-3-Rlogin的例子"><a href="#26-3-Rlogin的例子" class="headerlink" title="26.3 Rlogin的例子"></a>26.3 Rlogin的例子</h2><h2 id="26-4-Telnet协议"><a href="#26-4-Telnet协议" class="headerlink" title="26.4 Telnet协议"></a>26.4 Telnet协议</h2><p>NVT是带有键盘和打印机的字符设备</p>
<h3 id="26-4-1-NVT-ASCII"><a href="#26-4-1-NVT-ASCII" class="headerlink" title="26.4.1 NVT ASCII"></a>26.4.1 NVT ASCII</h3><p>术语NVT ASCII代表7比特的ASCII字符集，在字节中最高位比特为0。</p>
<p>行结束符以\r\n来表示，而\r\0则被认为是回车命令</p>
<p>网间网协议族都使用NVT ASCII，例如FTP,SMTP,Finger和Whois。</p>
<h3 id="26-4-2-Telnet命令"><a href="#26-4-2-Telnet命令" class="headerlink" title="26.4.2 Telnet命令"></a>26.4.2 Telnet命令</h3><p>Telnet通信的两个方向都采用带内信令方式。字节0xff叫做IAC，该字节后面的一个字节才是命令字节。</p>
<h3 id="26-4-3-选项协商"><a href="#26-4-3-选项协商" class="headerlink" title="26.4.3 选项协商"></a>26.4.3 选项协商</h3><p>虽然我们可以认为Telnet连接的双方都是NVT，但是实际上Telnet连接双方首先进行交互的信息是选项协商数据。</p>
<p>对于任何给定的选项，连接的任何一方都可以发送下面4中请求</p>
<ol>
<li>WILL</li>
<li>DO</li>
<li>WONT</li>
<li>DON’T</li>
</ol>
<p>Telnet规定，对于激活选项请求（如1和2），有权同意或者不同意；而对于使选项失效请求（如3和4），必须同意。</p>
<p>选项协商需要3个字节：一个IAC字节，接着一个字节是上述4个请求之一，最后一个ID字节指明激活或禁止选项。</p>
<h3 id="26-4-4-子选项协商"><a href="#26-4-4-子选项协商" class="headerlink" title="26.4.4 子选项协商"></a>26.4.4 子选项协商</h3><p>SB是子选项协商的起始命令标志</p>
<h3 id="26-4-5-半双工、一次一字符、一次一行或行方式"><a href="#26-4-5-半双工、一次一字符、一次一行或行方式" class="headerlink" title="26.4.5 半双工、一次一字符、一次一行或行方式"></a>26.4.5 半双工、一次一字符、一次一行或行方式</h3><h3 id="26-4-6-同步信号"><a href="#26-4-6-同步信号" class="headerlink" title="26.4.6 同步信号"></a>26.4.6 同步信号</h3><p>以DM作为同步信号，该同步信号是以TCP紧急数据形式发送的。</p>
<h3 id="26-4-7-客户的转义符"><a href="#26-4-7-客户的转义符" class="headerlink" title="26.4.7 客户的转义符"></a>26.4.7 客户的转义符</h3><p>Control_]</p>
<h2 id="26-5-Telnet举例"><a href="#26-5-Telnet举例" class="headerlink" title="26.5 Telnet举例"></a>26.5 Telnet举例</h2><p>Telnet有3种数据传输方式。现在的趋势是只要有可能，就尽量工作在准行方式下</p>
<p>Rlogin和Telnet的服务器通常都将设置TCP的保活选项以检测客户主机是否崩溃</p>
<h1 id="ch27-FTP：文件传送协议"><a href="#ch27-FTP：文件传送协议" class="headerlink" title="ch27 FTP：文件传送协议"></a>ch27 FTP：文件传送协议</h1><h2 id="27-1-引言"><a href="#27-1-引言" class="headerlink" title="27.1 引言"></a>27.1 引言</h2><ul>
<li><p>文件传送：FTP提供，将一个完整的文件从一个系统复制到另一个系统中</p>
</li>
<li><p>文件存取：NFS提供</p>
</li>
<li><p>Telnet获得异构性是强制两端采用NVT</p>
</li>
<li><p>FTP支持有限数量的文件类型和文件结构</p>
</li>
</ul>
<h2 id="27-2-FTP协议"><a href="#27-2-FTP协议" class="headerlink" title="27.2 FTP协议"></a>27.2 FTP协议</h2><ul>
<li>IP对控制连接的服务类型：最大限度地减小迟延</li>
<li>IP对数据连接的服务特点：最大限度提高吞吐量</li>
</ul>
<h3 id="27-2-1-数据表示"><a href="#27-2-1-数据表示" class="headerlink" title="27.2.1 数据表示"></a>27.2.1 数据表示</h3><p>FTP提供了控制文件传送与存储的四个方面的选择</p>
<ol>
<li>文件类型</li>
</ol>
<ul>
<li>ASCII码文件类型</li>
<li>EBCDIC文件类型</li>
<li>图像文件类型</li>
<li>本地文件类型</li>
</ul>
<ol>
<li>格式控制（只对ASCII和EBCDIC文件类型有效）</li>
</ol>
<ul>
<li>非打印</li>
<li>远程登录格式控制</li>
<li>Fortran回车控制</li>
</ul>
<ol>
<li>结构</li>
</ol>
<ul>
<li>文件结构</li>
<li>记录结构</li>
<li>页结构</li>
</ul>
<ol>
<li>传输方式</li>
</ol>
<ul>
<li>流方式</li>
<li>块方式</li>
<li>压缩方式</li>
</ul>
<p>通常由Unix实现的FTP客户和服务器把我们的选择限制如下</p>
<ul>
<li>类型：ASCII或图像</li>
<li>格式控制：只允许非打印</li>
<li>结构：只允许文件结构</li>
<li>传输方式：只允许流方式</li>
</ul>
<h3 id="27-2-2-FTP命令"><a href="#27-2-2-FTP命令" class="headerlink" title="27.2.2 FTP命令"></a>27.2.2 FTP命令</h3><h3 id="27-2-3-FTP应答"><a href="#27-2-3-FTP应答" class="headerlink" title="27.2.3 FTP应答"></a>27.2.3 FTP应答</h3><p>典型应答</p>
<ul>
<li>125 数据连接已打开；传输开始</li>
<li>200 就绪命令</li>
<li>214 帮助报文（面向用户）</li>
<li>331 用户名就绪，要求输入口令</li>
<li>425 不能打开数据连接</li>
<li>452 错写文件</li>
<li>500 语法错误（未认可的命令）</li>
<li>501 语法错误（无效参数）</li>
<li>502 未实现的MODE（方式命令）类型</li>
</ul>
<h3 id="27-2-4-连接管理"><a href="#27-2-4-连接管理" class="headerlink" title="27.2.4 连接管理"></a>27.2.4 连接管理</h3><p>传输的一般过程</p>
<ul>
<li>客户主动打开连接到服务器的21端口</li>
<li>客户通常在客户端主机上选择临时端口号，客户从该端口发布一个被动的打开</li>
<li>客户使用PORT命令从控制连接上把端口号发向服务器</li>
<li>服务器接收口号，并向客户端主机上的端口发布一个主动的打开。服务器的数据连接端一直使用端口20</li>
</ul>
<h2 id="27-3-FTP的例子"><a href="#27-3-FTP的例子" class="headerlink" title="27.3 FTP的例子"></a>27.3 FTP的例子</h2><p>跳过</p>
<h1 id="ch28-SMTP：简单邮件传送协议"><a href="#ch28-SMTP：简单邮件传送协议" class="headerlink" title="ch28 SMTP：简单邮件传送协议"></a>ch28 SMTP：简单邮件传送协议</h1><h2 id="28-1-引言"><a href="#28-1-引言" class="headerlink" title="28.1 引言"></a>28.1 引言</h2><p>本章研究在两个MTA之间如何用TCP交换邮件</p>
<h2 id="28-2-SMTP协议"><a href="#28-2-SMTP协议" class="headerlink" title="28.2 SMTP协议"></a>28.2 SMTP协议</h2><h3 id="28-2-1-简单例子"><a href="#28-2-1-简单例子" class="headerlink" title="28.2.1 简单例子"></a>28.2.1 简单例子</h3><p>只有5个SMTP命令用于发送邮件：HELO，MAIL，RCTP，DATA和QUIT</p>
<p>客户主动打开TCP端口25。返回时，客户等待从服务器来的问候报文（应答代码为220）</p>
<h3 id="28-2-2-SMTP命令"><a href="#28-2-2-SMTP命令" class="headerlink" title="28.2.2 SMTP命令"></a>28.2.2 SMTP命令</h3><p>最小SMTP实现支持8中命令，除了前面的例子中的5个，还有附加和可选命令</p>
<ul>
<li>RSET命令异常终止当前的邮件事务并使两端复位。</li>
<li>VRFY命令使客户能够询问发送方以验证接收方地址</li>
<li>NOOP命令仅强迫服务器响应一个OK应答码</li>
</ul>
<h3 id="28-2-3-信封、首部和正文"><a href="#28-2-3-信封、首部和正文" class="headerlink" title="28.2.3 信封、首部和正文"></a>28.2.3 信封、首部和正文</h3><p>电子邮件由三部分组成</p>
<ol>
<li>信封由两个SMTP命令指明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAIL From: &lt;rstevens@sun.tuc.noao.edu&gt;</span><br><span class="line">RCPT To: &lt;estevens@noao.edu&gt;</span><br></pre></td></tr></table></figure></li>
<li>首部由用户代理使用</li>
<li>正文是发送用户发给接收用户报文的内容。当用DATA命令发送时，先发送首部，紧跟一个空行，然后是正文。</li>
</ol>
<h3 id="28-2-4-中继代理"><a href="#28-2-4-中继代理" class="headerlink" title="28.2.4 中继代理"></a>28.2.4 中继代理</h3><p>本地MTA的信息输出中的 Connectiing to mailhost via ether 表示系统已被配置成把所有非本地的向外的邮件发送到一台中继机上进行转发</p>
<h3 id="28-2-5-扩充多媒体邮件只需对用户代理作一些改变"><a href="#28-2-5-扩充多媒体邮件只需对用户代理作一些改变" class="headerlink" title="28.2.5 扩充多媒体邮件只需对用户代理作一些改变"></a>28.2.5 扩充多媒体邮件只需对用户代理作一些改变</h3><h3 id="28-2-6-重试间隔"><a href="#28-2-6-重试间隔" class="headerlink" title="28.2.6 重试间隔"></a>28.2.6 重试间隔</h3><p>推荐初始时间间隔至少为30分钟。发送方至少4~5天内不能放弃</p>
<h2 id="28-3-SMTP的例子"><a href="#28-3-SMTP的例子" class="headerlink" title="28.3 SMTP的例子"></a>28.3 SMTP的例子</h2><h2 id="28-4-SMTP的未来"><a href="#28-4-SMTP的未来" class="headerlink" title="28.4 SMTP的未来"></a>28.4 SMTP的未来</h2><p>新加入的SMTP命令影响了信封，首部中可以使用非ASCII字母，正文（MINE）中也加入了结构。</p>
<h3 id="28-4-1-信封的变化：扩充的SMTP"><a href="#28-4-1-信封的变化：扩充的SMTP" class="headerlink" title="28.4.1 信封的变化：扩充的SMTP"></a>28.4.1 信封的变化：扩充的SMTP</h3><p>这些变化以向后兼容的方式被加入，所以不影响已有的实现</p>
<p>如果客户想使用新的特性，首先通过发布一个EHLO而不是HELO命令启动一个服务器的回话。相兼容的服务器用250应答码响应。</p>
<ul>
<li>250-SIZE让客户在MAIL FROM命令行中以字节的多少指定报文的大小。</li>
<li>250-8BITMIME允许客户把关键字BODY加到MAIL FROM命令中，指定正文中是否包含NVT ASCII字符（默认的）或8 bit数据</li>
<li>250-XADR等等。任何以X开头的关键字都指的是本地SMTP扩充</li>
</ul>
<h3 id="28-4-2-首部变化：非ASCII字符"><a href="#28-4-2-首部变化：非ASCII字符" class="headerlink" title="28.4.2 首部变化：非ASCII字符"></a>28.4.2 首部变化：非ASCII字符</h3><p>首部字段中可以包含编码字，格式：<code>=?charset?encoding?encoded-text?=</code></p>
<h3 id="28-4-3-正文变化：通用Internet邮件扩充"><a href="#28-4-3-正文变化：通用Internet邮件扩充" class="headerlink" title="28.4.3 正文变化：通用Internet邮件扩充"></a>28.4.3 正文变化：通用Internet邮件扩充</h3><p>MINE定义5个标题字段、7个内容类型5种不同的编码格式</p>
<p>尽管内容类型和编码是独立的，RFC1521推荐有非ASCII数据的text使用quoted-printable，其他使用base64。</p>
<h1 id="ch29-网络文件系统"><a href="#ch29-网络文件系统" class="headerlink" title="ch29 网络文件系统"></a>ch29 网络文件系统</h1><h2 id="29-1-引言"><a href="#29-1-引言" class="headerlink" title="29.1 引言"></a>29.1 引言</h2><p>NFS的基础是Sun RPC：远程过程调用。</p>
<h2 id="29-2-Sun远程过程调用"><a href="#29-2-Sun远程过程调用" class="headerlink" title="29.2 Sun远程过程调用"></a>29.2 Sun远程过程调用</h2><p>一般来说，客户发送命令给服务器，服务器向客户发送应答。目前为止，我们讨论过的所有应用程序都是采用这种方式实现的。</p>
<p>远程过程调用RPC是一种不同的网络程序设计方法。调用服务器提供的函数时发生了下面一些动作</p>
<ul>
<li>它实际上只是调用了一个位于本机上的、由RPC程序包生成的函数。这个函数被称为客户残桩（stub）。客户残桩将过程的参数封装成一个网络报文，并且将这个报文发送给服务器程序。</li>
<li>服务器残桩接收报文，从中提取参数，然后调用服务器过程</li>
<li>当服务器函数返回时，它返回到服务器残桩。封装成网络报文然后发送给客户残桩</li>
<li>客户残桩从报文中取出返回值，将其返回给客户程序</li>
</ul>
<p>图29-1显示的是使用UDP时，一个RPC过程调用报文的格式。</p>
<p>图29-2显示了一个RPC应答报文的格式</p>
<h2 id="29-3-XDR：外部数据表示"><a href="#29-3-XDR：外部数据表示" class="headerlink" title="29.3 XDR：外部数据表示"></a>29.3 XDR：外部数据表示</h2><p>外部数据表示用来对RPC调用报文和应答报文中的值进行编码</p>
<h2 id="29-4-端口映射器"><a href="#29-4-端口映射器" class="headerlink" title="29.4 端口映射器"></a>29.4 端口映射器</h2><p>RPC服务器不使用指明窗口，需要注册程序来跟踪RPC程序使用了哪一个临时端口。这个注册程序被称为端口映射器。</p>
<p>端口映射器本身必须有一个知名端口：111。端口映射器提供四个服务过程</p>
<ul>
<li>PMAPPROC_SET</li>
<li>PMAPPROC_UNSET</li>
<li>PMAPPROC_GETPORT</li>
<li>PMAPPROC_DUMP</li>
</ul>
<p>从RPC服务器程序启动到被调用的过程：</p>
<ul>
<li>系统引导时，端口映射器启动。它创建TCP和UDP端点</li>
<li>当RPC服务器应用程序启动时，它为它所支持的程序的每一个版本创建TCP和UDP端点。两个端点各自绑定一个临时端口。服务器通过PMAPPROC_SET过程注册每一个程序、版本、协议和端口号。</li>
<li>当RPC应用程序启动时，它调用端口映射器的PMAPPROC_GETPORT过程来获得一个指定程序、版本和协议的临时端口号。</li>
<li>客户发送一个RPC调用报文给第3步返回的端口号。</li>
</ul>
<h2 id="29-5-NFS协议"><a href="#29-5-NFS协议" class="headerlink" title="29.5 NFS协议"></a>29.5 NFS协议</h2><p>FTP会产生文件一个完整的副本；NFS只访问一个进程引用文件的那一部分。<br>任何能够访问一个本地文件的客户程序不需要做任何修改，就应该能够访问一个NFS文件。</p>
<p>NFS是一个使用Sun RPC构造的客户服务器应用程序。尽管这一工作可以使用一般的用户进程来实现，但是在内核与用户进程之间进行切换的代价太大。</p>
<p>大多数的NFS服务器都是多线程的。既然大多数的Unix内核不是多线程的，一个共同的技术就是启动一个用户进程（常被称为nfsd）的多个实例。这个实例执行一个系统调用，使自己作为一个内核进程保留在操作系统的内核中。</p>
<h3 id="29-5-1-文件句柄"><a href="#29-5-1-文件句柄" class="headerlink" title="29.5.1 文件句柄"></a>29.5.1 文件句柄</h3><p>文件句柄的内容只对服务器有意义</p>
<h3 id="29-5-2-安装协议"><a href="#29-5-2-安装协议" class="headerlink" title="29.5.2 安装协议"></a>29.5.2 安装协议</h3><p>客户必须在访问服务器上一个文件系统中的文件之前，使用安装协议安装那个文件系统。</p>
<h3 id="29-5-3-NFS过程"><a href="#29-5-3-NFS过程" class="headerlink" title="29.5.3 NFS过程"></a>29.5.3 NFS过程</h3><p>NFS服务器提供15个过程</p>
<h3 id="29-5-4-UDP还是TCP"><a href="#29-5-4-UDP还是TCP" class="headerlink" title="29.5.4 UDP还是TCP"></a>29.5.4 UDP还是TCP</h3><p>NFS最初是用UDP写的，TCP支持主要用于广域网</p>
<h3 id="29-5-5-TCP上的NFS"><a href="#29-5-5-TCP上的NFS" class="headerlink" title="29.5.5 TCP上的NFS"></a>29.5.5 TCP上的NFS</h3><h2 id="29-6-NFS实例"><a href="#29-6-NFS实例" class="headerlink" title="29.6 NFS实例"></a>29.6 NFS实例</h2><h3 id="29-6-3-无状态"><a href="#29-6-3-无状态" class="headerlink" title="29.6.3 无状态"></a>29.6.3 无状态</h3><p>服务器并不记录哪个客户正在访问哪个文件，没有open和close操作。</p>
<p>无状态设计的理由是为了在服务器崩溃并且重启动时，简化服务器的崩溃恢复操作。</p>
<h3 id="29-6-5-等幂过程"><a href="#29-6-5-等幂过程" class="headerlink" title="29.6.5 等幂过程"></a>29.6.5 等幂过程</h3><p>客户维护着状态（每个文件当前的偏移位置），而不是服务器</p>
<p>并非所有的文件操作都是等幂的</p>
<p>NFS服务器需要一种方法来处理非等幂的操作。大多数的服务器实现了一个最近应答的高速缓存，用于存放非等幂操作最近的应答。收到同样的请求就返回以前的应答而不再调用相应的NFS过程。</p>
<p>等幂服务器过程的概念可以应用于任何基于UDP的应用程序</p>
<h2 id="29-7-第3版的NFS"><a href="#29-7-第3版的NFS" class="headerlink" title="29.7 第3版的NFS"></a>29.7 第3版的NFS</h2><h1 id="ch30-其他的TCP-IP应用程序"><a href="#ch30-其他的TCP-IP应用程序" class="headerlink" title="ch30 其他的TCP/IP应用程序"></a>ch30 其他的TCP/IP应用程序</h1><h2 id="30-1-引言"><a href="#30-1-引言" class="headerlink" title="30.1 引言"></a>30.1 引言</h2><p>我们提供一些Internet上资源发现工具的概述。</p>
<h2 id="30-2-Finger协议"><a href="#30-2-Finger协议" class="headerlink" title="30.2 Finger协议"></a>30.2 Finger协议</h2><p>Finger协议返回一个指定主机上一个或多个用户的信息。</p>
<h2 id="30-3-Whois协议"><a href="#30-3-Whois协议" class="headerlink" title="30.3 Whois协议"></a>30.3 Whois协议</h2><p>Whois协议是另一种信息服务。维护者所有的DNS域和很多连接在Internet上的系统的系统管理员的信息</p>
<h4 id="白页"><a href="#白页" class="headerlink" title="白页"></a>白页</h4><h2 id="30-4-Archie、WAIS、Gopher、Veronica和WWW"><a href="#30-4-Archie、WAIS、Gopher、Veronica和WWW" class="headerlink" title="30.4 Archie、WAIS、Gopher、Veronica和WWW"></a>30.4 Archie、WAIS、Gopher、Veronica和WWW</h2><p>Finger、Whois和白页服务使用来查找人的信息的。还有一些工具是用来定位文件和文档的。</p>
<h3 id="Archie用于从几千个FTP中搜索那些名字中包含了一个指定的常规表达式的文件"><a href="#Archie用于从几千个FTP中搜索那些名字中包含了一个指定的常规表达式的文件" class="headerlink" title="Archie用于从几千个FTP中搜索那些名字中包含了一个指定的常规表达式的文件"></a>Archie用于从几千个FTP中搜索那些<strong>名字中</strong>包含了一个指定的常规表达式的文件</h3><h3 id="WAIS帮助我们查找一个内容中包含一个关键字的文件或数据库"><a href="#WAIS帮助我们查找一个内容中包含一个关键字的文件或数据库" class="headerlink" title="WAIS帮助我们查找一个内容中包含一个关键字的文件或数据库"></a>WAIS帮助我们查找一个<strong>内容中</strong>包含一个关键字的文件或数据库</h3><h3 id="Gopher是其他Internet资源服务的一个菜单驱动的前端程序"><a href="#Gopher是其他Internet资源服务的一个菜单驱动的前端程序" class="headerlink" title="Gopher是其他Internet资源服务的一个菜单驱动的前端程序"></a>Gopher是其他Internet资源服务的一个菜单驱动的前端程序</h3><h3 id="Veronica是一个Gopher标题的索引"><a href="#Veronica是一个Gopher标题的索引" class="headerlink" title="Veronica是一个Gopher标题的索引"></a>Veronica是一个Gopher标题的索引</h3><h3 id="万维网使得我们可以浏览一个大的-全球范围的服务和文档。"><a href="#万维网使得我们可以浏览一个大的-全球范围的服务和文档。" class="headerlink" title="万维网使得我们可以浏览一个大的/全球范围的服务和文档。"></a>万维网使得我们可以浏览一个大的/全球范围的服务和文档。</h3><h2 id="30-5-X窗口系统"><a href="#30-5-X窗口系统" class="headerlink" title="30.5 X窗口系统"></a>30.5 X窗口系统</h2><p>X窗口系统可以使得多个客户（应用）使用由一个服务器管理的位映射显示器</p>
<h1 id="附录A-tcpdump程序"><a href="#附录A-tcpdump程序" class="headerlink" title="附录A tcpdump程序"></a>附录A tcpdump程序</h1><p>tcpdump通过将网络接口卡设置为混杂模式来截获经过网络接口的每一个分组。<br>本书中使用的是2.2.1版。</p>
<p>程序snoop和iptrace也提供了类似的功能。</p>
<h2 id="A-1-BSD分组过滤器"><a href="#A-1-BSD分组过滤器" class="headerlink" title="A.1 BSD分组过滤器"></a>A.1 BSD分组过滤器</h2><h2 id="A-2-SunOS的网络接口分接头"><a href="#A-2-SunOS的网络接口分接头" class="headerlink" title="A.2 SunOS的网络接口分接头"></a>A.2 SunOS的网络接口分接头</h2><h2 id="A-3-SVR4数据链路提供者接口"><a href="#A-3-SVR4数据链路提供者接口" class="headerlink" title="A.3 SVR4数据链路提供者接口"></a>A.3 SVR4数据链路提供者接口</h2><h2 id="A-4-tcpdump的输出"><a href="#A-4-tcpdump的输出" class="headerlink" title="A.4 tcpdump的输出"></a>A.4 tcpdump的输出</h2><p>本书对tcpdump的原始输出进行了修改以便阅读</p>
<ol>
<li>删去了网络接口名字</li>
<li>把时间戳的HH:MM:SS格式改为：与开始监听的相对时间以及与下面分组的时间差</li>
<li>经常把<code>发送主机名字 &gt; 目的主机名字</code>画成时间线</li>
<li>在太长行的适当地方进行了换行</li>
<li>没有显示中断键</li>
<li>没有显示接收到的和漏掉的分组的个数（漏掉的分组是那些到达得太快，tcpdump来不及处理的分组。因为本文中的例子经常运行在另外一个空闲的网络上，所以漏掉的分组个数总是0）</li>
</ol>
<h2 id="A-5-安全性考虑"><a href="#A-5-安全性考虑" class="headerlink" title="A.5 安全性考虑"></a>A.5 安全性考虑</h2><p>截获网络数据流使我们可以看到Telnet和FTP口令的明文表示。<br>然而，很多时候一个网络管理员需要使用一个类似于tcpdump的工具来分析网络中出现的问题。</p>
<p>对tcpdump等等工具的访问权限依赖于具体系统。<br>一般来说，只有超级用户才能读写这些设备。对于系统管理组用户是可读的。</p>
<h2 id="A-6-插口排错选项"><a href="#A-6-插口排错选项" class="headerlink" title="A.6 插口排错选项"></a>A.6 插口排错选项</h2><p>查看一个TCP连接上发生的事情的另一种方法是使能插口排错选项。</p>
<p><a href="#%E9%99%84%E5%BD%95C-sock%E7%A8%8B%E5%BA%8F">sock程序</a>的-D选项支持这个特征，但是输出的信息难解析和理解</p>
<h1 id="附录B-计算机时钟"><a href="#附录B-计算机时钟" class="headerlink" title="附录B 计算机时钟"></a>附录B 计算机时钟</h1><p>大多数Unix系统所采用的记录时间的方法。<br>硬件按照一定的频率产生一个时钟中断。</p>
<p>一个0.01%的误差就会产生一个每天8.64秒的差错。</p>
<p>如果内核丢失了一个中断，时钟将失去10ms。</p>
<p>tcpdump可以通过NIT驱动程序调用gettimeofday访问微秒级定时器。</p>
<h1 id="附录C-sock程序"><a href="#附录C-sock程序" class="headerlink" title="附录C sock程序"></a>附录C sock程序</h1><p>sock程序运行在以下四种模式之一</p>
<ul>
<li>交互式客户，默认模式，例如<code>sock bsdi echo</code></li>
<li>交互式服务器，例如<code>sock -s [本地接口IP地址] 端口号</code></li>
<li>源客户：指明-i选项。在默认情况下，将一个1024字节的缓存写到网络中，写1024次。-n和-w选项可以改变默认值。</li>
<li>接收器服务器：指明-i和-s选项。从网络中读数据然后扔掉。<br>这些例子都使用了TCP，-u选项指明使用udp</li>
</ul>
<p>sock的其它选项一览表 CF：原书P379</p>
<h1 id="附录D-部分习题的解答"><a href="#附录D-部分习题的解答" class="headerlink" title="附录D 部分习题的解答"></a>附录D 部分习题的解答</h1><h1 id="附录E-配置选项"><a href="#附录E-配置选项" class="headerlink" title="附录E 配置选项"></a>附录E 配置选项</h1><p>共6节，每节对应一个操作系统</p>
<h1 id="附录F-可以免费获得的源代码"><a href="#附录F-可以免费获得的源代码" class="headerlink" title="附录F 可以免费获得的源代码"></a>附录F 可以免费获得的源代码</h1><p>公开资料一览表 CF：原书P406</p>
<p>作者编写的软件在主机 ftp.uu.net 的文件 published/books/stevens.tcpipiv1.tar.z 中提供</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><h1 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/09/tcp-ip-xiang-jie/" data-id="cl310rf45001ggctkd73fgf1d" data-title="《TCP/IP详解》读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/07/06/unix-bian-cheng-yi-shu/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          《UNIX编程艺术》读书笔记
        
      </div>
    </a>
  
  
    <a href="/2021/05/05/web-scraping-with-python/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">《python网络爬虫权威指南》读书笔记</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bao-xian/">bao-xian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-note/">book-note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/health/">health</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/humor/">humor</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jekyll-update/">jekyll update</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1021/04/">April 1021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/23/2022-06-23-gpg/">《gpg》读书笔记</a>
          </li>
        
          <li>
            <a href="/2022/06/14/2022-06-14-jing-tong-git/">《精通git》读书笔记</a>
          </li>
        
          <li>
            <a href="/2022/05/15/ffmpeg/">《ffmpeg从入门到精通》读书笔记</a>
          </li>
        
          <li>
            <a href="/2021/08/10/high-availability-linux/">《构建高可用Linux服务器》读书笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/21/mysql-ji-shu-nei-mu/">《mysql技术内幕》读书笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>