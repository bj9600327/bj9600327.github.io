<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-high-availability-linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/10/high-availability-linux/" class="article-date">
  <time class="dt-published" datetime="2021-08-10T00:36:43.000Z" itemprop="datePublished">2021-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/10/high-availability-linux/">《构建高可用Linux服务器》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="如何阅读本书"><a href="#如何阅读本书" class="headerlink" title="如何阅读本书"></a>如何阅读本书</h1><ol>
<li>经验不足的读者：先了解第1章</li>
<li>系统管理员和系统工程师：重点关注第3～6章</li>
<li>网络管理员：先学习第1～3章，然后将重点放在第7章和第8章上</li>
<li>项目实施工程师：顺序阅读全书内容，重心可以放在第4章和第5章上。</li>
<li>开发人员：重点放在第1章和第3章上</li>
</ol>
<h1 id="ch01-Linux服务器的构建与优化"><a href="#ch01-Linux服务器的构建与优化" class="headerlink" title="ch01 Linux服务器的构建与优化"></a>ch01 Linux服务器的构建与优化</h1><h2 id="1-1-无人值守安装CentOS"><a href="#1-1-无人值守安装CentOS" class="headerlink" title="1.1 无人值守安装CentOS"></a>1.1 无人值守安装CentOS</h2><p>跳过</p>
<h2 id="1-2-全面了解Linux服务器"><a href="#1-2-全面了解Linux服务器" class="headerlink" title="1.2 全面了解Linux服务器"></a>1.2 全面了解Linux服务器</h2><p>客户往往不能提供详细的硬件配置清单</p>
<h3 id="1-2-1-CPU"><a href="#1-2-1-CPU" class="headerlink" title="1.2.1 CPU"></a>1.2.1 CPU</h3><ol>
<li><code>cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq</code>显示物理CPU</li>
<li><code>cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq</code>显示每个物理CPU中core的个数（即核数）</li>
<li><code>cat /proc/cpuinfo | grep &quot;processor&quot;</code>显示逻辑CPU</li>
</ol>
<h3 id="1-2-2-内存"><a href="#1-2-2-内存" class="headerlink" title="1.2.2 内存"></a>1.2.2 内存</h3><p><code>free -m</code>如果常常看到swap用了很多，你可能就要考虑增加物理内存了</p>
<h3 id="1-2-3-硬盘"><a href="#1-2-3-硬盘" class="headerlink" title="1.2.3 硬盘"></a>1.2.3 硬盘</h3><ol>
<li><code>fdish -l</code>查看硬盘及分区信息</li>
<li><code>df -h</code>查看文件系统的磁盘空间占用情况</li>
<li><code>iostat -d -x -k 1 10</code>查看硬盘的I/O性能</li>
</ol>
<ul>
<li>如果%util接近100%，则说明产生的I/O请求太多，该磁盘可能存在瓶颈</li>
<li>如果await大于5ms就表示磁盘I/O压力很大，这时可以考虑：<ul>
<li>更换响应速度更快的磁盘</li>
<li>调整内核elevator的算法</li>
<li>优化应用</li>
<li>升级CPU</li>
</ul>
</li>
</ul>
<ol start="4">
<li><code>du -sh 目录名</code>查看某目录的大小。分区空间不足时使用组合拳<ul>
<li><code>du -cks * | sort -rn | head -n 10</code></li>
</ul>
</li>
<li>dd命令可以在复制过程中进行格式转换，例如</li>
</ol>
<ul>
<li><code>dd if=/dev/zero of=/swapfile bs=1024 count=65536</code>制作交换文件</li>
<li><code>dd if=rhe140.img of=/dev/fd0 bs=10k</code>把驱动文件复制到软驱</li>
<li><code>dd if=/dev/cdrom of=/root/cd1.iso</code>制作ISO镜像</li>
</ul>
<h3 id="1-2-4-平均负载"><a href="#1-2-4-平均负载" class="headerlink" title="1.2.4 平均负载"></a>1.2.4 平均负载</h3><ol>
<li>uptime命令查看平均负载</li>
<li>w命令还可以查看当前有哪些用户，他们占用了哪些终端</li>
<li>top命令会动态地显示负载情况</li>
</ol>
<ul>
<li>如果load average的输出值大于逻辑CPU的个数，就要结合vmstat命令来判断系统是否国语繁忙</li>
</ul>
<h3 id="1-2-5-其他参数"><a href="#1-2-5-其他参数" class="headerlink" title="1.2.5 其他参数"></a>1.2.5 其他参数</h3><ol>
<li>vmstat是全面的性能分析工具。</li>
</ol>
<ul>
<li>标准情况下：等待运行的进程数r&lt;5，非中断睡眠状态下的进程数b约为0</li>
<li>如果r经常大于3或4，且id（闲置时间）经常少于50，就要考虑更换服务器或增加CPU数量</li>
<li>user% + sys% 表示CPU的用户模式时间 + 系统模式时间<ul>
<li>和 &lt;70% 表示系统性能较好</li>
<li>和&gt;=85% 表示系统性能比较糟糕</li>
</ul>
</li>
</ul>
<ol start="2">
<li>查看系统内核</li>
</ol>
<ul>
<li>内核版本号<ul>
<li>详细<code>uname -a</code></li>
<li>简化<code>uname -r</code></li>
</ul>
</li>
<li>查看系统是32位还是64位<ul>
<li><code>ls -lF / |grep /$ |egrep &#39;lib64|i386&#39;</code></li>
<li><code>file /sbin/init</code></li>
</ul>
</li>
</ul>
<ol start="3">
<li><code>lsb_release -a</code>查看发行版信息，如果CentOS5.8没有此命令，需要安装<code>yum -y install redhat-lsb</code></li>
<li><code>lsmod</code>查看系统已载入的相关模块</li>
<li><code>lspci</code>查找PCI设置，例如网卡、主板集成设备</li>
</ol>
<ul>
<li><code>miit-tool</code>检测机器网卡是否正常连接</li>
</ul>
<h2 id="1-3-Linux服务器的网络配置"><a href="#1-3-Linux服务器的网络配置" class="headerlink" title="1.3 Linux服务器的网络配置"></a>1.3 Linux服务器的网络配置</h2><h3 id="1-3-1-配置Linux服务器的网络"><a href="#1-3-1-配置Linux服务器的网络" class="headerlink" title="1.3.1 配置Linux服务器的网络"></a>1.3.1 配置Linux服务器的网络</h3><ol>
<li>手动修改配置网卡文件。跳过</li>
<li>修改机器的hostname名：编辑/etc/sysconfig/network文件</li>
<li>修改主机名查询静态表/etc/hosts，每一行由3部分组成，分别是<ul>
<li>网络IP地址</li>
<li>主机名或域名</li>
<li>主机名别名（可选）</li>
</ul>
</li>
<li>配置DNS只需修改/etc/resolv.conf，最多支持3个nameserver</li>
</ol>
<h3 id="1-3-2-查看网络连接"><a href="#1-3-2-查看网络连接" class="headerlink" title="1.3.2 查看网络连接"></a>1.3.2 查看网络连接</h3><ol>
<li><code>ifconfig -a</code>显示所有网络接口配置，<code>ifconfig eth0</code>显示指定接口</li>
<li><code>ping -c 5 www.163.com</code>只发5个包</li>
<li>netstat可显示网络连接、路由表和网络接口的信息</li>
</ol>
<ul>
<li><code>netstat -an | grep -v unix</code>显示所有套接字的状态，打印实际地址</li>
<li><code>netstat -an |awk &#39;/^tcp/ &#123;++S[$NF]&#125;END&#123;for (a in S) print a,S[a]&#125;&#39;</code>这个命令组合用于查看State的汇总信息</li>
<li><code>netstat -rn</code>与<code>route -n</code>都能查看路由表，输出中带有UG的行是默认网关</li>
</ul>
<ol start="4">
<li>nslookup跨平台通用</li>
<li>dig只存在于Linux及FreeBSD等开源系统中。<code>dig @114.114.114.114 sina.com.cn</code></li>
<li>finger和w命令可查询用户的信息</li>
<li>lsof列出当先系统打开的文件。<code>lsof -i:4000</code>查看4000端口由哪些程序占用</li>
<li>sockstat查看打开插口的情况，CentOS5.8中无此命令</li>
</ol>
<h3 id="1-3-3-查看Linux服务器的进程"><a href="#1-3-3-查看Linux服务器的进程" class="headerlink" title="1.3.3 查看Linux服务器的进程"></a>1.3.3 查看Linux服务器的进程</h3><ol>
<li><code>ps aux</code>获得终端上所有用户的有关进程的所有信息。输出中STAT列表示进程的运行状态，包括以下几种代码<ul>
<li>D 不可中断的睡眠</li>
<li>R 就绪</li>
<li>S 睡眠</li>
<li>T 被跟踪或停止</li>
<li>Z 终止（僵死）的进程</li>
<li>W 没有足够的内存分页可分配</li>
<li>&lt; 高优先序的进程</li>
<li>N 低优先序的进程</li>
<li>L 有内存分页分配并锁在内存体内（实时系统或IO）</li>
</ul>
</li>
<li>top基本类似于ps，且可以通过按键动态地刷新状态</li>
<li>pgrep查找当前运行的进程，并列出匹配给定条件进程的pid</li>
<li>kill    根据pid，给进程发送信号，默认为15</li>
<li>killall 根据程序的名字，直接杀死所有进程<h3 id="1-3-4-添加静态路由"><a href="#1-3-4-添加静态路由" class="headerlink" title="1.3.4 添加静态路由"></a>1.3.4 添加静态路由</h3></li>
<li>win：<code>route add 目的网段 mask 子网掩码 下一跳IP</code>用于临时添加静态路由，重启后会消失。想让路由一直保持需要加上-p开关，如<code>route -p add 10.10.0.0 mask 255.255.0.0 192.168.4.222</code></li>
<li>CentOS<ul>
<li>临时<code>route add -net 172.16.6.0 netmask 255.255.255.0 gw 172.16.2.25</code></li>
<li>永久添加需要编辑<code>/etc/sysconfig/network-scripts/route-eth0</code>添加一行<code>127.16.6.0/24 via 172.16.2.25</code></li>
<li>Debian系的网卡配置跟Redhat系很不一样，Redhat是放在/etc/sysconfig/network-scripts目录下面的一大堆文件里面。而Debian系的网卡配置则是存在/etc/network/interfaces</li>
</ul>
</li>
<li>FreeBSD<ul>
<li>临时<code>route add -net 172.16.0.0/24 172.16.2.25</code></li>
<li>永久添加需要编辑<code>/etc/rc.conf</code></li>
</ul>
</li>
</ol>
<h1 id="ch08-Linux防火墙及系统安全"><a href="#ch08-Linux防火墙及系统安全" class="headerlink" title="ch08 Linux防火墙及系统安全"></a>ch08 Linux防火墙及系统安全</h1><p>本章介绍Netfilter/iptables</p>
<h2 id="8-1-基础网络知识"><a href="#8-1-基础网络知识" class="headerlink" title="8.1 基础网络知识"></a>8.1 基础网络知识</h2><p>跳过</p>
<h2 id="8-2-Linux防火墙的概念"><a href="#8-2-Linux防火墙的概念" class="headerlink" title="8.2 Linux防火墙的概念"></a>8.2 Linux防火墙的概念</h2><p>Netfilter是内核的模块实现，iptables是上层的操作工具</p>
<p>有状态的防火墙能够指定并记住为发送或接收信息包所建立的连接状态，以增加其效率和速度。Netfilter/iptables有4种有效状态</p>
<ol>
<li>ESTABLISHED：已建立的连接</li>
<li>INVALID：与任何已知的流或连接都不相关联</li>
<li>NEW：该信息包已经或将启动新连接，或者它与尚未用于发送和接收信息包的连接相关联</li>
<li>RELATED：正在启动新连接</li>
</ol>
<h2 id="8-3-Linux防火墙在企业中的作用"><a href="#8-3-Linux防火墙在企业中的作用" class="headerlink" title="8.3 Linux防火墙在企业中的作用"></a>8.3 Linux防火墙在企业中的作用</h2><ol>
<li>IDC机房一般没有硬件防火墙，用开源免费的iptables是一个性价比高的选择。</li>
<li>iptables可以结合squid作为企业内部上网的透明代理</li>
<li>很多中小型企业和网吧利用iptables作为企业的NAT路由器。优势：节约成本、有效控制<ul>
<li>可以使用iptables的扩展模块屏蔽P2P流量、禁止非法网页。但建议通过行政手段控制非法流量。</li>
</ul>
</li>
<li>iptables还可以用于外网IP向内网IP映射，这种形式的NAT一般称为DNAT</li>
<li>iptables可以防止轻量级的DOS攻击</li>
</ol>
<h2 id="8-4-Linux防火墙的语法"><a href="#8-4-Linux防火墙的语法" class="headerlink" title="8.4 Linux防火墙的语法"></a>8.4 Linux防火墙的语法</h2><p>数据包的流向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">           ------FORWARD------</span><br><span class="line">          &#x2F;                   \</span><br><span class="line">PREROUTING                     POSTROUTING</span><br><span class="line">          \                   &#x2F;</span><br><span class="line">           INPUT -&gt; 本机OUTPUT</span><br></pre></td></tr></table></figure>
<p>iptables的两种工作模式：作为NAT路由器、作为主机防火墙</p>
<p>三个规则表</p>
<ol>
<li>filter</li>
<li>nat</li>
<li>mangle</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/10/high-availability-linux/" data-id="cl310rf3c000lgctk5dte7l4i" data-title="《构建高可用Linux服务器》读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mysql-ji-shu-nei-mu" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/21/mysql-ji-shu-nei-mu/" class="article-date">
  <time class="dt-published" datetime="2021-07-21T12:25:14.000Z" itemprop="datePublished">2021-07-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/21/mysql-ji-shu-nei-mu/">《mysql技术内幕》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E6%9C%AC%E4%B9%A6%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9">本书的主要内容</a></li>
<li><a href="#ch01-MySQL%E5%85%A5%E9%97%A8">ch01-MySQL入门</a></li>
<li><a href="#ch02-%E4%BD%BF%E7%94%A8SQL%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE">ch02-使用SQL管理数据</a></li>
<li><a href="#ch03-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">ch03-数据类型</a></li>
<li><a href="#ch10-MYSQL%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B">ch10-MYSQL管理简介</a></li>
</ul>
<h1 id="本书的主要内容"><a href="#本书的主要内容" class="headerlink" title="本书的主要内容"></a>本书的主要内容</h1><h2 id="各章路线图"><a href="#各章路线图" class="headerlink" title="各章路线图"></a>各章路线图</h2><ol>
<li>基本概念</li>
<li>编写程序</li>
<li>管理</li>
<li>参考附录</li>
</ol>
<h2 id="阅读本书的方法"><a href="#阅读本书的方法" class="headerlink" title="阅读本书的方法"></a>阅读本书的方法</h2><ol>
<li>对SQL熟悉，从第二章开始</li>
<li>如果你的职责是管理mysql的安装，读第十章</li>
</ol>
<h1 id="ch01-MySQL入门"><a href="#ch01-MySQL入门" class="headerlink" title="ch01 MySQL入门"></a>ch01 MySQL入门</h1><p>跳过</p>
<h1 id="ch02-使用SQL管理数据"><a href="#ch02-使用SQL管理数据" class="headerlink" title="ch02 使用SQL管理数据"></a>ch02 使用SQL管理数据</h1><p>第一章介绍了MySQL的许多功能，以及SQL的某些基本用法。本章更深入</p>
<h2 id="2-1-服务器的SQL模式"><a href="#2-1-服务器的SQL模式" class="headerlink" title="2.1 服务器的SQL模式"></a>2.1 服务器的SQL模式</h2><p>sql_mode值</p>
<ol>
<li>ANSI_QUOTES ：把双引号识别为一个标识符引用字符</li>
<li>PIPES_AS_CONCAT ：把<code>||</code>当成字符串连接运算符，而不是OR运算符</li>
<li>ANSI 标准模式：是一个组合模式，与默认状态相比，其行为更接近于标准SQL</li>
<li>TRADITIONAL 传统模式：是一个组合模式，处理坏数据时，其行为更接近于传统的SQL服务器</li>
<li>STRICT_ALL_TABLES 和 STRICT_TRANS_TABLES 将启用严格模式：拒绝接受坏数据</li>
</ol>
<p>运行时查询与更改SQL模式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@SESSION</span>.sql_mode;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@GLOBAL</span>.sql_mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;ANSI_QUOTES,PIPES_AS_CONCAT&#x27;</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;TRADITIONAL&#x27;</span></span><br></pre></td></tr></table></figure>
<p>全局性的设置对所有客户端产生影响</p>
<p>CF：3.3节；12.3.1节；附录D</p>
<h2 id="2-2-MySQL的标识符语法和命名规则"><a href="#2-2-MySQL的标识符语法和命名规则" class="headerlink" title="2.2 MySQL的标识符语法和命名规则"></a>2.2 MySQL的标识符语法和命名规则</h2><h3 id="标识符里的字符要合法"><a href="#标识符里的字符要合法" class="headerlink" title="标识符里的字符要合法"></a>标识符里的字符要合法</h3><ol>
<li>不加引号的标识符可以由a-zA-Z0-9、美元符号、下划线以及Unicode扩展字符U+0080~U+FFFF</li>
</ol>
<ul>
<li>MySQL支持标识符以数字开头的做法不常见，还要特别留意它是否包含e/E</li>
</ul>
<ol>
<li>标识符还可以用反引号`引起来，它支持使用<strong>除</strong>NUL字节和Unicode补充字符（&gt;=U+10000）<strong>以外</strong>的任何字符</li>
</ol>
<ul>
<li>如果标识符是SQL保留字或包含空格，那么引号就会很有用</li>
</ul>
<h3 id="服务器的SQL模式-ANSI-QUOTES-和-IGNORE-SPACE-对引号有影响"><a href="#服务器的SQL模式-ANSI-QUOTES-和-IGNORE-SPACE-对引号有影响" class="headerlink" title="服务器的SQL模式 ANSI_QUOTES 和 IGNORE_SPACE 对引号有影响"></a>服务器的SQL模式 ANSI_QUOTES 和 IGNORE_SPACE 对引号有影响</h3><h3 id="标识符的最大长度是64个字符，别名的最大长度是256个字符"><a href="#标识符的最大长度是64个字符，别名的最大长度是256个字符" class="headerlink" title="标识符的最大长度是64个字符，别名的最大长度是256个字符"></a>标识符的最大长度是64个字符，别名的最大长度是256个字符</h3><h3 id="标识符限定符：db-name-tbl-name-col-name-或-根据上下文使用部分限定名"><a href="#标识符限定符：db-name-tbl-name-col-name-或-根据上下文使用部分限定名" class="headerlink" title="标识符限定符：db_name.tbl_name.col_name 或 根据上下文使用部分限定名"></a>标识符限定符：db_name.tbl_name.col_name 或 根据上下文使用部分限定名</h3><h2 id="2-3-SQL语句的大小写规则"><a href="#2-3-SQL语句的大小写规则" class="headerlink" title="2.3 SQL语句的大小写规则"></a>2.3 SQL语句的大小写规则</h2><p>在Unix上创建表时，要考虑以后要否迁移到一台不区分大小写的机器上。建议统一使用小写字母，特别对于InnoDB而言。</p>
<h3 id="SQL关键字、函数名：不区分大小写"><a href="#SQL关键字、函数名：不区分大小写" class="headerlink" title="SQL关键字、函数名：不区分大小写"></a>SQL关键字、函数名：不区分大小写</h3><h3 id="数据库名、表名、视图名：取决于底层文件系统，Unix要区分大小写"><a href="#数据库名、表名、视图名：取决于底层文件系统，Unix要区分大小写" class="headerlink" title="数据库名、表名、视图名：取决于底层文件系统，Unix要区分大小写"></a>数据库名、表名、视图名：取决于底层文件系统，Unix要区分大小写</h3><h3 id="存储函数、存储过程、事件：不区分大小写"><a href="#存储函数、存储过程、事件：不区分大小写" class="headerlink" title="存储函数、存储过程、事件：不区分大小写"></a>存储函数、存储过程、事件：不区分大小写</h3><p>但触发器的名字要区分大小写，这一点与标准SQL的行为有所不同</p>
<h3 id="列名、索引名：不区分大小写"><a href="#列名、索引名：不区分大小写" class="headerlink" title="列名、索引名：不区分大小写"></a>列名、索引名：不区分大小写</h3><h3 id="别名要区分大小写，除非-lower-case-table-names-系统变量为非零值"><a href="#别名要区分大小写，除非-lower-case-table-names-系统变量为非零值" class="headerlink" title="别名要区分大小写，除非 lower_case_table_names 系统变量为非零值"></a>别名要区分大小写，除非 lower_case_table_names 系统变量为非零值</h3><h3 id="字符串值：取决于它是二进制还是非二进制串。CF：3-1-2节"><a href="#字符串值：取决于它是二进制还是非二进制串。CF：3-1-2节" class="headerlink" title="字符串值：取决于它是二进制还是非二进制串。CF：3.1.2节"></a>字符串值：取决于它是二进制还是非二进制串。CF：<a href="#">3.1.2节</a></h3><h2 id="2-4-字符集支持"><a href="#2-4-字符集支持" class="headerlink" title="2.4 字符集支持"></a>2.4 字符集支持</h2><p>MySQL支持在不同层次单独指定字符集，还可以为字符集挑选排序规则</p>
<h3 id="2-4-1-指定字符集"><a href="#2-4-1-指定字符集" class="headerlink" title="2.4.1 指定字符集"></a>2.4.1 指定字符集</h3><p>创建数据库和表时，使用两个字句指定字符集和排序规则</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集名</span><br><span class="line"><span class="keyword">COLLATE</span> 排序规则名</span><br></pre></td></tr></table></figure>
<p>这些规则适用于几个层次，局部规则覆盖全局规则，例如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db_name <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_danish_ci</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_name (...) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin1 <span class="keyword">COLLATE</span> latin1_spanish_ci</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -* 对于表里的列 *- --</span></span><br><span class="line"></span><br><span class="line">c <span class="type">CHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_danish_ci</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> l <span class="keyword">FROM</span> t <span class="keyword">ORDER</span> <span class="keyword">BY</span> l <span class="keyword">COLLATE</span> latin1_spanish_ci</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-确定可用字符集和当前设置"><a href="#2-4-2-确定可用字符集和当前设置" class="headerlink" title="2.4.2 确定可用字符集和当前设置"></a>2.4.2 确定可用字符集和当前设置</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="keyword">LIKE</span> <span class="string">&#x27;latin%&#x27;</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> <span class="keyword">LIKE</span> <span class="string">&#x27;utf8%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character\_set\_%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation\_%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-Unicode支持"><a href="#2-4-3-Unicode支持" class="headerlink" title="2.4.3 Unicode支持"></a>2.4.3 Unicode支持</h3><p>MySQL版本5.5.3和5.6.1是支持字符集的分水岭</p>
<h2 id="2-5-数据库的选择、创建、删除和更改"><a href="#2-5-数据库的选择、创建、删除和更改" class="headerlink" title="2.5 数据库的选择、创建、删除和更改"></a>2.5 数据库的选择、创建、删除和更改</h2><p>在涉及DATABASE的所有语句里，SCHEMA与DATABASE同义</p>
<h3 id="2-5-1-选择数据库：USE-db-name"><a href="#2-5-1-选择数据库：USE-db-name" class="headerlink" title="2.5.1 选择数据库：USE db_name;"></a>2.5.1 选择数据库：USE db_name;</h3><p>重新连接时无记忆</p>
<h3 id="2-5-2-创建数据库：CREATE-DATABASE-IF-NOT-EXISTS-db-name-字符集和排序规则"><a href="#2-5-2-创建数据库：CREATE-DATABASE-IF-NOT-EXISTS-db-name-字符集和排序规则" class="headerlink" title="2.5.2 创建数据库：CREATE DATABASE [IF NOT EXISTS] db_name [字符集和排序规则] ;"></a>2.5.2 创建数据库：<code>CREATE DATABASE [IF NOT EXISTS] db_name [字符集和排序规则] ;</code></h3><p>服务器会在其数据目录下创建一个<em>db_name</em>目录，还会在这个目录下创建一个名为db.opt的文件，用于存储全局属性——目前只包含默认字符集和排序规则</p>
<p>查看方法<code>SHOW CREATE DATABASE db_name\G</code></p>
<h3 id="2-5-3-删除数据库：DROP-DATABASE-db-name"><a href="#2-5-3-删除数据库：DROP-DATABASE-db-name" class="headerlink" title="2.5.3 删除数据库：DROP DATABASE db_name;"></a>2.5.3 删除数据库：DROP DATABASE db_name;</h3><p>如果执行失败，通常是因为那个数据库的目录里还包含有一些与数据库对象无关的文件。需要手动删除该数据库目录里的残留文件和目录，再调用DROP DATABASE</p>
<h3 id="2-5-4-更改数据库：ALTER-DATABASE-db-name-字符集和排序规则"><a href="#2-5-4-更改数据库：ALTER-DATABASE-db-name-字符集和排序规则" class="headerlink" title="2.5.4 更改数据库：ALTER DATABASE [db_name] [字符集和排序规则];"></a>2.5.4 更改数据库：<code>ALTER DATABASE [db_name] [字符集和排序规则];</code></h3><p>字符集和排序规则至少给定一个</p>
<h2 id="2-6-表的创建、删除、索引和更改"><a href="#2-6-表的创建、删除、索引和更改" class="headerlink" title="2.6 表的创建、删除、索引和更改"></a>2.6 表的创建、删除、索引和更改</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line">  <span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX</span><br><span class="line">  <span class="keyword">DROP</span> INDEX</span><br></pre></td></tr></table></figure>

<h3 id="2-6-1-存储引擎的特性"><a href="#2-6-1-存储引擎的特性" class="headerlink" title="2.6.1 存储引擎的特性"></a>2.6.1 存储引擎的特性</h3><p>本书未介绍到的引擎很少用到</p>
<p><strong>表2-1 MySQL的存储引擎</strong></p>
<h4 id="2-6-1-1-查看有哪些存储引擎可用：SHOW-ENGINES-G"><a href="#2-6-1-1-查看有哪些存储引擎可用：SHOW-ENGINES-G" class="headerlink" title="2.6.1.1 查看有哪些存储引擎可用：SHOW ENGINES\G"></a>2.6.1.1 查看有哪些存储引擎可用：<code>SHOW ENGINES\G</code></h4><table>
<thead>
<tr>
<th>栏</th>
<th>表示</th>
</tr>
</thead>
<tbody><tr>
<td>Engine:</td>
<td></td>
</tr>
<tr>
<td>Support:</td>
<td>可用吗</td>
</tr>
<tr>
<td>Comment:</td>
<td></td>
</tr>
<tr>
<td>Transactions:</td>
<td>支持事务处理吗</td>
</tr>
<tr>
<td>XA:</td>
<td>支持分布式事务吗</td>
</tr>
<tr>
<td>Savepoints:</td>
<td>支持事务回滚吗</td>
</tr>
</tbody></table>
<h4 id="2-6-1-2-表的磁盘存储方式"><a href="#2-6-1-2-表的磁盘存储方式" class="headerlink" title="2.6.1.2 表的磁盘存储方式"></a>2.6.1.2 表的磁盘存储方式</h4><p>每个表都有一个与之对应的<em>table_name</em>.frm文件用于保存该表的格式（即它的定义）</p>
<p>各个存储引擎还可能会为表再创建几个特定的文件，用以存储表的内容。也有可能保存在其他地方</p>
<h4 id="2-6-1-3-InnoDB存储引擎"><a href="#2-6-1-3-InnoDB存储引擎" class="headerlink" title="2.6.1.3 InnoDB存储引擎"></a>2.6.1.3 InnoDB存储引擎</h4><p>默认情况下，InnoDB会把表集中存储在一个系统表空间里，而不像2.6.1.2节所述。</p>
<h4 id="2-6-1-4-MyISAM存储引擎"><a href="#2-6-1-4-MyISAM存储引擎" class="headerlink" title="2.6.1.4 MyISAM存储引擎"></a>2.6.1.4 MyISAM存储引擎</h4><ol>
<li>对连续相似的字符串索引值进行压缩，选项PACK_KEYS=1还能压缩数字索引</li>
<li>AUTO_INCREATMENT提供更多功能。CF：<a href="#">3.4节</a></li>
<li>每个MyISAM表都有标志表明是否被正常关闭，可用于判断表是否需要检查和修复。CF：<a href="#">14.3.1节</a></li>
<li>支持全文检索和FULLTEXT索引</li>
<li>支持空间数据类型和SPATIAL索引</li>
</ol>
<h4 id="2-6-1-5-MEMORY存储引擎"><a href="#2-6-1-5-MEMORY存储引擎" class="headerlink" title="2.6.1.5 MEMORY存储引擎"></a>2.6.1.5 MEMORY存储引擎</h4><p>把表存在主存。掉电时内容清空不过与用<code>CREATE TEMPORARY TABLE</code>创建出来的临时表相比，MEMORY表对其他客户端可见。</p>
<ol>
<li>使用散列索引，对于“等值比较”非常快，但对于“范围比较”非常慢。不适合ORDER BY</li>
</ol>
<ul>
<li>如果需要范围比较，可以用BTREE索引来代替散列索引。CF：2.6.4.2节和5.1.3节</li>
</ul>
<ol>
<li>表的行长度固定不变，可以使用VARCHAR，但不能使用BLOB和TEXT类型</li>
</ol>
<h4 id="2-6-1-6-NDB存储引擎"><a href="#2-6-1-6-NDB存储引擎" class="headerlink" title="2.6.1.6 NDB存储引擎"></a>2.6.1.6 NDB存储引擎</h4><p>是集群（cluster）存储引擎。对此，MySQL服务器实际上变成了其他进程的集群客户端。NDB需要更多扩展性讨论，超出本书范围</p>
<h4 id="2-6-1-7-其他存储引擎"><a href="#2-6-1-7-其他存储引擎" class="headerlink" title="2.6.1.7 其他存储引擎"></a>2.6.1.7 其他存储引擎</h4><ol>
<li>ARCHIVE：提供数据归档存储功能。适合大批量存储“写了就不会再更改的行”。存储时压缩，检索时解压。只可包含1个带索引的AUTO_INCREATMENT列</li>
<li>BLACKHOLE：写操作会被忽略，读操作返回空内容</li>
<li>CSV：在文本文件中存储逗号分隔值。不支持索引</li>
<li>FEDREATED：提供访问远程MySQL服务器的能力</li>
<li>MERGE：提供合并多个MyISAM表为一个逻辑单元的手段，以突破文件系统对MyISAM表的最大尺寸。对于分区表，CF：<a href="#2-6-2-5-%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8">2.6.2.5节</a></li>
</ol>
<h3 id="2-6-2-创建表"><a href="#2-6-2-创建表" class="headerlink" title="2.6.2 创建表"></a>2.6.2 创建表</h3><p>简单的CREATE TABLE只需指定表名和各个列。</p>
<p>可以在创建表时指定如何索引。对于MyISAM表来说，如果计划在查询前先填入大量的数据，那最好先创建不带索引的表，填入数据后再为它加上索引。</p>
<p>本节将重点介绍CREATE TABLE语句的5种重要扩展。关于列定义的细节CF：<a href="#ch03-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">ch03-数据类型</a></p>
<h4 id="2-6-2-1-表选项"><a href="#2-6-2-1-表选项" class="headerlink" title="2.6.2.1 表选项"></a>2.6.2.1 表选项</h4><p>不想使用默认的存储特性，就要在右括号之后加上表选项。CF：附录E</p>
<p>想指定存储引擎：<code>CREATE TABLE t (i INT) ENGINE = ARCHIVE;</code>。如果指定的ENGINE未启用，会看到<code>2 warnings</code>。用<code>SHOW WARNINGS;</code>查看警告信息，用<code>SHOW CREATE TABLE t\G</code>确定表使用了啥引擎</p>
<p>一定要保证创建表的语句回显<strong>0 warning</strong>；如果想让MySQL在ENGINE不可用时报错，启用NO_ENGINE_SUBSTITUTION模式。</p>
<h5 id="用于MyISAM的其他选项：MAX-ROWS和AVG-ROW-LENGTH用于调整表的大小"><a href="#用于MyISAM的其他选项：MAX-ROWS和AVG-ROW-LENGTH用于调整表的大小" class="headerlink" title="用于MyISAM的其他选项：MAX_ROWS和AVG_ROW_LENGTH用于调整表的大小"></a>用于MyISAM的其他选项：MAX_ROWS和AVG_ROW_LENGTH用于调整表的大小</h5><h4 id="2-6-2-2-暂时性表的创建"><a href="#2-6-2-2-暂时性表的创建" class="headerlink" title="2.6.2.2 暂时性表的创建"></a>2.6.2.2 暂时性表的创建</h4><p>在把脚本当做批处理作业运行时，IF NOT EXIST 很有用。</p>
<p>如果可能存在名字相同但结构不同的表，更谨慎的做法是在<code>CREATE TABLE</code>之前放置<code>DROP TABLE IF EXISTS</code></p>
<h4 id="2-6-2-3-TEMPORARY表"><a href="#2-6-2-3-TEMPORARY表" class="headerlink" title="2.6.2.3 TEMPORARY表"></a>2.6.2.3 TEMPORARY表</h4><p><code>CREATE TEMPORARY TABLE tb1_name ... ;</code>创建出来的的表会在会话终止时自动消失</p>
<p>及时将临时性的MEMORY表释放掉是个好习惯，建议用<code>DROP TEMPORARY TABLE</code></p>
<p>如果TEMPORARY表名字与已有的永久表相同，永久表的名字会被暂时隐藏</p>
<p>连接池机制的自动重连问题会给TEMPORARY带来麻烦</p>
<h4 id="2-6-2-4-根据其他表或查询结果来创建表"><a href="#2-6-2-4-根据其他表或查询结果来创建表" class="headerlink" title="2.6.2.4 根据其他表或查询结果来创建表"></a>2.6.2.4 根据其他表或查询结果来创建表</h4><ol>
<li><code>CREATE [TEMPORARY] TABLE new_t LIKE old_t;</code>会创建与原有表结构相同的空副本；想填充数据还需要<code>INSERT INTO new_t SELECT * FROM old_t;</code>。</li>
<li><code>CREATE TABLE triple_pi SELECT PI() * 3 AS col_name ;</code>可以根据任意一条SELECT语句的查询结果创建新表。</li>
</ol>
<ul>
<li>默认不复制所有的列属性，如AUTO_INCREATMENT</li>
<li>不会复制索引</li>
<li>如果不用AS提供别名，新表的列名会直接使用了表达式文本<code>PI() * 3</code></li>
</ul>
<p><code>CREATE TABLE ... SELECT</code>的不足之处：不复制索引、可能丢失列属性。可以保留的列属性包括：NOT NULL与否、默认值、列注释、字符集和排序规则。补救方案：</p>
<ol>
<li>在SELECT部分用CAST()函数强制使用某些属性</li>
<li>在CREATE部分提供显式的列定义，同时必须在SELECT部分提供匹配的别名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytb1 (i <span class="type">INT</span> UNSIGNED, t <span class="type">TIME</span>, d <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">AS</span> i,</span><br><span class="line"><span class="built_in">CAST</span>(CURTIME() <span class="keyword">AS</span> <span class="type">TIME</span>) <span class="keyword">AS</span> t,</span><br><span class="line"><span class="built_in">CAST</span>(PI() <span class="keyword">AS</span> <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">5</span>)) <span class="keyword">AS</span> d;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-2-5-使用分区表"><a href="#2-6-2-5-使用分区表" class="headerlink" title="2.6.2.5 使用分区表"></a>2.6.2.5 使用分区表</h4>用PARTITION BY子句定义分区函数及其它选项</li>
<li>根据范围来分区，适用于：日期、收入水平、重量等等</li>
<li>根据列表来分区，如：邮编、电话区号、按地理区域划分</li>
<li>根据散列值来分区，可自行提供散列函数</li>
</ol>
<p>例如创建表时按年分区到2013</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> log_part (</span><br><span class="line">	dt DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	info <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	INDEX (dt)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(dt)) (</span><br><span class="line">	<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2010</span>),</span><br><span class="line">	<span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2011</span>),</span><br><span class="line">	<span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2012</span>),</span><br><span class="line">	<span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2013</span>),</span><br><span class="line">	<span class="keyword">PARTITION</span> pmax <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- -* 当到了2014年时进一步划分 *- --</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> log_part REORGANIZE <span class="keyword">PARTITION</span> pmax</span><br><span class="line"><span class="keyword">INTO</span> (</span><br><span class="line">	<span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2014</span>),</span><br><span class="line">	<span class="keyword">PARTITION</span> pmax <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>若想将存储分散到不同的物理设备上，则需要用到分区选项 DATA_DIRECTORY 和 INDEX_DIRECTORY。CF：附录E</p>
<h3 id="2-6-3-删除表"><a href="#2-6-3-删除表" class="headerlink" title="2.6.3 删除表"></a>2.6.3 删除表</h3><p>删除不存在的表会报错，<code>DROP TABLE IF EXISTS</code>只会给出警告信息</p>
<h3 id="2-6-4-索引表"><a href="#2-6-4-索引表" class="headerlink" title="2.6.4 索引表"></a>2.6.4 索引表</h3><h4 id="2-6-4-1-存储引擎的索引特性"><a href="#2-6-4-1-存储引擎的索引特性" class="headerlink" title="2.6.4.1 存储引擎的索引特性"></a>2.6.4.1 存储引擎的索引特性</h4><p>多种灵活的索引创建办法</p>
<ol>
<li>单列索引或多列复合索引</li>
<li>唯一值或重复值</li>
<li>同一个表可创建多个索引</li>
<li>前缀索引</li>
</ol>
<p>表2-3展示InnoDB、MyISAM、MEMORY所支持的索引功能</p>
<h4 id="2-6-4-2-创建索引"><a href="#2-6-4-2-创建索引" class="headerlink" title="2.6.4.2 创建索引"></a>2.6.4.2 创建索引</h4><p>ALTER TABLE比CREATE TABLE更灵活，可用来创建任何一种索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX	index_name (index_columns);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>	index_name (index_columns);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> FULLTEXT	index_name (index_columns);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> SPATIAL	index_name (index_columns);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (index_columns);</span><br></pre></td></tr></table></figure>
<p>其中SPATIAL和PRIMARY KEY只能用于NOT NULL</p>
<p>索引UNIQUE和PRIMARY KEY都只包含唯一值，区别如下</p>
<ol>
<li>每个表只能包含一个PRIMARY KEY，但可以防止多个UNIQUE索引</li>
<li>UNIQUE可以包含NULL值</li>
</ol>
<p>想为MEMORY表创建BTREE索引，在CREATE里增加USING子句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> namelist(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	INDEX (id) <span class="keyword">USING</span> BTREE,</span><br><span class="line">	INDEX (name(<span class="number">10</span>)) <span class="comment">-- -* 前缀索引 *- --</span></span><br><span class="line">) ENGINE <span class="operator">=</span> MEMORY;</span><br></pre></td></tr></table></figure>
<p>可以看出，前缀索引的语法是col_name(n)</p>
<p>为FULLTEXT指定前缀长度会被MySQL忽略。但有些列不能使用满列值方式的索引</p>
<ol>
<li>对于BLOB或TEXT列，只能创建前缀索引</li>
<li>如果在MyISAM表中创建的索引的总长度超过1000，必须使用前缀索引</li>
</ol>
<h4 id="2-6-4-3-删除索引"><a href="#2-6-4-3-删除索引" class="headerlink" title="2.6.4.3 删除索引"></a>2.6.4.3 删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX</span><br><span class="line"><span class="keyword">DROP</span> INDEX `<span class="keyword">PRIMARY</span>` <span class="keyword">ON</span> tb1_name;</span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> tb1_name;</span><br></pre></td></tr></table></figure>
<p>删除列时，索引会隐式地受到影响</p>
<h3 id="2-6-5-更改表结构"><a href="#2-6-5-更改表结构" class="headerlink" title="2.6.5 更改表结构"></a>2.6.5 更改表结构</h3><p>ALTER前后都可以用SHOW CREATE TABLE来查看和验证</p>
<h4 id="更改列的数据类型"><a href="#更改列的数据类型" class="headerlink" title="更改列的数据类型"></a>更改列的数据类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb1_name MODIFY col_name MEDIUMINT UNSIGNED;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tb1_name MODIFY old_name new_name MEDIUMINT UNSIGNED;</span><br></pre></td></tr></table></figure>
<h4 id="更改存储引擎"><a href="#更改存储引擎" class="headerlink" title="更改存储引擎"></a>更改存储引擎</h4><p><code>ALTER TABLE tb1_name ENGINE = InnoDB;</code>注意事如下</p>
<ol>
<li>从InnoDB转成其他引擎时，外键约束会消失</li>
<li>MEMORY表在服务器退出时会消失</li>
<li>包含BLOB列的表无法转成MEMORY引擎</li>
</ol>
<h2 id="2-7-获取数据库元数据"><a href="#2-7-获取数据库元数据" class="headerlink" title="2.7 获取数据库元数据"></a>2.7 获取数据库元数据</h2><p>多种方式</p>
<ol>
<li>SHOW语句</li>
<li>查询INFORMATION_SCHEMA数据库里的表</li>
<li>命令行程序：mysqlshow、mysqldump</li>
</ol>
<h3 id="2-7-1-SHOW"><a href="#2-7-1-SHOW" class="headerlink" title="2.7.1 SHOW"></a>2.7.1 SHOW</h3><p><code>SHOW COLUMNS FROM table_name</code>有别名<code>DESCREBE table_name</code>或<code>EXPLAIN table_name</code></p>
<p>确定某表是否存在的几种方式，适用于不同场景</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES [<span class="keyword">FROM</span> db_name] <span class="keyword">LIKE</span> <span class="string">&#x27;table%name&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> table_name;	<span class="comment">-- 最适合MyISAM</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="literal">FALSE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ENGINE <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES <span class="keyword">WHERE</span> TABLE_NAME<span class="operator">=</span><span class="string">&#x27;table_name&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-2-借助INFORMATION-SCHEMA获取元数据"><a href="#2-7-2-借助INFORMATION-SCHEMA获取元数据" class="headerlink" title="2.7.2 借助INFORMATION_SCHEMA获取元数据"></a>2.7.2 借助INFORMATION_SCHEMA获取元数据</h3><p>用 SELECT 访问 INFORMATION_SCHEMA 比用 SHOW 更灵活</p>
<p><strong>简述各个表</strong></p>
<h3 id="2-7-3-从命令行获取元数据"><a href="#2-7-3-从命令行获取元数据" class="headerlink" title="2.7.3 从命令行获取元数据"></a>2.7.3 从命令行获取元数据</h3><p>从不带参数的mysqlshow开始逐级深入到表</p>
<p>记得指定必要的连接参数选项，如–host、–user或–password</p>
<p>借助<code>mysqldump --no-data db_name [tb1_name] ...</code>查看表定义</p>
<h2 id="2-8-多表检索与连接操作"><a href="#2-8-多表检索与连接操作" class="headerlink" title="2.8 多表检索与连接操作"></a>2.8 多表检索与连接操作</h2><p>在<a href="#ch01-MySQL%E5%85%A5%E9%97%A8">ch01</a>重点讨论了对单表使用 SELECT、FROM、WHERE、GROUP BY、ORDER BY、HAVING、LIMIT。</p>
<p>多表查询语句包括：连接操作、子查询、UNION</p>
<h3 id="2-8-1-内连接"><a href="#2-8-1-内连接" class="headerlink" title="2.8.1 内连接"></a>2.8.1 内连接</h3><p>算笛卡尔积的几个等价的运算符：INNER JOIN、CROSS JOIN、JOIN、逗号。因逗号运算符的优先级问题而建议避免使用逗号。</p>
<p>如果被连接的两表有同名列，USING子句可简化语法<code>SELECT t1.*, t2.* FROM t1 JOIN t2 USING (same_col);</code></p>
<h3 id="2-8-2-限定列引用"><a href="#2-8-2-限定列引用" class="headerlink" title="2.8.2 限定列引用"></a>2.8.2 限定列引用</h3><p>自连接操作需要用AS为表取一个别名</p>
<h3 id="2-8-3-左外连接和右外连接"><a href="#2-8-3-左外连接和右外连接" class="headerlink" title="2.8.3 左外连接和右外连接"></a>2.8.3 左外连接和右外连接</h3><p>LEFT JOIN会在左表的某行在右表里无匹配时连接右表的一个全NULL的假行</p>
<p>注意事项：如果右表里本来就包含值为NULL的列，就无法区分原生NULL与标识未匹配行的NULL</p>
<p>想找到左表里哪些行在右表里无匹配：<br><code>SELECT t1.*  FROM t1 LEFT JOIN t2 ON t1.i1 = t2.i2  WHERE t2.i2 IS NULL;</code></p>
<p>NATURAL LEFT JOIN 就是自动指定 USING(同名列) 的 LEFT JOIN</p>
<h2 id="2-9-子查询"><a href="#2-9-子查询" class="headerlink" title="2.9 子查询"></a>2.9 子查询</h2><p>子查询可以依赖外层查询里的值。CF：<a href="#2-9-5-%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2">2.9.5 相关子查询</a></p>
<p>如果子查询用在有副作用的语句，它会被禁止查询正在被修改的表</p>
<p>子查询的类型</p>
<ol>
<li>标量子查询：可以出现在任何允许使用标量操作数的地方</li>
<li>行子查询：通常需要行构造器来实现比较，例如下面语句返回与特朗普出生于同一个州和城市的那些总统<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> prisident </span><br><span class="line"><span class="keyword">WHERE</span> (city, state) <span class="operator">=</span> </span><br><span class="line">(<span class="keyword">SELECT</span> city, state <span class="keyword">FROM</span> prisident</span><br><span class="line"> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Trump&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>列子查询</li>
<li>表子查询</li>
</ol>
<h3 id="2-9-1-带关系比较运算符的子查询"><a href="#2-9-1-带关系比较运算符的子查询" class="headerlink" title="2.9.1 带关系比较运算符的子查询"></a>2.9.1 带关系比较运算符的子查询</h3><p>由于不能在WHERE里使用聚合函数，用sql选取出生最早的总统需要做如下改写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> prisident <span class="keyword">WHERE</span> birth <span class="operator">=</span> <span class="built_in">MIN</span>(birth);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> prisident </span><br><span class="line"><span class="keyword">WHERE</span> birth <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(birth) <span class="keyword">FROM</span> prisident);</span><br></pre></td></tr></table></figure>
<h3 id="2-9-2-IN和NOT-IN实际上就是-SOME和-lt-gt-ALL的同义词"><a href="#2-9-2-IN和NOT-IN实际上就是-SOME和-lt-gt-ALL的同义词" class="headerlink" title="2.9.2 IN和NOT IN实际上就是= SOME和&lt;&gt; ALL的同义词"></a>2.9.2 <code>IN</code>和<code>NOT IN</code>实际上就是<code>= SOME</code>和<code>&lt;&gt; ALL</code>的同义词</h3><p>可用于各种类型的子查询</p>
<h3 id="2-9-3-ALL、ANY和SOME子查询"><a href="#2-9-3-ALL、ANY和SOME子查询" class="headerlink" title="2.9.3 ALL、ANY和SOME子查询"></a>2.9.3 ALL、ANY和SOME子查询</h3><p>SOME是ANY的同义词</p>
<p>下面语句返回最早出生的总统</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> prisident</span><br><span class="line"><span class="keyword">WHERE</span> birth <span class="operator">&lt;=</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> birth <span class="keyword">FROM</span> prisident);</span><br></pre></td></tr></table></figure>
<h3 id="2-9-4-EXISTS和NOT-EXISTS"><a href="#2-9-4-EXISTS和NOT-EXISTS" class="headerlink" title="2.9.4 EXISTS和NOT EXISTS"></a>2.9.4 EXISTS和NOT EXISTS</h3><p><code>SELECT EXISTS (SELECT * FROM absence);</code>测试子查询是否为空<br>（博主注：用<code>SELECT COUNT(*)&gt;0 FROM absence</code>不就好了）</p>
<h3 id="2-9-5-相关子查询"><a href="#2-9-5-相关子查询" class="headerlink" title="2.9.5 相关子查询"></a>2.9.5 相关子查询</h3><p>通常配合EXISTS用于在某个表里查找在另一个表里有匹配的行，或没有匹配的行。工作原理：把值从外层查询传递到子查询，并检查其是否满足子查询里的条件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> absence <span class="keyword">WHERE</span> absence.id <span class="operator">=</span> student.id);</span><br></pre></td></tr></table></figure>
<h3 id="2-9-6-FROM子句里的子查询"><a href="#2-9-6-FROM子句里的子查询" class="headerlink" title="2.9.6 FROM子句里的子查询"></a>2.9.6 FROM子句里的子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span>) <span class="keyword">AS</span> l <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">4</span>) <span class="keyword">AS</span> r;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+---+---+---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+---+---+---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+---+---+---+</span></span><br></pre></td></tr></table></figure>
<h3 id="2-9-7-将子查询改写为连接操作"><a href="#2-9-7-将子查询改写为连接操作" class="headerlink" title="2.9.7 将子查询改写为连接操作"></a>2.9.7 将子查询改写为连接操作</h3><h4 id="2-9-7-1-改写-WHERE-…-IN-子查询"><a href="#2-9-7-1-改写-WHERE-…-IN-子查询" class="headerlink" title="2.9.7.1 改写 WHERE … IN 子查询"></a>2.9.7.1 改写 WHERE … IN 子查询</h4><p>一般情况下，下述两个查询模式等价</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> col2 <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> col2 <span class="operator">=</span> <span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> t1.<span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.col1 <span class="operator">=</span> t2.col2 <span class="keyword">WHERE</span> t2.col2 <span class="operator">=</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>
<p>如果t2包含col2的多个实例，DISTINCT是必要的</p>
<h4 id="2-9-7-2-改写-WHERE-…-NOT-IN-子查询"><a href="#2-9-7-2-改写-WHERE-…-NOT-IN-子查询" class="headerlink" title="2.9.7.2 改写 WHERE … NOT IN 子查询"></a>2.9.7.2 改写 WHERE … NOT IN 子查询</h4><p>一般情况下，下述两个查询模式等价</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2 <span class="keyword">FROM</span> t2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> t1.<span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 </span><br><span class="line"><span class="keyword">ON</span> t1.col1 <span class="operator">=</span> t2.col2 <span class="keyword">WHERE</span> t2.col2 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>如果col2本来就包含NULL值，不适合用外连接</p>
<h2 id="2-10-使用UNION实现多表检索"><a href="#2-10-使用UNION实现多表检索" class="headerlink" title="2.10 使用UNION实现多表检索"></a>2.10 使用UNION实现多表检索</h2><p>UNION可以将多个包含相同数量的列的表数据拼接在一起。特性如下</p>
<ol>
<li>列名和数据类型都来自第一个SELECT。</li>
</ol>
<ul>
<li>如果后面SELECT出来的列数据类型不同于第一个SELECT，会进行必要的类型转换</li>
<li>列是根据位置，而不是根据名字来匹配。</li>
</ul>
<ol>
<li>默认剔除重复行。UNION等同于UNION DISTINCT；想保留重复行要改用UNION ALL。混合使用时“不同联合”的优先级比UNION ALL更高</li>
<li>使用ORDER BY和LIMIT时要注意对整体操作还是对单个SELECT操作，强烈建议用括号把每一个SELECT语句括起来</li>
</ol>
<h2 id="2-11-多表删除和更新"><a href="#2-11-多表删除和更新" class="headerlink" title="2.11 多表删除和更新"></a>2.11 多表删除和更新</h2><p>删除两表中匹配的行<code>DELETE t1, t2 FROM t1 INNER JOIN t2 ON t1.id = t2.id</code></p>
<p>任意一种SELECT语句支持的连接操作，多表DELETE语句都支持。对两表中不匹配的行的选择语句与删除语句的对比：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.<span class="operator">*</span></span><br><span class="line"> <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.i1 <span class="operator">=</span> t2.i2</span><br><span class="line"> <span class="keyword">WHERE</span> t2.i2 <span class="keyword">IS</span> <span class="keyword">NULL</span>;`</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> t1</span><br><span class="line"> <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.i1 <span class="operator">=</span> t2.i2</span><br><span class="line"> <span class="keyword">WHERE</span> t2.i2 <span class="keyword">IS</span> <span class="keyword">NULL</span>;`</span><br></pre></td></tr></table></figure>

<p>有些多表UPDATE语句既能用子查询也能用连接操作。想要复制列值，只能用连接操作：<br>`UPDATE t1, t2 SET t2.a = t1.a WHERE t2.id = t1.id;</p>
<p>InnoDB引擎的外键关系能协助多表删除和更新，需要包含约束条件：</p>
<ul>
<li>ON DELETE CASCADE 或</li>
<li>ON UPDATE CASCADE</li>
</ul>
<h2 id="2-12-事务处理"><a href="#2-12-事务处理" class="headerlink" title="2.12 事务处理"></a>2.12 事务处理</h2><p>金融业通常需要InnoDB；对于记录网页访问情况的应用，能接受损失几行记录，可以使用MyISAM。</p>
<h3 id="2-12-1-利用事务保证语句安全执行"><a href="#2-12-1-利用事务保证语句安全执行" class="headerlink" title="2.12.1 利用事务保证语句安全执行"></a>2.12.1 利用事务保证语句安全执行</h3><p>与oracle不同，MySQL默认运行模式是自动提交。显式执行事务的方式</p>
<ol>
<li><code>SET autocommit = 0; ... ;SET autocommit = 1;</code></li>
<li>先调用BEGIN（或START TRANSACTION），事务处理过程中可以调用ROLLBACK撤销更改，最后用COMMIT结束事务。</li>
</ol>
<p>默认情况下，一个mysql程序实例中尚未提交的更改在其他mysql程序实例中不可见</p>
<p>如果在事务处理过程中调用了START TRANSACTION语句，会隐式提交当前事务再开始新事务</p>
<p>DDL语句和那些与锁定有关的语句不能成为事务的一部分。<strong>隐式提交的语句</strong></p>
<p>在事务提交前结束会话或意外中断，服务器会自动回滚</p>
<p>注意事项：非事务表总是待在自动提交模式下，如果在某个事务里修改了一个非事务表，那么这个修改无法被回滚还原</p>
<h3 id="2-12-2-SAVEPOINT"><a href="#2-12-2-SAVEPOINT" class="headerlink" title="2.12.2 SAVEPOINT"></a>2.12.2 SAVEPOINT</h3><p>ROLLBACK TO savepoint_name;用于回滚到标记点</p>
<h3 id="2-12-3-事务隔离"><a href="#2-12-3-事务隔离" class="headerlink" title="2.12.3 事务隔离"></a>2.12.3 事务隔离</h3><p>MyISAM使用表级锁定机制，InnoDB使用比较底层的锁定方式。</p>
<p>InnoDB的事务隔离级别功能可以控制：一个客户端的事务是否应该看到另一个客户端的事务所做的修改。4个级别如下</p>
<ol>
<li>READ UNCOMMITTED </li>
<li>READ COMMITTED</li>
<li>REPEATABLE READ（默认）</li>
<li>SERIALIZABLE</li>
</ol>
<p><strong>本章未读完</strong></p>
<h2 id="2-13-InnoDB对外键定义语法的支持还不完备"><a href="#2-13-InnoDB对外键定义语法的支持还不完备" class="headerlink" title="2.13 InnoDB对外键定义语法的支持还不完备"></a>2.13 InnoDB对外键定义语法的支持还不完备</h2><h2 id="2-14-使用FULLTEXT搜索"><a href="#2-14-使用FULLTEXT搜索" class="headerlink" title="2.14 使用FULLTEXT搜索"></a>2.14 使用FULLTEXT搜索</h2><h1 id="ch03-数据类型"><a href="#ch03-数据类型" class="headerlink" title="ch03 数据类型"></a>ch03 数据类型</h1><p>TIMESTAMP和拥有AUTO_INCREATMENT的整数具有特殊行为</p>
<h2 id="3-1-数据值类别"><a href="#3-1-数据值类别" class="headerlink" title="3.1 数据值类别"></a>3.1 数据值类别</h2><h3 id="3-1-1-数值"><a href="#3-1-1-数值" class="headerlink" title="3.1.1 数值"></a>3.1.1 数值</h3><h4 id="3-1-1-1-精确值数和近似值数"><a href="#3-1-1-1-精确值数和近似值数" class="headerlink" title="3.1.1.1 精确值数和近似值数"></a>3.1.1.1 精确值数和近似值数</h4><p>MySQL能识别的数字包括：整数、定点数、浮点数以及位域值</p>
<p>带小数部分的1.23456属于精确值；而1.58E5属于近似值</p>
<p>MySQL会根据以下规则来决定是使用精确计算还是近似运算</p>
<ol>
<li>只要表达式里有近似值，就会被当做浮点（近似）表达式来进行计算</li>
<li>如果表达式只包含整数精确值，会以BIGINT（64位）精度来进行计算</li>
<li>如果表达式只包含精确值，但小数，会以具有65位精度的DECIMAL算法来进行计算</li>
<li>如果字符串参与计算，通常会被转换成双精度浮点值</li>
</ol>
<h4 id="3-1-1-2-位域值"><a href="#3-1-1-2-位域值" class="headerlink" title="3.1.1.2 位域值"></a>3.1.1.2 位域值</h4><p>例如 b’1001’ 和 0b1001 都等于十进制9。在SELECT里将它们+0能按10进制显示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b<span class="string">&#x27;1001&#x27;</span><span class="operator">+</span><span class="number">0</span>, <span class="built_in">CAST</span>(<span class="number">0</span>b1001 <span class="keyword">AS</span> UNSIGNED);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> b<span class="string">&#x27;1001&#x27;</span><span class="operator">+</span><span class="number">0</span> <span class="operator">|</span> <span class="built_in">CAST</span>(<span class="number">0</span>b1001 <span class="keyword">AS</span> UNSIGNED) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>         <span class="number">9</span> <span class="operator">|</span>                        <span class="number">9</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------------------------+</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-字符串值"><a href="#3-1-2-字符串值" class="headerlink" title="3.1.2 字符串值"></a>3.1.2 字符串值</h3><p>字符串两边的引号尽量使用单引号</p>
<p>书写字符串值的十六进制记法</p>
<ol>
<li>X’val’记法要求val的数字个数为偶数，例如：X’61626364’</li>
<li>0xval记法后面跟着多个十六进制数字，例如：0x61626364</li>
</ol>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><ol>
<li>二进制串是一组字节序列。不涉及字符集；没有特殊的比较或排序属性</li>
</ol>
<ul>
<li>想对二进制串使用UPPER()或LOWER()需要先用CONVERT(str USING charset)做类型转换</li>
</ul>
<ol start="2">
<li>非二进制串是个字符序列。字符集决定了哪些字符可以用以及如何解释；每个字符集都有一种或多种排序规则</li>
</ol>
<h4 id="字符集支持"><a href="#字符集支持" class="headerlink" title="字符集支持"></a>字符集支持</h4><p>默认字符集是latin1，但环境变量$LANG或$LC_ALL会被mysql检测到并进行相应的调整。（博主注：Ubuntu选择中国语言时会自动置LANG=’zh_CN.UTF-8’）</p>
<p>有两种记法可将某个字符串常量强制解释为某种指定的字符集</p>
<ol>
<li><code>_utf8 &#39;str&#39;</code></li>
<li>`N’str’</li>
</ol>
<h4 id="字符串的长度如何定义"><a href="#字符串的长度如何定义" class="headerlink" title="字符串的长度如何定义"></a>字符串的长度如何定义</h4><ol>
<li>LENGTH()测量字节数</li>
<li>CHAR_LENGTH()测量字符数</li>
</ol>
<h4 id="3-1-2-2-字符集相关的系统变量"><a href="#3-1-2-2-字符集相关的系统变量" class="headerlink" title="3.1.2.2 字符集相关的系统变量"></a>3.1.2.2 字符集相关的系统变量</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;character\_set\_%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;collation\_%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>直接修改这些变量并不方便，建议修改方式</p>
<ol>
<li><code>SET NAME &#39;utf8&#39;;</code></li>
<li>命令行选项–default-character-set</li>
<li>环境变量LANG或LC_ALL</li>
</ol>
<h3 id="3-1-3-日期与时间"><a href="#3-1-3-日期与时间" class="headerlink" title="3.1.3 日期与时间"></a>3.1.3 日期与时间</h3><p>ISO8601格式：<code>2008-12-31T12:00:00.123456</code></p>
<p>函数DATE_FORMAT()用于改变日期的显示格式；函数STR_TO_DATE()用于转换日期的输入格式</p>
<h3 id="3-1-4-空间值"><a href="#3-1-4-空间值" class="headerlink" title="3.1.4 空间值"></a>3.1.4 空间值</h3><p>OpenGIS规范：<code>SET @pt = POINTFROMTEXT(&#39;POINT(10 20)&#39;);</code></p>
<h3 id="3-1-5-布尔值"><a href="#3-1-5-布尔值" class="headerlink" title="3.1.5 布尔值"></a>3.1.5 布尔值</h3><p>零为假，任何非零、非NULL的值为真</p>
<h3 id="3-1-6-NULL值"><a href="#3-1-6-NULL值" class="headerlink" title="3.1.6 NULL值"></a>3.1.6 NULL值</h3><p>NULL没有类型，以NULL为参数传递给运算符与函数，大多会返回NULL</p>
<h2 id="3-2-MySQL数据类型"><a href="#3-2-MySQL数据类型" class="headerlink" title="3.2 MySQL数据类型"></a>3.2 MySQL数据类型</h2><p><strong>本章未读完</strong></p>
<h1 id="ch10-MYSQL管理简介"><a href="#ch10-MYSQL管理简介" class="headerlink" title="ch10 MYSQL管理简介"></a>ch10 MYSQL管理简介</h1><p>每一项任务都很重要，但不需要立刻把它们全部学会。可以把本书作为参考，需要时再回头查询</p>
<p><strong>本章未读完</strong></p>
<p>接下来的几章将对这些概要进行详细讨论</p>
<h1 id="ch11-MySQL数据目录"><a href="#ch11-MySQL数据目录" class="headerlink" title="ch11 MySQL数据目录"></a>ch11 MySQL数据目录</h1><p>本书假定Unix用户名和组名都是mysql</p>
<h2 id="11-1-数据目录位置"><a href="#11-1-数据目录位置" class="headerlink" title="11.1 数据目录位置"></a>11.1 数据目录位置</h2><ul>
<li>通过源码安装时，数据目录默认为/usr/local/mysql/data。可在运行CMake时用选项修改数据目录</li>
<li>通过RPM包安装时，数据目录默认为/var/lib/mysql。（博主注：在Ubuntu用apt安装也一样）</li>
<li>在Windows系统里，默认数据目录取决于Windows版本</li>
</ul>
<p>想知道服务器的数据目录在什么地方，可以使用</p>
<ol>
<li>mysqladmin variables | grep datadir</li>
<li>SHOW VARIABLES LIKE ‘datadir’;</li>
</ol>
<p><strong>本章未读完</strong></p>
<h2 id="以上为《mysql技术内幕》读书笔记，查询语句为MySQL语法"><a href="#以上为《mysql技术内幕》读书笔记，查询语句为MySQL语法" class="headerlink" title="以上为《mysql技术内幕》读书笔记，查询语句为MySQL语法"></a>以上为《mysql技术内幕》读书笔记，查询语句为MySQL语法</h2><p>以下为《数据库系统概念》读书笔记，查询语句为sql标准语法</p>
<h1 id="ch04-中级SQL"><a href="#ch04-中级SQL" class="headerlink" title="ch04 中级SQL"></a>ch04 中级SQL</h1><h2 id="4-1-连接表达式"><a href="#4-1-连接表达式" class="headerlink" title="4.1 连接表达式"></a>4.1 连接表达式</h2><h3 id="4-1-1-连接条件"><a href="#4-1-1-连接条件" class="headerlink" title="4.1.1 连接条件"></a>4.1.1 连接条件</h3><ol>
<li>join … using 子句只需要在指定的属性上的取值匹配</li>
<li>on 条件允许在参与连接的关系上设置通用的谓词</li>
</ol>
<h3 id="4-1-2-外连接"><a href="#4-1-2-外连接" class="headerlink" title="4.1.2 外连接"></a>4.1.2 外连接</h3><ol>
<li>内连接：不保留未匹配元组</li>
<li>左外连接：只保留出现在左表的元组</li>
<li>右外连接：只保留出现在右表的元组</li>
<li>全外连接：保留出现在两个关系中的元组</li>
</ol>
<p>左外连接用于查询在左表中但不在右表中的元组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id</span><br><span class="line"><span class="keyword">from</span> lhs <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">join</span> rhs</span><br><span class="line"><span class="keyword">where</span> rhs.col <span class="keyword">is</span> <span class="keyword">null</span> ;</span><br></pre></td></tr></table></figure>
<p>在外连接中使用on与where不同，on条件是外连接声明的一部分；不满足on后面条件的元组也会被加入连接结果，只不过有一边的属性会被赋为空值</p>
<p>natural是using(同名列)的语法糖，using是on等值比较的语法糖，但on<strong>不是</strong>where的语法糖</p>
<h3 id="4-1-3-连接类型和条件"><a href="#4-1-3-连接类型和条件" class="headerlink" title="4.1.3 连接类型和条件"></a>4.1.3 连接类型和条件</h3><ol>
<li>natural、using、on 都是连接条件</li>
<li>inner、left outer、right outer、full outer 都是连接类型。关键词inner是可选的</li>
</ol>
<h2 id="4-2-视图"><a href="#4-2-视图" class="headerlink" title="4.2 视图"></a>4.2 视图</h2><p>出于安全考虑，让所有用户都看到整个逻辑模型是不合适的。</p>
<p>虚关系并<strong>不</strong>预先计算并存储</p>
<p>视图：不是逻辑模型的一部分，但作为虚关系对用户可见的关系</p>
<h3 id="4-1-1-视图定义"><a href="#4-1-1-视图定义" class="headerlink" title="4.1.1 视图定义"></a>4.1.1 视图定义</h3><p><code>create view view_name as &lt; query expression &gt; ;</code></p>
<h3 id="4-1-2-SQL查询中使用视图"><a href="#4-1-2-SQL查询中使用视图" class="headerlink" title="4.1.2 SQL查询中使用视图"></a>4.1.2 SQL查询中使用视图</h3><p>如果在视图定义中使用了聚集函数，可以显式指定列名，例如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> dept_total_salary( dept_name, total_salary ) <span class="keyword">AS</span></span><br><span class="line">	<span class="keyword">SELECT</span> dept_name, <span class="built_in">SUM</span>( salary )</span><br><span class="line">	<span class="keyword">FROM</span> instructor</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> dept_name;</span><br></pre></td></tr></table></figure>
<p>定以后的视图名可以出现在任何允许出现关系名的地方</p>
<h3 id="4-1-3-物化视图"><a href="#4-1-3-物化视图" class="headerlink" title="4.1.3 物化视图"></a>4.1.3 物化视图</h3><p>频繁使用视图的应用将从视图的物化中获益。那些需要快速响应聚集计算的查询也会从物化视图中受益。</p>
<p>SQL没有定义指定物化视图的标准方式。某些数据库系统允许DBA控制每个物化视图采用定期维护还是触发维护。</p>
<h3 id="4-1-4-视图更新"><a href="#4-1-4-视图更新" class="headerlink" title="4.1.4 视图更新"></a>4.1.4 视图更新</h3><p>视图一般只读不可写</p>
<p>可更新的视图需要满足的4个条件</p>
<p>即使满足这些条件，向视图中插入一条不满足视图的where子句的数据也会带来麻烦。</p>
<h2 id="4-3-事务"><a href="#4-3-事务" class="headerlink" title="4.3 事务"></a>4.3 事务</h2><p>ch14学习事务的更多特性；ch15和ch16介绍在单个数据库中实现事务的相关问题，ch19介绍跨多个数据库上实现事务的相关问题。</p>
<h2 id="4-4-完整性约束"><a href="#4-4-完整性约束" class="headerlink" title="4.4 完整性约束"></a>4.4 完整性约束</h2><p>大多数数据库系统允许用户指定那些只需极小开销就可以检测的完整性约束</p>
<h3 id="4-4-1-单个关系上的约束"><a href="#4-4-1-单个关系上的约束" class="headerlink" title="4.4.1 单个关系上的约束"></a>4.4.1 单个关系上的约束</h3><ol>
<li>not null</li>
<li>unique</li>
<li>check &lt;谓词&gt;</li>
</ol>
<h3 id="4-4-2-主码隐式not-null"><a href="#4-4-2-主码隐式not-null" class="headerlink" title="4.4.2 主码隐式not null"></a>4.4.2 主码隐式not null</h3><h3 id="4-4-3-unique-c1-c2…cn-声明指出了候选码"><a href="#4-4-3-unique-c1-c2…cn-声明指出了候选码" class="headerlink" title="4.4.3 unique(c1,c2…cn)声明指出了候选码"></a>4.4.3 unique(c1,c2…cn)声明指出了候选码</h3><p>除非显式声明，候选码属性可以为null；这是因为空值不等于其他的任何值</p>
<h3 id="4-4-4-check实际上创建了一个强大的类型系统"><a href="#4-4-4-check实际上创建了一个强大的类型系统" class="headerlink" title="4.4.4 check实际上创建了一个强大的类型系统"></a>4.4.4 check实际上创建了一个强大的类型系统</h3><p>`check (semester in (‘Autumn’,’Winter’,’Spring’,’Summer’))</p>
<h3 id="4-4-5-参照完整性"><a href="#4-4-5-参照完整性" class="headerlink" title="4.4.5 参照完整性"></a>4.4.5 参照完整性</h3><p>当违反参照完整性约束时，通常回滚。但可以在foreign key子句中指明以下动作</p>
<ol>
<li>cascade：级联</li>
<li>set null：将参照域（dept_name）置为null</li>
<li>set default：将参照域（dept_name）置为默认值<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course</span><br><span class="line">(...</span><br><span class="line">	<span class="keyword">foreign</span> key (dept_name) <span class="keyword">references</span> department</span><br><span class="line">		[<span class="keyword">on</span> <span class="keyword">delete</span> cascade] <span class="comment">--级联删除</span></span><br><span class="line">		[<span class="keyword">on</span> update cascade]</span><br><span class="line">...);</span><br></pre></td></tr></table></figure>
如果一个关系的foreign key约束所参照的关系就是它自己，级联操作可能无法恢复完整性约束<h3 id="4-4-6-在事务中暂时违反完整性约束"><a href="#4-4-6-在事务中暂时违反完整性约束" class="headerlink" title="4.4.6 在事务中暂时违反完整性约束"></a>4.4.6 在事务中暂时违反完整性约束</h3>在事务中，默认立即检查约束，而且许多数据库实现不支持延迟约束检查。</li>
</ol>
<p>SQL标准允许用initially deferred把完整性约束的检查推迟到事务结束时。</p>
<p>例如，民政局需要插入Mary和John并将他们登记为夫妻，无论先插入哪个元组都会暂时违反外码约束。允许配偶属性为null可以避开这个问题。</p>
<h3 id="4-4-7-复杂check条件与断言"><a href="#4-4-7-复杂check条件与断言" class="headerlink" title="4.4.7 复杂check条件与断言"></a>4.4.7 复杂check条件与断言</h3><p>开小很大。如果数据库不支持，可以用触发器来实现等价的功能</p>
<h2 id="4-5-SQL的数据类型与模式"><a href="#4-5-SQL的数据类型与模式" class="headerlink" title="4.5 SQL的数据类型与模式"></a>4.5 SQL的数据类型与模式</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/21/mysql-ji-shu-nei-mu/" data-id="cl310rf3p000wgctk0bnsahgd" data-title="《mysql技术内幕》读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ubuntu-linux-os" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/19/ubuntu-linux-os/" class="article-date">
  <time class="dt-published" datetime="2021-07-19T09:00:31.000Z" itemprop="datePublished">2021-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/19/ubuntu-linux-os/">Ubuntu相关读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="《完美应用Ubuntu》读书笔记"><a href="#《完美应用Ubuntu》读书笔记" class="headerlink" title="《完美应用Ubuntu》读书笔记"></a>《完美应用Ubuntu》读书笔记</h2><h1 id="ch06-Ubuntu软件包和存储管理"><a href="#ch06-Ubuntu软件包和存储管理" class="headerlink" title="ch06 Ubuntu软件包和存储管理"></a>ch06 Ubuntu软件包和存储管理</h1><p>软件包格式：Red Hat为RPM格式，Debian为DEB格式。<br>DEB在丰富程度和易用性上略高RPM一筹</p>
<h2 id="6-1-深入了解Ubuntu软件包格式"><a href="#6-1-深入了解Ubuntu软件包格式" class="headerlink" title="6.1 深入了解Ubuntu软件包格式"></a>6.1 深入了解Ubuntu软件包格式</h2><p>RPM和DEB二者都有二进制和源码两种格式，例如DEB软件包分为</p>
<ol>
<li>二进制软件包：扩展名为deb的二进制文件</li>
<li>源码软件包：通常包含</li>
</ol>
<ul>
<li>源码描述文件.dsc</li>
<li>源码包文件.orig.tar.gz</li>
<li>源码包补丁文件.diff.gz</li>
</ul>
<p>DEB软件包之间常见的依赖关系</p>
<ol>
<li>Depends：依赖</li>
<li>Conflicts：不能共存</li>
<li>Recommend：推荐安装</li>
</ol>
<p>Ubuntu16.04起支持SNAP软件包，优势是不存在复杂的依赖关系并且与操作系统隔离，更加安全</p>
<p>软件包管理程序大致可以分为</p>
<ol>
<li>前端（由新到旧）：Ubuntu Software、Ubuntu软件中心（USC）、新立得（Synaptic）</li>
<li>后端：dpkg、<a href="#3-5">tasksel</a>、aptitude、apt-cache/apt-get</li>
</ol>
<h2 id="6-2-使用软件包管理程序"><a href="#6-2-使用软件包管理程序" class="headerlink" title="6.2 使用软件包管理程序"></a>6.2 使用软件包管理程序</h2><p>对于由多个软件包构成的应用程序，它可以自动解决软件包的依赖关系</p>
<h2 id="6-3-软件源管理"><a href="#6-3-软件源管理" class="headerlink" title="6.3 软件源管理"></a>6.3 软件源管理</h2><p>Ubuntu软件仓库类似于应用商店，又称为软件源</p>
<p>默认情况下，第三方的非开源应用无法包含在Ubuntu默认的软件源；但如果这些应用很常用怎么办？Canonical合作伙伴专门解决这个问题，但默认不开启。开启方法：软件和更新 -&gt; 其他软件 -&gt; Canonical Parthners -&gt; Yes</p>
<p>不能把Debian的软件源设置给Ubuntu系统；Ubuntu与其<a href="#Ubuntu%E9%9D%9E%E6%AD%A3%E5%BC%8F%E7%9A%84%E8%A1%8D%E7%94%9F%E7%89%88%E6%9C%AC">非官方衍生版本</a>MINT和Elementary的软件源不通用；</p>
<p>PPA软件仓库是第三方开发者的在线打包和发布软件仓库，可视为扩展和补充，更新及时但稍欠稳妥。<br>命令行下，可以使用add-apt-repository命令添加PPA软件仓库。</p>
<h2 id="6-4-Ubuntu软件包后端管理工具"><a href="#6-4-Ubuntu软件包后端管理工具" class="headerlink" title="6.4 Ubuntu软件包后端管理工具"></a>6.4 Ubuntu软件包后端管理工具</h2><p>apt-get和aptitude可以调用dpkg</p>
<p>本书默认采用Guake终端运行命令行</p>
<h3 id="6-4-1-后端的最底层——dpkg"><a href="#6-4-1-后端的最底层——dpkg" class="headerlink" title="6.4.1 后端的最底层——dpkg"></a>6.4.1 后端的最底层——dpkg</h3><p>不建议直接用<code>sudo dpkg -i name.deb</code>安装，因为它无法自动解决软件包复杂的依赖关系</p>
<h3 id="6-4-2-后端自动化管理"><a href="#6-4-2-后端自动化管理" class="headerlink" title="6.4.2 后端自动化管理"></a>6.4.2 后端自动化管理</h3><p>aptitude、apt-cache/apt-get都能自动解决依赖关系；至于tasksel，则是一次安装一组软件包，适合安装桌面环境这种庞大的程序</p>
<p><strong>本章未读完</strong></p>
<h2 id="16-3-部署和配置Nginx-Web服务器"><a href="#16-3-部署和配置Nginx-Web服务器" class="headerlink" title="16.3 部署和配置Nginx Web服务器"></a>16.3 部署和配置Nginx Web服务器</h2><h3 id="16-3-1-部署Nginx-Web服务器"><a href="#16-3-1-部署Nginx-Web服务器" class="headerlink" title="16.3.1 部署Nginx Web服务器"></a>16.3.1 部署Nginx Web服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y nginx</span><br><span class="line">sudo systemctl start nginx</span><br><span class="line">sudo lsof -i:80</span><br></pre></td></tr></table></figure>
<h3 id="16-3-2-深入Nginx-Web配置目录"><a href="#16-3-2-深入Nginx-Web配置目录" class="headerlink" title="16.3.2 深入Nginx Web配置目录"></a>16.3.2 深入Nginx Web配置目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo echo</span><br><span class="line">cd /stc/nginx</span><br><span class="line">ll</span><br><span class="line">grep &#x27;include /etc/nginx&#x27; nginx.conf</span><br><span class="line">ls conf.d</span><br><span class="line">ls sites-*</span><br><span class="line">cat fastcgi* | less</span><br></pre></td></tr></table></figure>
<h3 id="16-3-2-配置Nginx-Web服务器"><a href="#16-3-2-配置Nginx-Web服务器" class="headerlink" title="16.3.2 配置Nginx Web服务器"></a>16.3.2 配置Nginx Web服务器</h3><p>nginx.conf 的默认内容注解。一般应用环境通常采用默认值即可</p>
<p>sites-enabled/default 的默认内容注解。文件末尾以注释形式给出了虚拟主机的配置模板</p>
<p>定制实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name ubuntu.com;</span><br><span class="line">        root &#x2F;var&#x2F;www&#x2F;ubuntucom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-3-4-全面管理Nginx-Web服务器"><a href="#16-3-4-全面管理Nginx-Web服务器" class="headerlink" title="16.3.4 全面管理Nginx Web服务器"></a>16.3.4 全面管理Nginx Web服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop nginx</span><br><span class="line">sudo systemctl restart nginx</span><br><span class="line">sudo systemctl enable nginx	#随系统自启动</span><br><span class="line">sudo systemctl disable nginx</span><br></pre></td></tr></table></figure>
<h2 id="16-3节已读完"><a href="#16-3节已读完" class="headerlink" title="16.3节已读完"></a>16.3节已读完</h2><h2 id="《Ubuntu-linux操作系统》读书笔记"><a href="#《Ubuntu-linux操作系统》读书笔记" class="headerlink" title="《Ubuntu linux操作系统》读书笔记"></a>《Ubuntu linux操作系统》读书笔记</h2><h2 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h2><p>本书主要讲解Ubuntu的配置管理、桌面应用、编程和软件开发。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>前两章是基础部分，讲解Linux基本知识、Ubuntu Linux的安装、图形界面与命令行的基本操作。</li>
<li>第3章至第7章介绍各类系统配置管理，涉及用户与组、文件与目录、磁盘存储、软件包安装，以及进程、系统启动、服务、任务调度和系统日志等高级管理，这些都是Ubuntu Linux系统管理员、操作员和程序开发人员等需要掌握的基本技能。</li>
<li>第8章简单介绍了桌面应用软件的功能特性和基本使用，Ubuntu Linux已被许多用户用来进行编程和软件开发。</li>
<li>第9章讲解最基本的Linux编程——Shell编程，编写Shell脚本也属于高级系统管理内容，这对于管理员来说非常必要。</li>
<li>第10章至第12章讲解软件开发，涉及C/C++、Java、Android和PHP等应用程序，重点不是如何编写程序，而是在Ubuntu Linux系统中如何部署和使用软件开发环境，让读者掌握基本的应用开发流程。</li>
<li>Web应用一般需要部署到网络服务器，最后一章还介绍了LAMP平台和Ubuntu Linux服务器版</li>
</ol>
<h1 id="ch01"><a href="#ch01" class="headerlink" title="ch01"></a>ch01</h1><h2 id="1-1-Linux与Ubuntu"><a href="#1-1-Linux与Ubuntu" class="headerlink" title="1.1 Linux与Ubuntu"></a>1.1 Linux与Ubuntu</h2><p>从技术角度看，Linux是一个内核。内核指的是一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件。一个内核不是一套完整的操作系统。一套基于Linux内核的完整操作系统称为Linux操作系统</p>
<ol>
<li>Red Hat Linux是商业上运作最成功的一个Linux发行套件，普及程度很高，由Red Hat公司发行。Red Hat Linux中的RPM软件包格式可以说是Linux社区的一个事实标准，被广泛使用于其他Linux发行套件中。目前RedHat分为两个系列：</li>
</ol>
<ul>
<li>一个是Red Hat Enterprise Linux （简称RHEL），Red Hat提供收费技术支持和更新，适合服务器用户；</li>
<li>另一个是Fedora（第7版以前为Fedora Core），它的定位是桌面用户，Fedora是Red Hat公司新技术的实验场，许多新的技术都会在Fedora Core中检验，如果稳定则会考虑加入Red Hat Enterprise Linux中。Fedora预计每年发行2～3次的发行版本。</li>
</ul>
<ol>
<li>值得一提的是CentOS（Community Enterprise Operating System）是RHEL源代码再编译的免费版，它继承了Red Hat Linux的稳定性，而且又提供免费更新。2014年1月8日CentOS宣布加入Red Hat公司，承诺继续免费。</li>
<li>SUSE（读音为[ˈsuːsə]）是欧洲大陆最流行的Linux版本，也是目前历史最久的商业发行版之一，起源于德国，后被Novell收购。主要版本有：SUSE Linux，针对个人用户，可以免费下载；另一个SUSE Linux Enterprise Server（SLES）是基于企业服务器端的。如果需要使用数据库高级服务和电子邮件网络应用，则可以考虑选用SUSE。</li>
<li>Debian（读音为[ˈdɛ.bi.ən]）是迄今为止完全遵循GNU规范的Linux系统。Ubuntu是Debian的一个改版，也是现在最流行的Linux桌面系统。下面将重点介绍这两个发行版本。</li>
</ol>
<h3 id="1-1-5-后来居上的Ubuntu-Linux"><a href="#1-1-5-后来居上的Ubuntu-Linux" class="headerlink" title="1.1.5 后来居上的Ubuntu Linux"></a>1.1.5 后来居上的Ubuntu Linux</h3><p>发作oo-boon-too的音，国际音标为[uːˈbuːntuː]。中文音译为“乌班图”。Ubuntu基于Debian发行版，与Debian的不同在于它每6个月会发布一个新版本。1. Ubuntu的父版本——Debian</p>
<p>Ubuntu每半年发行一个新的版本，版本号由发布年月组成。例如第一个版本，4.10代表是在2004年10月发行的。Ubuntu会发行长期支持版本（简称LTS），更新维护的时间比较长，大约两年会推出一个正式的大改版版本。<br>自Ubuntu 12.04 LTS开始，桌面版和服务器版均可获得为期5年的技术支持。</p>
<h5 id="Ubuntu衍生版本："><a href="#Ubuntu衍生版本：" class="headerlink" title="Ubuntu衍生版本："></a>Ubuntu衍生版本：</h5><ol>
<li>Ubuntu Server Edition：现与桌面版同步发行，可用作多种服务器。与桌面版本相比，服务器版的光盘映像较小，运行时对硬件要求较低，最少需要500MB硬盘空间和64MB内存。服务器版通常不提供任何桌面环境。</li>
<li>Kubuntu：使用和Ubuntu一样的软件库，但不采用GNOME，而是采用KDE作为默认的桌面环境，以满足偏爱KDE的Ubuntu用户。</li>
<li>Edubuntu：是为教育量身定做的发行版，包含很多教育软件，可以帮助教师方便地搭建网络学习环境，管理电子教室。</li>
<li>Xubuntu：属于轻量级的发行版，使用Xfce4作为默认桌面环境，与Ubuntu采用一样的软件库。</li>
<li>Ubuntu Studio：适合于音频、视频和图像设计的版本，使用Xfce4作为默认的桌面环境。</li>
<li>Ubuntu JeOS：一个高度精简的、专门面向虚拟化应用的版本。</li>
<li>Ubuntu Kylin（优麒麟）：语言的默认设置为中文，为中国用户专门定制。</li>
</ol>
<h5 id="Ubuntu非正式的衍生版本"><a href="#Ubuntu非正式的衍生版本" class="headerlink" title="Ubuntu非正式的衍生版本"></a>Ubuntu非正式的衍生版本</h5><ul>
<li>Ubuntu（专注于安全工具）、Ubuntu Lite（针对旧电脑）、Dubuntu（由中国爱好者开发的Ubuntu改进版）等。</li>
<li>除了桌面版和服务器版之外，Canonical公司还针对其他平台发布Ubuntu版本，如Ubuntu for Android用于Android手机的版本，Ubuntu Touch是基于Ubuntu和Android的手机/平板操作系统，Ubuntu TV是用于智能电视的版本。</li>
</ul>
<p>目前全世界桌面操作系统市场约有5%由Linux家族所占据，其中约有一半为Ubuntu。</p>
<h2 id="1-2-安装Ubuntu操作系统"><a href="#1-2-安装Ubuntu操作系统" class="headerlink" title="1.2 安装Ubuntu操作系统"></a>1.2 安装Ubuntu操作系统</h2><p>Linux使用设备名称加分区编号来标明分区。</p>
<ol>
<li>SCSI磁盘、SATA磁盘（串口硬盘）均可表示为“sd”，并且在“sd”之后使用小写字母表示磁盘编号，磁盘编号之后是分区编号，使用阿拉伯数字表示。</li>
<li>IDE磁盘使用“hd”表示，表示方法同SCSI磁盘。</li>
</ol>
<p>Ubuntu支持在一台计算机中安装多个操作系统，可以通过使用GRUB多重启动管理器来引导Windows等操作系统。</p>
<h2 id="1-3-熟悉Ubuntu桌面环境"><a href="#1-3-熟悉Ubuntu桌面环境" class="headerlink" title="1.3 熟悉Ubuntu桌面环境"></a>1.3 熟悉Ubuntu桌面环境</h2><p>可选择“挂起”命令，让系统暂时进入休眠（待机）状态。</p>
<p>默认的显示分辨率为800像素×600像素，一般不能满足实际需要。首先就要修改屏幕分辨率，打开“系统设置”界面，单击“硬件”区域的“显示”</p>
<p>有些软件包安装不成功，会遇到“下载软件包文件失败”“下载软件仓库信息失败”一类的提示，这主要是软件源的问题，解决的办法是变更软件源。</p>
<h6 id="打开“系统设置”界面，单击“系统”区域的“软件和更新”按钮打开如图1-38所示的界面，从“下载自”下拉列表中选择所需的软件源。如果选择“其他站点”，将打开如图1-39所示的对话框，从列表中选择一个下载服务器作为软件源，或者直接单击“选择最佳服务器”（这种情况由于要测试速度，可能要耗费较长时间）。"><a href="#打开“系统设置”界面，单击“系统”区域的“软件和更新”按钮打开如图1-38所示的界面，从“下载自”下拉列表中选择所需的软件源。如果选择“其他站点”，将打开如图1-39所示的对话框，从列表中选择一个下载服务器作为软件源，或者直接单击“选择最佳服务器”（这种情况由于要测试速度，可能要耗费较长时间）。" class="headerlink" title="打开“系统设置”界面，单击“系统”区域的“软件和更新”按钮打开如图1-38所示的界面，从“下载自”下拉列表中选择所需的软件源。如果选择“其他站点”，将打开如图1-39所示的对话框，从列表中选择一个下载服务器作为软件源，或者直接单击“选择最佳服务器”（这种情况由于要测试速度，可能要耗费较长时间）。"></a>打开“系统设置”界面，单击“系统”区域的“软件和更新”按钮打开如图1-38所示的界面，从“下载自”下拉列表中选择所需的软件源。如果选择“其他站点”，将打开如图1-39所示的对话框，从列表中选择一个下载服务器作为软件源，或者直接单击“选择最佳服务器”（这种情况由于要测试速度，可能要耗费较长时间）。</h6><h1 id="ch03"><a href="#ch03" class="headerlink" title="ch03"></a>ch03</h1><h2 id="3-3-使用命令行工具管理用户和组"><a href="#3-3-使用命令行工具管理用户和组" class="headerlink" title="3.3 使用命令行工具管理用户和组"></a>3.3 使用命令行工具管理用户和组</h2><p>查看全部用户列表，可以考虑使用<code>awk -F&#39;:&#39; &#39;&#123; print $1&#125;&#39; /etc/passwd</code></p>
<p>添加一个管理员的语法格式<br><code>adduser --system [--home 用户主文件夹] [--shell SHELL] [--no-create-home （无主文 件夹）] [--uid 用户 ID] [--gecos GECOS] [--group | --ingroup 用户组 | --gid 组 ID] [--disabled-password（禁用密码）] [--disabled-login （禁止登录）] 用户名</code></p>
<p>useradd [选项] 该命令的选项较多。例如</p>
<ol>
<li>-d用于指定用户主目录；</li>
<li>-g用于指定该用户所属主要组（名称或ID均可）；</li>
<li>-G用于指定用户所属其他组列表，各组之间用逗号分隔；</li>
<li>-r指定创建一个系统账户，建立系统账户时不会建立主目录，其UID也会有限制；</li>
<li>-s指定用户登录时所使用的Shell，默认为/bin/bash；</li>
<li>-u指定新用户的UID。</li>
</ol>
<p>对于没有指定上述选项的情况，系统将</p>
<ol>
<li>根据etc/default/useradd配置文件中的定义为新建用户账户提供默认值，如是否创建用户私有目录等。</li>
<li>利用/etc/skel/目录为新用户初始化主目录。/etc/skel目录一般是存放用户启动文件的目录，这个目录由root权限控制，当管理员添加用户时，这个目录下的文件自动复制到新添加的用户的家目录下；/etc/skel目录下的文件都是隐藏文件，也就是类似.file格式的；可通过修改、添加、删除/etc/skel目录下的文件，来为用户提供一个统一、标准的、默认的用户环境。</li>
<li>默认情况下创建用户账户的同时也会建立一个与用户名同名的组账户，该组作为用户的主组（默认组）。<br><code>useradd -D</code>用于显示或默认的useradd配置</li>
</ol>
<p>Ubuntu还特别提供一个adduser，该命令执行过程中可提供交互对话</p>
<p>创建用户时如果没有设置密码，账户将处于锁定状态，此时用户账户将无法登录系统。可到/etc/shadow文件中查看，密码部分为！</p>
<p>使用passwd命令为用户设置密码<code>passwd [选项] [用户名]</code> </p>
<ol>
<li>使用带-l选项的passwd命令可锁定账户密码</li>
<li>使用带-u选项的passwd命令可解除锁定</li>
<li>使用带-S选项的passwd命令可查看某账户的当前状态</li>
<li>使用带-d选项的passwd命令可删除密码</li>
</ol>
<p>对于已创建的用户账户，可使用usermod命令来修改其各项属性，包括用户名、主目录、用户组、登录Shell等，用法<code>usermod [选项] 用户名</code>。大部分选项与添加用户所用的useradd命令相同，这里重点介绍几个不同的选项。</p>
<ol>
<li>使用-l选项改变用户账户名。　　usermod -l 新用户名 原用户名</li>
<li>使用-L选项锁定账户，临时禁止该用户登录。　　usermod -L 用户名</li>
<li>如果要解除账户锁定，使用-U选项即可。</li>
</ol>
<p>可以使用命令chfn来更改用户的个人信息，如真实姓名、办公电话等。语法格式如下：<code>chfn [选项] [用户名]</code>。选项-f表示全名（真实姓名），-h表示家庭电话，-o表示办公地址。</p>
<p>要删除账户，可使用userdel命令来实现，其用法如下：<code>userdel [-r] 用户名</code>。如果使用选项-r，则在删除该账户的同时，一并删除该账户对应的主目录和邮件目录。注意userdel不允许删除正在使用（已经登录）的用户账户。另一个用户删除命令deluser在Ubuntu中使用较多。</p>
<p>想查看组列表，可以通过查看组配置文件/etc/group来解决</p>
<p><strong>关于用户组的内容未读完</strong></p>
<h1 id="ch05"><a href="#ch05" class="headerlink" title="ch05"></a>ch05</h1><h2 id="5-1-Linux磁盘存储概述"><a href="#5-1-Linux磁盘存储概述" class="headerlink" title="5.1 Linux磁盘存储概述"></a>5.1 Linux磁盘存储概述</h2><ol>
<li>目前所有硬盘厂商在产品出厂前，已经对硬盘进行了低级格式化处理。低级格式化是物理级的，对硬盘有损伤，影响磁盘寿命。如果硬盘已有物理坏道，则低级格式化会使损伤更严重，加快报废。</li>
<li>平常所说的格式化就是指高级格式化。高级格式化与操作系统有关，不同的操作系统有不同的格式化程序、不同的格式化结果、不同的磁道划分方法。当一个磁盘分区被格式化之后，就可以被称为卷（Volume）</li>
</ol>
<p>在Linux中，设备文件名用字母表示不同的设备接口，例如a表示第1个接口，字母b表示第2个接口，磁盘设备也不例外。</p>
<ol>
<li>IDE硬盘（包括光驱设备）由内部连接来区分，最多可以接4个设备。</li>
</ol>
<ul>
<li>/dev/hda表示第1个IDE通道（IDE1）的主设备（master）</li>
<li>/dev/hdb表示第1个IDE通道的从设备（slave）。</li>
<li>/dev/hdc和/dev/hdd为第2个IDE通道（IDE2）的主设备和从设备。</li>
</ul>
<ol>
<li>原则上SCSI、SAS、SATA、USB接口硬盘的设备文件名均以/dev/sd开头。这些设备命名依赖于设备的ID号码，不考虑遗漏的ID号码。例如，3个SCSI设备的ID号码分别是0、2、5，设备名分别是/dev/sda、/dev/sdb和/dev/sdc。如果再添加一个ID号码为3的设备，则这个设备将被以/dev/sdc来命名，ID号码为5的设备将改称为/dev/sdd。</li>
<li>一般情况SATA硬盘类似SCSI，在Linux中用类似/dev/sda这样的设备名表示。</li>
</ol>
<p>Linux主要使用MBR和GPT两种分区样式。</p>
<ol>
<li>MBR磁盘分区如图5-2所示，最多可支持4个磁盘分区，可通过扩展分区来支持更多的逻辑分区，在Linux中将该分区样式又称为MSDOS。</li>
<li>一个GPT磁盘内最多可以创建128个主分区，不必创建扩展分区或逻辑分区。特别适合大于2TB的硬盘分区。<br>目前还是采用传统的MBR分区的居多</li>
</ol>
<h3 id="磁盘分区命名"><a href="#磁盘分区命名" class="headerlink" title="磁盘分区命名"></a>磁盘分区命名</h3><p>在Linux中，磁盘分区的文件名需要在磁盘设备文件名的基础上加上分区编号。这样，IDE硬盘分区采用/dev/hdxy这样的形式命名，SCSI、SAS、SATA、USB硬盘分区采用/dev/sdxy这样的形式命名，其中x表示设备编号（从a开始），y是分区编号（从1开始）。例如，第一块SCSI硬盘的主分区为sda1，扩展分区为sda2，扩展分区下的一个逻辑分区为sda5（从5开始才用来为逻辑分区命名）。</p>
<p>ext3是Linux操作系统的主流文件系统格式，Linux内核自2.6.28版开始正式支持新的文件系统ext4。作为ext3的改进版，ext4修改了ext3中部分重要的数据结构，提供更佳的性能和可靠性。其主要特点说明如下</p>
<ol>
<li>属于大型文件系统，支持最高1EB（1048576TB）的分区，最大16 TB的单个文件。</li>
<li>向下兼容于ext3与ext2，可将ext3和ext2的文件系统挂载为ext4分区。</li>
<li>引入现代文件系统中流行的Extent文件存储方式，以取代ext2/3使用的块映射（block mapping）方式。Extent为一组连续的数据块，可以增加大型文件的效率。ext4支持单一Extent，在单一块大小为4KB的系统中最高可达128MB。</li>
<li>支持持久预分配，在文件系统层面实现了持久预分配并提供相应的API，比应用软件自己实现更有效率。</li>
<li>能够尽可能地延迟分配磁盘空间，使用一种称为allocate-on-flush的方式，直到文件在缓存中写完才开始分配数据块并写入磁盘，这样就能优化整个文件的数据块分配。</li>
<li>支持无限数量的子目录。</li>
<li>使用日志校验来提高文件系统可靠性。</li>
<li>支持在线磁盘碎片整理。</li>
</ol>
<p>Linux Native和Linux Swap是Linux特有的分区类型。</p>
<ol>
<li>Ubuntu Linux至少需要一个Linux Native分区</li>
<li>Swap分区应该大于或等于物理内存的大小。建议物理内存在2GB以下时，Swap分区的大小为物理内存的2～2.5倍，如果物理内存在2GB以上，则Swap分区的大小设为与物理内存大小相同即可</li>
<li>引导分区不是必需的，如果没有创建引导分区，引导文件就安装在根分区中。</li>
</ol>
<p>fdisk是各种Linux发行版本中最常用的分区工具，使用灵活，简单易用。parted功能更强大，支持的分区类型非常多，而且可以调整原有分区尺寸，只是操作复杂一些。Ubuntu提供一个基于文本窗口界面的分区工具cfdisk，它比fdisk的操作界面更为直观</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/19/ubuntu-linux-os/" data-id="cl310rf3t0012gctk7o26c94j" data-title="Ubuntu相关读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-shell-program-demo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/07/shell-program-demo/" class="article-date">
  <time class="dt-published" datetime="2021-07-07T07:49:58.000Z" itemprop="datePublished">2021-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/07/shell-program-demo/">shell例程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="基本循环"><a href="#基本循环" class="headerlink" title="基本循环"></a>基本循环</h3><p>do while循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">CTR&#x3D;1</span><br><span class="line">while [ $&#123;CTR&#125; -lt 9 ]</span><br><span class="line">do</span><br><span class="line">	echo $&#123;CTR&#125;</span><br><span class="line">	((CTR++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="使用函数和参数"><a href="#使用函数和参数" class="headerlink" title="使用函数和参数"></a>使用函数和参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">function print2() &#123;</span><br><span class="line">	local lhs&#x3D;&quot;$1&quot;</span><br><span class="line">	local rhs&#x3D;&quot;$2&quot;</span><br><span class="line">	echo &quot;$&#123;lhs&#125; $&#123;rhs&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line">print2 &quot;a&quot; &quot;b&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="包含源文件"><a href="#包含源文件" class="headerlink" title="包含源文件"></a>包含源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">source library.sh</span><br></pre></td></tr></table></figure>
<h3 id="检索返回码和输出"><a href="#检索返回码和输出" class="headerlink" title="检索返回码和输出"></a>检索返回码和输出</h3><p>三种方式</p>
<ol>
<li>使用全局变量保存命令的返回码</li>
<li>使用return</li>
<li>通过echo输出，使用子shell获取</li>
</ol>
<h2 id="以上来自《Bash-Cookbook》"><a href="#以上来自《Bash-Cookbook》" class="headerlink" title="以上来自《Bash Cookbook》"></a>以上来自《Bash Cookbook》</h2><p>以下来自《Unix编程环境》</p>
<h2 id="3-8-循环"><a href="#3-8-循环" class="headerlink" title="3.8 循环"></a>3.8 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for i in *</span><br><span class="line">do</span><br><span class="line">	diff -b old&#x2F;$i $i</span><br><span class="line">	echo</span><br><span class="line">done | pr -h &#39;title&#39; | lpr &amp;</span><br><span class="line"></span><br><span class="line">for i in 3 4 5 6; do ln 2 $i; done</span><br><span class="line"></span><br><span class="line">for i in &#96;cat ...&#96;</span><br><span class="line"></span><br><span class="line">for i in &#96;pick *&#96;	#交互式选择文件</span><br><span class="line">do</span><br><span class="line">	echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="5-4-trap：捕获中断"><a href="#5-4-trap：捕获中断" class="headerlink" title="5.4 trap：捕获中断"></a>5.4 trap：捕获中断</h2><p>发出中断信号，后台运行的进程（使用&amp;运行）能得到保护；但如果是挂断信号，则得不到保护。</p>
<p><code>trap 命令序列 信号值列表</code>，命令序列最好用单引号来保护，这样变量仅在trap程序执行时才被赋值</p>
<p>trap调用的命令结束后，程序返回到断点继续执行，除非中断信号终止了它或显式地调用exit</p>
<h1 id="ch04-过滤程序"><a href="#ch04-过滤程序" class="headerlink" title="ch04 过滤程序"></a>ch04 过滤程序</h1><h2 id="4-1-grep家族"><a href="#4-1-grep家族" class="headerlink" title="4.1 grep家族"></a>4.1 grep家族</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -y mary $HOME&#x2F;lib&#x2F;phone-book</span><br><span class="line">ls | grep -v temp</span><br></pre></td></tr></table></figure>
<p>选项-v表示对测试结果求反，-y使得模式中的小写字母与文件中的大小写字母都相匹配</p>
<p>grep的正则表达式不能与换行符匹配，表达式被独立地应用于每一行</p>
<p>egrep附加了圆括号、或操作符、加号和问号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(xy)*</span><br><span class="line">today|tomorrow</span><br><span class="line"></span><br><span class="line">egrep -e &#39;^(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?)(.?).?\9\8\7\6\5\4\3\2\1$&#39; file</span><br><span class="line">#可以查最长为19的回文字符串</span><br></pre></td></tr></table></figure>

<p>fgrep不能解释元字符，但却可有效地并行检索成千上万个单词</p>
<p>egrep和fgrep都接受-f选项表示从指定的文件中读取模式</p>
<h2 id="4-2-其他过滤程序"><a href="#4-2-其他过滤程序" class="headerlink" title="4.2 其他过滤程序"></a>4.2 其他过滤程序</h2><p>sort的选项：-f忽略大小写、-d字典序、-n数值序、-r降序、+m跳过头m个域、-o输出文件、-u删除排序区域中的重复行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort +4f +3n -t &#39;:&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<p>可使用多个排序码</p>
<p>unique的选项：-d只打印重复的行、-u只打印唯一的行、-c对每行的出现进行计数</p>
<p>comm用于文件比较。它打印三列输出：仅在f1中出现的行、仅在f2中出现的行、在两者出现的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tr A-Z a-z		#将大写字母映射成小写字母</span><br><span class="line">tr -sc A-Za-z &#39;\012&#39;	#将非字母字符转换为换行</span><br></pre></td></tr></table></figure>

<p>dd常被用于处理原始的、未格式化的数据</p>
<h2 id="4-3-流编辑程序sed"><a href="#4-3-流编辑程序sed" class="headerlink" title="4.3 流编辑程序sed"></a>4.3 流编辑程序sed</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/07/shell-program-demo/" data-id="cl310rf3s0010gctk7qz837a5" data-title="shell例程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-unix-bian-cheng-yi-shu" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/06/unix-bian-cheng-yi-shu/" class="article-date">
  <time class="dt-published" datetime="2021-07-06T13:27:56.000Z" itemprop="datePublished">2021-07-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/06/unix-bian-cheng-yi-shu/">《UNIX编程艺术》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#ch01-%E5%93%B2%E5%AD%A6">ch01-哲学</a></li>
<li><a href="#ch02-%E5%8E%86%E5%8F%B2%E2%80%94%E2%80%94%E5%8F%8C%E6%B5%81%E8%AE%B0">ch02-历史——双流记</a></li>
<li><a href="#ch03-Unix%E5%93%B2%E5%AD%A6%E5%90%8C%E5%85%B6%E4%BB%96%E5%93%B2%E5%AD%A6%E7%9A%84%E6%AF%94%E8%BE%83">ch03-Unix哲学同其他哲学的比较</a></li>
<li><a href="#ch04-%E6%A8%A1%E5%9D%97%E6%80%A7%EF%BC%9A%E4%BF%9D%E6%8C%81%E6%B8%85%E6%99%B0%EF%BC%8C%E4%BF%9D%E6%8C%81%E7%AE%80%E6%B4%81">ch04-模块性：保持清晰，保持简洁</a></li>
<li><a href="#ch05-%E6%96%87%E6%9C%AC%E5%8C%96%EF%BC%9A%E5%A5%BD%E5%8D%8F%E8%AE%AE%E4%BA%A7%E7%94%9F%E5%A5%BD%E5%AE%9E%E8%B7%B5">ch05-文本化：好协议产生好实践</a></li>
<li><a href="#ch06-%E9%80%8F%E6%98%8E%E6%80%A7%EF%BC%9A%E6%9D%A5%E7%82%B9%E5%84%BF%E5%85%89">ch06-透明性：来点儿光</a></li>
<li><a href="#ch07-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%88%86%E7%A6%BB%E8%BF%9B%E7%A8%8B%E4%B8%BA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%8A%9F%E8%83%BD">ch07-多道程序设计：分离进程为独立的功能</a></li>
<li><a href="#ch08-%E5%BE%AE%E5%9E%8B%E8%AF%AD%E8%A8%80">ch08-微型语言</a></li>
<li><a href="#ch09-%E7%94%9F%E6%88%90%EF%BC%9A%E6%8F%90%E5%8D%87%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E%E7%9A%84%E5%B1%82%E6%AC%A1">ch09-生成：提升规格说明的层次</a></li>
<li><a href="#ch10-%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%BF%88%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5">ch10-配置：迈出正确的第一步</a></li>
<li><a href="#ch11-%E6%8E%A5%E5%8F%A3%EF%BC%9AUnix%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">ch11-接口：Unix环境下的用户接口设计模式</a></li>
<li><a href="#ch12-%E4%BC%98%E5%8C%96">ch12-优化</a></li>
<li><a href="#ch13-%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BD%86%E5%88%AB%E7%AE%80%E5%8D%95%E8%BF%87%E4%BA%86%E5%A4%B4">ch13-复杂度：尽可能简单，但别简单过了头</a></li>
</ul>
<h1 id="译序"><a href="#译序" class="headerlink" title="译序"></a>译序</h1><p>本书总结了历史上Unix众多成功的经验和失败的教训。</p>
<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本书分为四部分：场景、设计、工具和社群</p>
<h1 id="ch01-哲学"><a href="#ch01-哲学" class="headerlink" title="ch01 哲学"></a>ch01 哲学</h1><h2 id="1-1-文化？什么文化"><a href="#1-1-文化？什么文化" class="headerlink" title="1.1 文化？什么文化"></a>1.1 文化？什么文化</h2><p>有些不成文的行业素养具有与标准手册及教科书同等重要的地位</p>
<h2 id="1-2-Unix的生命力"><a href="#1-2-Unix的生命力" class="headerlink" title="1.2 Unix的生命力"></a>1.2 Unix的生命力</h2><p>语言、系统调用、工具用法——它们积年不变</p>
<h2 id="1-3-反对学习Unix文化的理由"><a href="#1-3-反对学习Unix文化的理由" class="headerlink" title="1.3 反对学习Unix文化的理由"></a>1.3 反对学习Unix文化的理由</h2><p>通用性受到怀疑</p>
<h2 id="1-4-Unix之失"><a href="#1-4-Unix之失" class="headerlink" title="1.4 Unix之失"></a>1.4 Unix之失</h2><p>“只提供机制，不提供策略”令非技术型的终端用户晕头转向</p>
<h2 id="1-5-Unix之得"><a href="#1-5-Unix之得" class="headerlink" title="1.5 Unix之得"></a>1.5 Unix之得</h2><h3 id="1-5-1-开源软件"><a href="#1-5-1-开源软件" class="headerlink" title="1.5.1 开源软件"></a>1.5.1 开源软件</h3><h3 id="1-5-2-跨平台可移植性和开放标准"><a href="#1-5-2-跨平台可移植性和开放标准" class="headerlink" title="1.5.2 跨平台可移植性和开放标准"></a>1.5.2 跨平台可移植性和开放标准</h3><h3 id="1-5-3-Internet和万维网"><a href="#1-5-3-Internet和万维网" class="headerlink" title="1.5.3 Internet和万维网"></a>1.5.3 Internet和万维网</h3><h3 id="1-5-4-开源社区"><a href="#1-5-4-开源社区" class="headerlink" title="1.5.4 开源社区"></a>1.5.4 开源社区</h3><h3 id="1-5-5-从头到脚的灵活性"><a href="#1-5-5-从头到脚的灵活性" class="headerlink" title="1.5.5 从头到脚的灵活性"></a>1.5.5 从头到脚的灵活性</h3><h3 id="1-5-6-Unix-Hack之趣"><a href="#1-5-6-Unix-Hack之趣" class="headerlink" title="1.5.6 Unix Hack之趣"></a>1.5.6 Unix Hack之趣</h3><h3 id="1-5-7-Unix的经验别处也可适用"><a href="#1-5-7-Unix的经验别处也可适用" class="headerlink" title="1.5.7 Unix的经验别处也可适用"></a>1.5.7 Unix的经验别处也可适用</h3><h2 id="1-6-Unix哲学基础"><a href="#1-6-Unix哲学基础" class="headerlink" title="1.6 Unix哲学基础"></a>1.6 Unix哲学基础</h2><p>Unix哲学是自下而上的</p>
<p>管道的发明人总结道：一个程序只做一件事，并做好。程序要能协作。程序要能处理文本流，因为这是最通用的接口。</p>
<h3 id="1-6-1-模块原则：使用简洁的接口拼合简单的部件"><a href="#1-6-1-模块原则：使用简洁的接口拼合简单的部件" class="headerlink" title="1.6.1 模块原则：使用简洁的接口拼合简单的部件"></a>1.6.1 模块原则：使用简洁的接口拼合简单的部件</h3><h3 id="1-6-2-清晰原则：尽量使用简单的算法配合简单的数据结构"><a href="#1-6-2-清晰原则：尽量使用简单的算法配合简单的数据结构" class="headerlink" title="1.6.2 清晰原则：尽量使用简单的算法配合简单的数据结构"></a>1.6.2 清晰原则：尽量使用简单的算法配合简单的数据结构</h3><h3 id="1-6-3-组合原则：以一点点格式解析的代价，换得可以使用通用工具来构造或解读数据流"><a href="#1-6-3-组合原则：以一点点格式解析的代价，换得可以使用通用工具来构造或解读数据流" class="headerlink" title="1.6.3 组合原则：以一点点格式解析的代价，换得可以使用通用工具来构造或解读数据流"></a>1.6.3 组合原则：以一点点格式解析的代价，换得可以使用通用工具来构造或解读数据流</h3><h3 id="1-6-4-分离原则：策略同机制分离，接口同引擎分离"><a href="#1-6-4-分离原则：策略同机制分离，接口同引擎分离" class="headerlink" title="1.6.4 分离原则：策略同机制分离，接口同引擎分离"></a>1.6.4 分离原则：策略同机制分离，接口同引擎分离</h3><h3 id="1-6-5-简洁原则：将程序系统分解为几个能够协作的小部分"><a href="#1-6-5-简洁原则：将程序系统分解为几个能够协作的小部分" class="headerlink" title="1.6.5 简洁原则：将程序系统分解为几个能够协作的小部分"></a>1.6.5 简洁原则：将程序系统分解为几个能够协作的小部分</h3><h3 id="1-6-6-吝啬原则：除非确无它法，不要编写庞大的程序"><a href="#1-6-6-吝啬原则：除非确无它法，不要编写庞大的程序" class="headerlink" title="1.6.6 吝啬原则：除非确无它法，不要编写庞大的程序"></a>1.6.6 吝啬原则：除非确无它法，不要编写庞大的程序</h3><h3 id="1-6-7-透明性原则"><a href="#1-6-7-透明性原则" class="headerlink" title="1.6.7 透明性原则"></a>1.6.7 透明性原则</h3><ul>
<li>透明性：一眼就能看出软件是在做什么以及怎样做的</li>
<li>显见性：程序带有监视和显示内部状态的功能</li>
</ul>
<h3 id="1-6-8-健壮原则：健壮源于透明与简洁"><a href="#1-6-8-健壮原则：健壮源于透明与简洁" class="headerlink" title="1.6.8 健壮原则：健壮源于透明与简洁"></a>1.6.8 健壮原则：健壮源于透明与简洁</h3><h3 id="1-6-9-表示原则：把知识叠入数据以求逻辑质朴而健壮"><a href="#1-6-9-表示原则：把知识叠入数据以求逻辑质朴而健壮" class="headerlink" title="1.6.9 表示原则：把知识叠入数据以求逻辑质朴而健壮"></a>1.6.9 表示原则：把知识叠入数据以求逻辑质朴而健壮</h3><h3 id="1-6-10-通俗原则：关注目标受众和传统惯例，尽量按照用户最可能熟悉的同样功能接口和相似应用程序来进行建模"><a href="#1-6-10-通俗原则：关注目标受众和传统惯例，尽量按照用户最可能熟悉的同样功能接口和相似应用程序来进行建模" class="headerlink" title="1.6.10 通俗原则：关注目标受众和传统惯例，尽量按照用户最可能熟悉的同样功能接口和相似应用程序来进行建模"></a>1.6.10 通俗原则：关注目标受众和传统惯例，尽量按照用户最可能熟悉的同样功能接口和相似应用程序来进行建模</h3><h3 id="1-6-11-缄默原则：如果一个程序没什么好说的，就保持沉默"><a href="#1-6-11-缄默原则：如果一个程序没什么好说的，就保持沉默" class="headerlink" title="1.6.11 缄默原则：如果一个程序没什么好说的，就保持沉默"></a>1.6.11 缄默原则：如果一个程序没什么好说的，就保持沉默</h3><h3 id="1-6-12-补救原则：出现异常时，马上退出并给出足量错误信息"><a href="#1-6-12-补救原则：出现异常时，马上退出并给出足量错误信息" class="headerlink" title="1.6.12 补救原则：出现异常时，马上退出并给出足量错误信息"></a>1.6.12 补救原则：出现异常时，马上退出并给出足量错误信息</h3><h3 id="1-6-13-经济原则：宁花机器一分，不花程序员一秒"><a href="#1-6-13-经济原则：宁花机器一分，不花程序员一秒" class="headerlink" title="1.6.13 经济原则：宁花机器一分，不花程序员一秒"></a>1.6.13 经济原则：宁花机器一分，不花程序员一秒</h3><h3 id="1-6-14-生成原则：避免手工hack，尽量编写程序去生成程序"><a href="#1-6-14-生成原则：避免手工hack，尽量编写程序去生成程序" class="headerlink" title="1.6.14 生成原则：避免手工hack，尽量编写程序去生成程序"></a>1.6.14 生成原则：避免手工hack，尽量编写程序去生成程序</h3><h3 id="1-6-15-优化原则：先制作原型，再精雕细琢。优化之前先确保能用"><a href="#1-6-15-优化原则：先制作原型，再精雕细琢。优化之前先确保能用" class="headerlink" title="1.6.15 优化原则：先制作原型，再精雕细琢。优化之前先确保能用"></a>1.6.15 优化原则：先制作原型，再精雕细琢。优化之前先确保能用</h3><h3 id="1-6-16-多样原则：广泛采用多种语言、开放的可扩展系统和用户定制机制"><a href="#1-6-16-多样原则：广泛采用多种语言、开放的可扩展系统和用户定制机制" class="headerlink" title="1.6.16 多样原则：广泛采用多种语言、开放的可扩展系统和用户定制机制"></a>1.6.16 多样原则：广泛采用多种语言、开放的可扩展系统和用户定制机制</h3><h3 id="1-6-17-扩展原则：为数据格式和代码留下扩展的空间"><a href="#1-6-17-扩展原则：为数据格式和代码留下扩展的空间" class="headerlink" title="1.6.17 扩展原则：为数据格式和代码留下扩展的空间"></a>1.6.17 扩展原则：为数据格式和代码留下扩展的空间</h3><h2 id="1-7-一言蔽之：Keep-It-Simple-Stupid"><a href="#1-7-一言蔽之：Keep-It-Simple-Stupid" class="headerlink" title="1.7 一言蔽之：Keep It Simple, Stupid!"></a>1.7 一言蔽之：Keep It Simple, Stupid!</h2><h2 id="1-8-应用Unix哲学"><a href="#1-8-应用Unix哲学" class="headerlink" title="1.8 应用Unix哲学"></a>1.8 应用Unix哲学</h2><h2 id="1-9-态度也要紧"><a href="#1-9-态度也要紧" class="headerlink" title="1.9 态度也要紧"></a>1.9 态度也要紧</h2><h1 id="ch02-历史——双流记"><a href="#ch02-历史——双流记" class="headerlink" title="ch02 历史——双流记"></a>ch02 历史——双流记</h1><p>本章通过回顾Unix的历史来阐明如今的Unix文化为什么会呈现当前这种状态</p>
<h2 id="2-1-起源：Unix的祖辈是小而简单的兼容分时系统"><a href="#2-1-起源：Unix的祖辈是小而简单的兼容分时系统" class="headerlink" title="2.1 起源：Unix的祖辈是小而简单的兼容分时系统"></a>2.1 起源：Unix的祖辈是小而简单的兼容分时系统</h2><h2 id="2-2-黑客的起源和历史"><a href="#2-2-黑客的起源和历史" class="headerlink" title="2.2 黑客的起源和历史"></a>2.2 黑客的起源和历史</h2><h2 id="2-3-开源运动"><a href="#2-3-开源运动" class="headerlink" title="2.3 开源运动"></a>2.3 开源运动</h2><h2 id="2-4-Unix的历史教训"><a href="#2-4-Unix的历史教训" class="headerlink" title="2.4 Unix的历史教训"></a>2.4 Unix的历史教训</h2><h1 id="ch03-Unix哲学同其他哲学的比较"><a href="#ch03-Unix哲学同其他哲学的比较" class="headerlink" title="ch03 Unix哲学同其他哲学的比较"></a>ch03 Unix哲学同其他哲学的比较</h1><h2 id="3-1-操作系统的风格元素"><a href="#3-1-操作系统的风格元素" class="headerlink" title="3.1 操作系统的风格元素"></a>3.1 操作系统的风格元素</h2><p>与不同操作系统相关的设计和编程风格可以追溯出三个源头</p>
<ol>
<li>操作系统设计者的意图</li>
<li>成本和编程环境的限制对设计的均衡影响</li>
<li>文化随机漂移，传统无非就是先入为主</li>
</ol>
<h3 id="3-1-1-最基本的问题：这个操作系统存在对其开发具有决定作用的统一性理念吗？"><a href="#3-1-1-最基本的问题：这个操作系统存在对其开发具有决定作用的统一性理念吗？" class="headerlink" title="3.1.1 最基本的问题：这个操作系统存在对其开发具有决定作用的统一性理念吗？"></a>3.1.1 最基本的问题：这个操作系统存在对其开发具有决定作用的统一性理念吗？</h3><p>一切皆文件</p>
<h3 id="3-1-2-多任务能力"><a href="#3-1-2-多任务能力" class="headerlink" title="3.1.2 多任务能力"></a>3.1.2 多任务能力</h3><p>顺序的程序加载器 -&gt; 协作式多任务 -&gt; 抢先式多任务</p>
<h3 id="3-1-3-协作进程"><a href="#3-1-3-协作进程" class="headerlink" title="3.1.3 协作进程"></a>3.1.3 协作进程</h3><p>代价高昂的进程生成和IPC会带来的5个后果</p>
<h3 id="3-1-4-内部边界"><a href="#3-1-4-内部边界" class="headerlink" title="3.1.4 内部边界"></a>3.1.4 内部边界</h3><p>Unix至少设立了三层内部边界来防范恶意用户或有缺陷的程序</p>
<ol>
<li>内存管理</li>
<li>为多用户设置的真正权限组</li>
<li>把涉及关键安全性的功能限制在尽可能小的可信代码块上</li>
</ol>
<h3 id="3-1-5-文件属性和记录结构"><a href="#3-1-5-文件属性和记录结构" class="headerlink" title="3.1.5 文件属性和记录结构"></a>3.1.5 文件属性和记录结构</h3><p>Unix文件既没有记录结构也没有文件属性</p>
<ol>
<li>记录结构：操作系统通过固定长度的记录，了解文件</li>
<li>文件属性：采用编外数据将文档文件同能够解读它的应用程序关联起来。（Unix使用特征数或是文件内的其他类型数据）</li>
</ol>
<h3 id="3-1-6-二进制文件格式"><a href="#3-1-6-二进制文件格式" class="headerlink" title="3.1.6 二进制文件格式"></a>3.1.6 二进制文件格式</h3><p>后果：不透明</p>
<h3 id="3-1-7-首选用户界面风格"><a href="#3-1-7-首选用户界面风格" class="headerlink" title="3.1.7 首选用户界面风格"></a>3.1.7 首选用户界面风格</h3><p>命令行界面弱的4个后果</p>
<h3 id="3-1-8-目标受众"><a href="#3-1-8-目标受众" class="headerlink" title="3.1.8 目标受众"></a>3.1.8 目标受众</h3><p>客户端和服务器的区别对开发风格产生影响。其中最明显的就是目标用户能够容忍的界面复杂的级别。Unix是写给程序员的——这个目标用户群在界面复杂度的承受力方面是出了名的。</p>
<h3 id="3-1-9-开发的门槛"><a href="#3-1-9-开发的门槛" class="headerlink" title="3.1.9 开发的门槛"></a>3.1.9 开发的门槛</h3><p>昂贵的开发工具和复杂晦涩的API造就了小群的精英编程文化</p>
<h2 id="3-2-操作系统的比较"><a href="#3-2-操作系统的比较" class="headerlink" title="3.2 操作系统的比较"></a>3.2 操作系统的比较</h2><h3 id="3-2-2-MacOS"><a href="#3-2-2-MacOS" class="headerlink" title="3.2.2 MacOS"></a>3.2.2 MacOS</h3><p>经典的MacOS已经寿终正寝。MacOS大多数功能已被引入MacOS X，并同源自Berkeley传统的Unix架构结合在一起。</p>
<h3 id="3-2-4-Windows-NT"><a href="#3-2-4-Windows-NT" class="headerlink" title="3.2.4 Windows NT"></a>3.2.4 Windows NT</h3><p>Windows ME终结后，目前所有的Windows操作系统都以Windows NT为基础。（本书写作时是2003年）</p>
<p>每一代技术都随着旧方式被宣告过时而不再有良好支持，开发者必须以不同的方式从头学起</p>
<p>Unix中很简单的多道程序设计和网络应用到NT下则要牵涉更多基础性概念</p>
<p>进程生成昂贵，比Unix高出一个数量级</p>
<p>Unix的配置数据分散在dotfiles和系统数据文件中；而NT则集中存放在注册表中</p>
<h3 id="3-2-8-Linux"><a href="#3-2-8-Linux" class="headerlink" title="3.2.8 Linux"></a>3.2.8 Linux</h3><p>Linux的长期目标是包容</p>
<ul>
<li>专有Unix牺牲在低端硬件上的性能而专门为多处理器和服务器集群调优</li>
<li>Linux要从过时了的硬件中榨取有用东西，Linux应用程序始终保持瘦小精干的体态</li>
</ul>
<h2 id="3-3-种什么籽，得什么果"><a href="#3-3-种什么籽，得什么果" class="headerlink" title="3.3 种什么籽，得什么果"></a>3.3 种什么籽，得什么果</h2><p>Unix竞争者的什么劣势让它们失败</p>
<ol>
<li>不可移植性</li>
<li>不具备良好的网络支持能力</li>
</ol>
<h1 id="ch04-模块性：保持清晰，保持简洁"><a href="#ch04-模块性：保持清晰，保持简洁" class="headerlink" title="ch04 模块性：保持清晰，保持简洁"></a>ch04 模块性：保持清晰，保持简洁</h1><p>分析Unix传统是如何教导我们遵循模块化原则的</p>
<h2 id="4-1-封装和最佳模块大小"><a href="#4-1-封装和最佳模块大小" class="headerlink" title="4.1 封装和最佳模块大小"></a>4.1 封装和最佳模块大小</h2><p>在编码前为API编写一段非正式书面描述</p>
<p>200到400之间逻辑行的代码使缺陷密度达到最小</p>
<h2 id="4-2-紧凑性和正交性"><a href="#4-2-紧凑性和正交性" class="headerlink" title="4.2 紧凑性和正交性"></a>4.2 紧凑性和正交性</h2><p>在设计API、命令集、协议以及其他方法时，要认真考虑紧凑性和正交性</p>
<h3 id="4-2-1-紧凑性就是一个设计是否能装进人脑中"><a href="#4-2-1-紧凑性就是一个设计是否能装进人脑中" class="headerlink" title="4.2.1 紧凑性就是一个设计是否能装进人脑中"></a>4.2.1 紧凑性就是一个设计是否能装进人脑中</h3><ul>
<li><p>Lisp构建在易于理解且利于组合的抽象概念上，是紧凑的</p>
</li>
<li><p>Unix系统调用是半紧凑的</p>
</li>
<li><p>C标准库无论如何都算不上是紧凑的</p>
</li>
<li><p>在Unix工具软件中：make是紧凑的，autoconf和automake则不是。</p>
</li>
<li><p>在通用编程语言中：C和Python是半紧凑的，Perl、java、Emacs Lisp和shell则不是</p>
</li>
</ul>
<h3 id="4-2-2-正交性就是每一个动作只改变一件事，不会影响其他"><a href="#4-2-2-正交性就是每一个动作只改变一件事，不会影响其他" class="headerlink" title="4.2.2 正交性就是每一个动作只改变一件事，不会影响其他"></a>4.2.2 正交性就是每一个动作只改变一件事，不会影响其他</h3><p>Unix的基本API设计在正交性方面虽不完美，但也颇为成功</p>
<h3 id="4-2-3-SPOT：真理的单点性"><a href="#4-2-3-SPOT：真理的单点性" class="headerlink" title="4.2.3 SPOT：真理的单点性"></a>4.2.3 SPOT：真理的单点性</h3><p>常量、表和元数据只应该声明和初始化一次，并导入其他地方</p>
<h3 id="4-2-4-紧凑性和强单一中心"><a href="#4-2-4-紧凑性和强单一中心" class="headerlink" title="4.2.4 紧凑性和强单一中心"></a>4.2.4 紧凑性和强单一中心</h3><ol>
<li>形式法：围绕“解决一个定义明确的问题”的强核心算法组织设计。</li>
</ol>
<ul>
<li>diff使用一个简单、从数学上看很可靠的序列比较方法</li>
<li>grep围绕正则表达式模式的形式代数问题</li>
<li>yacc围绕LR语法形式理论</li>
</ul>
<ol>
<li>试探法：凭经验法则得出的解决方案</li>
</ol>
<ul>
<li>有时不可能找到绝对正确的解决方案。例如垃圾邮件过滤——自然语言的理解问题尚未完全解决</li>
<li>有时形式上正确的方法开销贵得难以想象。例如虚拟内存管理</li>
</ul>
<h3 id="4-2-5-分离的价值"><a href="#4-2-5-分离的价值" class="headerlink" title="4.2.5 分离的价值"></a>4.2.5 分离的价值</h3><p>从零开始，抛弃先入之见</p>
<h2 id="4-3-软件是多层的"><a href="#4-3-软件是多层的" class="headerlink" title="4.3 软件是多层的"></a>4.3 软件是多层的</h2><h3 id="4-3-1-自顶向下和自底向上"><a href="#4-3-1-自顶向下和自底向上" class="headerlink" title="4.3.1 自顶向下和自底向上"></a>4.3.1 自顶向下和自底向上</h3><p>当以下三个条件都成立时，自顶向下不失为好方法：</p>
<ol>
<li>能够精确预知程序的任务</li>
<li>实现过程中，程序规格变化不大</li>
<li>在底层有充分自由来选择程序完成任务的方式</li>
</ol>
<p>如果纯粹地自顶向下编程，常常产生在某些代码上的过度投资效应</p>
<p>实际代码往往是自顶向下和自底向上综合的产物。这就导致了胶合层的出现</p>
<h3 id="4-3-2-胶合层"><a href="#4-3-2-胶合层" class="headerlink" title="4.3.2 胶合层"></a>4.3.2 胶合层</h3><p>胶合层必须尽可能薄</p>
<p>薄胶合层原则可以看做是分离原则的升华。策略（应用逻辑）应该与机制（域原语集）清晰地分离。</p>
<h3 id="4-3-3-实例分析：被视为薄胶合层的C语言"><a href="#4-3-3-实例分析：被视为薄胶合层的C语言" class="headerlink" title="4.3.3 实例分析：被视为薄胶合层的C语言"></a>4.3.3 实例分析：被视为薄胶合层的C语言</h3><p>除了紧凑、正交和分离，C语言还拥有透明性</p>
<h2 id="4-4-程序库"><a href="#4-4-程序库" class="headerlink" title="4.4 程序库"></a>4.4 程序库</h2><p>Unix把服务程序集中在一个库中并单独文档化</p>
<p>库分层的一个重要形式是插件</p>
<h3 id="4-4-1-实例分析：GIMP插件"><a href="#4-4-1-实例分析：GIMP插件" class="headerlink" title="4.4.1 实例分析：GIMP插件"></a>4.4.1 实例分析：GIMP插件</h3><p>C程序写成的插件可以由GIMP动态载入</p>
<h2 id="4-5-Unix和面向对象语言"><a href="#4-5-Unix和面向对象语言" class="headerlink" title="4.5 Unix和面向对象语言"></a>4.5 Unix和面向对象语言</h2><p>面向对象（OO）最初在图形系统、GUI和某些仿真程序中被认可。</p>
<p>OO语言鼓励“具有厚重的胶合与复杂层次”的体系。</p>
<p>在Unix下，OO语言没能代替非OO的主力语言</p>
<h2 id="4-6-模块式编码"><a href="#4-6-模块式编码" class="headerlink" title="4.6 模块式编码"></a>4.6 模块式编码</h2><p>编写代码时问以下问题</p>
<ol>
<li>有多少全局变量</li>
<li>单个模块是否在Hatton的最佳范围内</li>
<li>模块内的单个函数是不是太大了</li>
<li>代码是否有内部API</li>
<li>API的入口点是否超过七个</li>
<li>整个项目中每个模块的入口点数量如何分布</li>
</ol>
<h1 id="ch05-文本化：好协议产生好实践"><a href="#ch05-文本化：好协议产生好实践" class="headerlink" title="ch05 文本化：好协议产生好实践"></a>ch05 文本化：好协议产生好实践</h1><p>序列化（保存）操作有时也称为列集，其反向操作（载入）称为散集</p>
<h2 id="5-1-文本化的重要性"><a href="#5-1-文本化的重要性" class="headerlink" title="5.1 文本化的重要性"></a>5.1 文本化的重要性</h2><p>使用二进制协议的正当例子</p>
<ol>
<li>要处理大批量的数据集。例如大图像和多媒体数据格式</li>
<li>非常关心将数据转化为芯片核心结构所必需的时间或指令开销。例如网络协议</li>
</ol>
<h3 id="5-1-1-实例分析：Unix口令文件格式"><a href="#5-1-1-实例分析：Unix口令文件格式" class="headerlink" title="5.1.1 实例分析：Unix口令文件格式"></a>5.1.1 实例分析：Unix口令文件格式</h3><h3 id="5-1-2-实例分析：-newsrc格式"><a href="#5-1-2-实例分析：-newsrc格式" class="headerlink" title="5.1.2 实例分析：.newsrc格式"></a>5.1.2 实例分析：.newsrc格式</h3><h3 id="5-1-3-实例分析：PNG图形文件格式"><a href="#5-1-3-实例分析：PNG图形文件格式" class="headerlink" title="5.1.3 实例分析：PNG图形文件格式"></a>5.1.3 实例分析：PNG图形文件格式</h3><h2 id="5-2-数据文件元格式"><a href="#5-2-数据文件元格式" class="headerlink" title="5.2 数据文件元格式"></a>5.2 数据文件元格式</h2><p>已经得到充分肯定的句法和词法约定</p>
<h3 id="5-2-1-DSV风格"><a href="#5-2-1-DSV风格" class="headerlink" title="5.2.1 DSV风格"></a>5.2.1 DSV风格</h3><p>/etc/passwd 文件就是一个使用冒号作为值分隔符的DSV格式，这种风格的数据文件一般应通过反斜杠<code>\</code>转义符支持在数据域中包含冒号。</p>
<p>CSV是反面例子，如果字段值中有逗号，就将整个字段值包括在双引号内</p>
<h3 id="5-2-2-RFC-822格式"><a href="#5-2-2-RFC-822格式" class="headerlink" title="5.2.2 RFC 822格式"></a>5.2.2 RFC 822格式</h3><p>源于电子邮件</p>
<h3 id="5-2-3-Cookie-Jar格式"><a href="#5-2-3-Cookie-Jar格式" class="headerlink" title="5.2.3 Cookie-Jar格式"></a>5.2.3 Cookie-Jar格式</h3><p>fortune为随机引用数据库而使用的一种格式</p>
<h3 id="5-2-4-Record-Jar格式"><a href="#5-2-4-Record-Jar格式" class="headerlink" title="5.2.4 Record-Jar格式"></a>5.2.4 Record-Jar格式</h3><p>是Cookie-Jar和RFC 822的结合</p>
<h3 id="5-2-5-XML"><a href="#5-2-5-XML" class="headerlink" title="5.2.5 XML"></a>5.2.5 XML</h3><p>适合又复杂递归或嵌套数据结构的格式</p>
<h3 id="5-2-6-Windows-INI格式"><a href="#5-2-6-Windows-INI格式" class="headerlink" title="5.2.6 Windows INI格式"></a>5.2.6 Windows INI格式</h3><p>适合数据围绕指定的记录或部分能够自然分成“名称-属性对”两层组织结构</p>
<h3 id="5-2-7-Unix文本文件格式的约定"><a href="#5-2-7-Unix文本文件格式的约定" class="headerlink" title="5.2.7 Unix文本文件格式的约定"></a>5.2.7 Unix文本文件格式的约定</h3><p><strong>共13点</strong></p>
<h3 id="5-2-8-文件压缩的利弊"><a href="#5-2-8-文件压缩的利弊" class="headerlink" title="5.2.8 文件压缩的利弊"></a>5.2.8 文件压缩的利弊</h3><p>将表现形式的设计和具体压缩方法分离</p>
<h2 id="5-3-应用协议设计"><a href="#5-3-应用协议设计" class="headerlink" title="5.3 应用协议设计"></a>5.3 应用协议设计</h2><p>应用协议的典范：SMTP、POP3、IMAP</p>
<h3 id="5-3-1-SMTP，简单的套接字协议"><a href="#5-3-1-SMTP，简单的套接字协议" class="headerlink" title="5.3.1 SMTP，简单的套接字协议"></a>5.3.1 SMTP，简单的套接字协议</h3><p>SMTP是邮件<strong>发送</strong>者启动事务处理的“推”协议</p>
<h3 id="5-3-2-POP3，邮局协议"><a href="#5-3-2-POP3，邮局协议" class="headerlink" title="5.3.2 POP3，邮局协议"></a>5.3.2 POP3，邮局协议</h3><p>POP3是邮件<strong>接收</strong>者启动事务处理的“拉”协议</p>
<h3 id="5-3-3-IMAP，互联网消息访问协议"><a href="#5-3-3-IMAP，互联网消息访问协议" class="headerlink" title="5.3.3 IMAP，互联网消息访问协议"></a>5.3.3 IMAP，互联网消息访问协议</h3><p>不是用点号来结束，而是将有效载荷的长度直接放在有效载荷之前发送</p>
<h2 id="5-4-应用协议元格式"><a href="#5-4-应用协议元格式" class="headerlink" title="5.4 应用协议元格式"></a>5.4 应用协议元格式</h2><ul>
<li>数据文件元格式是为了简化存储的序列化</li>
<li>应用协议元格式是为了简化网络间事务处理的序列化</li>
</ul>
<h3 id="5-4-1-经典的互联网应用元协议"><a href="#5-4-1-经典的互联网应用元协议" class="headerlink" title="5.4.1 经典的互联网应用元协议"></a>5.4.1 经典的互联网应用元协议</h3><p>使用单行请求和响应，但有效数据载荷可以多行。有效数据载荷要么是8位组数据作为前导，要么以“\r\n”行作为结束符。</p>
<h3 id="5-4-2-作为通用应用协议的HTTP"><a href="#5-4-2-作为通用应用协议的HTTP" class="headerlink" title="5.4.2 作为通用应用协议的HTTP"></a>5.4.2 作为通用应用协议的HTTP</h3><p>HTTP请求采用类似RFC-822/MINE格式的消息：通常，消息头包含识别和认证信息，第一行是对通用资源指示符（URI）指定的某个资源的方法调用。最重要的方法是GET、PUT和POST。URI最重要的形式是URL</p>
<h4 id="5-4-2-1-实例分析：freedb-org数据库基于HTTP作为简单地CGI查询"><a href="#5-4-2-1-实例分析：freedb-org数据库基于HTTP作为简单地CGI查询" class="headerlink" title="5.4.2.1 实例分析：freedb.org数据库基于HTTP作为简单地CGI查询"></a>5.4.2.1 实例分析：freedb.org数据库基于HTTP作为简单地CGI查询</h4><h4 id="5-4-2-2-实例分析：互联网打印协议（IPP）使用HTTP1-1作为传输层，所有请求都通过POST方法调用发送"><a href="#5-4-2-2-实例分析：互联网打印协议（IPP）使用HTTP1-1作为传输层，所有请求都通过POST方法调用发送" class="headerlink" title="5.4.2.2 实例分析：互联网打印协议（IPP）使用HTTP1.1作为传输层，所有请求都通过POST方法调用发送"></a>5.4.2.2 实例分析：互联网打印协议（IPP）使用HTTP1.1作为传输层，所有请求都通过POST方法调用发送</h4><h3 id="5-4-3-BEEP：块可扩展交换协议"><a href="#5-4-3-BEEP：块可扩展交换协议" class="headerlink" title="5.4.3 BEEP：块可扩展交换协议"></a>5.4.3 BEEP：块可扩展交换协议</h3><p>支持对等网模式（peer-to-peer）。用户端之间相互交换自描述二进制包序列</p>
<h3 id="5-4-4-XML-RPC、SOAP和Jabber"><a href="#5-4-4-XML-RPC、SOAP和Jabber" class="headerlink" title="5.4.4 XML-RPC、SOAP和Jabber"></a>5.4.4 XML-RPC、SOAP和Jabber</h3><p>这三个协议都基于XML文档</p>
<h1 id="ch06-透明性：来点儿光"><a href="#ch06-透明性：来点儿光" class="headerlink" title="ch06 透明性：来点儿光"></a>ch06 透明性：来点儿光</h1><ul>
<li><p>透明性（被动品质）：能预测到程序行为的大部分情况，并能建立简单的心理模型</p>
</li>
<li><p>可显性（主动品质）：软件系统所包含的功能是为了帮助人们对软件建立正确的“做什么、怎样做”的心理模型而设计的</p>
</li>
<li><p>Linux的内核源码相当透明，但不具备可显性。</p>
</li>
<li><p>Emacs Lisp库是可显的，但却不透明。</p>
</li>
</ul>
<h2 id="6-1-研究实例"><a href="#6-1-研究实例" class="headerlink" title="6.1 研究实例"></a>6.1 研究实例</h2><h3 id="6-1-1-audacity在UI设计中展示透明性"><a href="#6-1-1-audacity在UI设计中展示透明性" class="headerlink" title="6.1.1 audacity在UI设计中展示透明性"></a>6.1.1 audacity在UI设计中展示透明性</h3><h3 id="6-1-2-fetchmail的-v选项使其具有可显性"><a href="#6-1-2-fetchmail的-v选项使其具有可显性" class="headerlink" title="6.1.2 fetchmail的-v选项使其具有可显性"></a>6.1.2 fetchmail的-v选项使其具有可显性</h3><h3 id="6-1-3-gcc的不同命令行选项可以监控解析进程和代码生成进程中的许多中间步骤的结果"><a href="#6-1-3-gcc的不同命令行选项可以监控解析进程和代码生成进程中的许多中间步骤的结果" class="headerlink" title="6.1.3 gcc的不同命令行选项可以监控解析进程和代码生成进程中的许多中间步骤的结果"></a>6.1.3 gcc的不同命令行选项可以监控解析进程和代码生成进程中的许多中间步骤的结果</h3><h3 id="6-1-4-kmail的GUI内容详实但并不令人分心，既显示了事务处理信息，又很容易让人视而不见。"><a href="#6-1-4-kmail的GUI内容详实但并不令人分心，既显示了事务处理信息，又很容易让人视而不见。" class="headerlink" title="6.1.4 kmail的GUI内容详实但并不令人分心，既显示了事务处理信息，又很容易让人视而不见。"></a>6.1.4 kmail的GUI内容详实但并不令人分心，既显示了事务处理信息，又很容易让人视而不见。</h3><h3 id="6-1-5-sng使PNG可以被编辑和被版本控制"><a href="#6-1-5-sng使PNG可以被编辑和被版本控制" class="headerlink" title="6.1.5 sng使PNG可以被编辑和被版本控制"></a>6.1.5 sng使PNG可以被编辑和被版本控制</h3><h3 id="6-1-6-terminfo使用文件系统作为一个简单地层级数据库，符合经济性原则和透明性原则"><a href="#6-1-6-terminfo使用文件系统作为一个简单地层级数据库，符合经济性原则和透明性原则" class="headerlink" title="6.1.6 terminfo使用文件系统作为一个简单地层级数据库，符合经济性原则和透明性原则"></a>6.1.6 terminfo使用文件系统作为一个简单地层级数据库，符合经济性原则和透明性原则</h3><h3 id="6-1-7-Freeciv游戏里，服务器维持共享状态而客户端专注GUI表现；游戏的大部分固定数据，没有编入服务器的代码中"><a href="#6-1-7-Freeciv游戏里，服务器维持共享状态而客户端专注GUI表现；游戏的大部分固定数据，没有编入服务器的代码中" class="headerlink" title="6.1.7 Freeciv游戏里，服务器维持共享状态而客户端专注GUI表现；游戏的大部分固定数据，没有编入服务器的代码中"></a>6.1.7 Freeciv游戏里，服务器维持共享状态而客户端专注GUI表现；游戏的大部分固定数据，没有编入服务器的代码中</h3><h2 id="6-2-为透明性和可显性而设计"><a href="#6-2-为透明性和可显性而设计" class="headerlink" title="6.2 为透明性和可显性而设计"></a>6.2 为透明性和可显性而设计</h2><p>保持简洁，专注代码同其他人交流的方式</p>
<h3 id="6-2-1-透明性之禅"><a href="#6-2-1-透明性之禅" class="headerlink" title="6.2.1 透明性之禅"></a>6.2.1 透明性之禅</h3><p>不要再具体操作的代码上叠放太多的抽象层</p>
<h3 id="6-2-2-为透明性和可显性而编码"><a href="#6-2-2-为透明性和可显性而编码" class="headerlink" title="6.2.2 为透明性和可显性而编码"></a>6.2.2 为透明性和可显性而编码</h3><p>透明性和可显性同模块性一样，主要是设计的特性而不是代码的特性。好好思考8个问题</p>
<h3 id="6-2-3-透明性和避免过度保护"><a href="#6-2-3-透明性和避免过度保护" class="headerlink" title="6.2.3 透明性和避免过度保护"></a>6.2.3 透明性和避免过度保护</h3><p>隐藏细节和无法访问细节有着重要区别。调试和探测开关是良好程序的标志</p>
<h3 id="6-2-4-透明性和可编辑的表现形式"><a href="#6-2-4-透明性和可编辑的表现形式" class="headerlink" title="6.2.4 透明性和可编辑的表现形式"></a>6.2.4 透明性和可编辑的表现形式</h3><p>一些程序可以把难透明转化为易透明：Audacity、sng、tic、infocmp。这些转换都是可逆、无损的。</p>
<p>如果二进制对象是动态生成的，或者非常大，那么用<strong>文本化器</strong>转化所有状态可能不实际。在这种情况下，对应的任务是编写一个<strong>浏览器</strong>。例如：Unix上的fsdb、Linux上的debugfs、浏览PostgreSQL数据库的psql、查询文件共享的smbclient</p>
<p>编写文本化器或浏览器的4个理由</p>
<p>把文本化器/浏览器作为引擎使用就可以应用“接口和引擎分离”模式</p>
<h3 id="6-2-5-透明性、故障诊断和故障恢复"><a href="#6-2-5-透明性、故障诊断和故障恢复" class="headerlink" title="6.2.5 透明性、故障诊断和故障恢复"></a>6.2.5 透明性、故障诊断和故障恢复</h3><p>透明性有利于简化调试</p>
<ol>
<li>透明的系统可以防止破坏发生</li>
</ol>
<ul>
<li>Windows注册表容易受到错误代码的破坏</li>
<li>Unix的terminfo数据库可以从单点恢复</li>
</ul>
<ol>
<li>透明的系统更容易实施恢复措施</li>
</ol>
<ul>
<li>SNG文件中的语法错误，人工就可以解决</li>
<li>专用编辑器可能拒绝载入受损的PNG图像</li>
</ul>
<ol>
<li>透明的系统使故障诊断更加容易</li>
</ol>
<ul>
<li>kmail遵循了补救原则</li>
<li>SNG格式简化了系统状态的检查，数据的文本化版本具备有用的冗余</li>
</ul>
<h2 id="6-3-为可维护性而设计"><a href="#6-3-为可维护性而设计" class="headerlink" title="6.3 为可维护性而设计"></a>6.3 为可维护性而设计</h2><p>为了透明性和可显性而设计的代码已经朝着可维护性的目标前进了许多。还有其他值得效仿的实践</p>
<ol>
<li>应用清晰原则：选择简单的算法</li>
<li>要包含开发者手册</li>
</ol>
<h1 id="ch07-多道程序设计：分离进程为独立的功能"><a href="#ch07-多道程序设计：分离进程为独立的功能" class="headerlink" title="ch07 多道程序设计：分离进程为独立的功能"></a>ch07 多道程序设计：分离进程为独立的功能</h1><p>用定义良好的进程间通信或共享文件夹来连通小型进程</p>
<h2 id="7-1-从性能调整中分离复杂度控制"><a href="#7-1-从性能调整中分离复杂度控制" class="headerlink" title="7.1 从性能调整中分离复杂度控制"></a>7.1 从性能调整中分离复杂度控制</h2><p>除非万不得已，尽量避免使用线程</p>
<p>进程分解的所有理由，都是我们在<a href="#ch04-%E6%A8%A1%E5%9D%97%E6%80%A7%EF%BC%9A%E4%BF%9D%E6%8C%81%E6%B8%85%E6%99%B0%EF%BC%8C%E4%BF%9D%E6%8C%81%E7%AE%80%E6%B4%81">ch04-模块性</a>提出的模块划分缘由的延续</p>
<p>另一个原因是为了更强的安全性</p>
<h2 id="7-2-Unix-IPC方法的分类"><a href="#7-2-Unix-IPC方法的分类" class="headerlink" title="7.2 Unix IPC方法的分类"></a>7.2 Unix IPC方法的分类</h2><p>本章的剩余部分将大致按照由简到繁的顺序介绍各种IPC方法</p>
<h3 id="7-2-1-把任务转给专门程序"><a href="#7-2-1-把任务转给专门程序" class="headerlink" title="7.2.1 把任务转给专门程序"></a>7.2.1 把任务转给专门程序</h3><p>专门程序运行时并不需要跟父进程交流</p>
<ul>
<li>shell out</li>
<li>bolt-on</li>
</ul>
<h4 id="7-2-1-2-例如git-commit调用编辑器"><a href="#7-2-1-2-例如git-commit调用编辑器" class="headerlink" title="7.2.1.2 例如git commit调用编辑器"></a>7.2.1.2 例如git commit调用编辑器</h4><h3 id="7-2-2-管道、重定向和过滤器"><a href="#7-2-2-管道、重定向和过滤器" class="headerlink" title="7.2.2 管道、重定向和过滤器"></a>7.2.2 管道、重定向和过滤器</h3><p>管道线中所有阶段的程序是并发运行的</p>
<p>管道的主要缺点是单向性，管道线的成员除了终止外不可能回传控制信息</p>
<p>命名管道已经被命名套接字取代了</p>
<h4 id="7-2-2-1-more基本上被less取代了，less增加了向后滚屏的能力"><a href="#7-2-2-1-more基本上被less取代了，less增加了向后滚屏的能力" class="headerlink" title="7.2.2.1 more基本上被less取代了，less增加了向后滚屏的能力"></a>7.2.2.1 more基本上被less取代了，less增加了向后滚屏的能力</h4><h4 id="7-2-2-2-制作单词表tr-c-39-alnum-39-39-n-39-sort-iu-grep-v-39-0-9"><a href="#7-2-2-2-制作单词表tr-c-39-alnum-39-39-n-39-sort-iu-grep-v-39-0-9" class="headerlink" title="7.2.2.2 制作单词表tr -c &#39;[:alnum:]&#39; &#39;[\n*]&#39; | sort -iu | grep -v &#39;^[0-9]*$"></a>7.2.2.2 制作单词表<code>tr -c &#39;[:alnum:]&#39; &#39;[\n*]&#39; | sort -iu | grep -v &#39;^[0-9]*$</code></h4><h4 id="7-2-2-3-pic2graph实现展示了仅仅依靠现有工具的管道线能够完成多少任务"><a href="#7-2-2-3-pic2graph实现展示了仅仅依靠现有工具的管道线能够完成多少任务" class="headerlink" title="7.2.2.3 pic2graph实现展示了仅仅依靠现有工具的管道线能够完成多少任务"></a>7.2.2.3 pic2graph实现展示了仅仅依靠现有工具的管道线能够完成多少任务</h4><h4 id="7-2-2-4-计算器程序bc的旧版本通过管道把命令传递给dc"><a href="#7-2-2-4-计算器程序bc的旧版本通过管道把命令传递给dc" class="headerlink" title="7.2.2.4 计算器程序bc的旧版本通过管道把命令传递给dc"></a>7.2.2.4 计算器程序bc的旧版本通过管道把命令传递给dc</h4><ul>
<li>dc接受简单的逆波兰标记法（RPN）</li>
<li>bc接受复杂的中缀表示法</li>
</ul>
<h4 id="7-2-2-5-反例分析：为什么fetchmail不是管线"><a href="#7-2-2-5-反例分析：为什么fetchmail不是管线" class="headerlink" title="7.2.2.5 反例分析：为什么fetchmail不是管线"></a>7.2.2.5 反例分析：为什么fetchmail不是管线</h4><p>取信程序要决定是否为已取回的每一条消息发送一个删除请求，而管线是单向的</p>
<h3 id="7-2-3-包装器"><a href="#7-2-3-包装器" class="headerlink" title="7.2.3 包装器"></a>7.2.3 包装器</h3><p>和shellout程序相对的是包装器，经常用于隐藏shell管线的复杂细节</p>
<h4 id="7-2-3-1-备份脚本tar-czvf-dev-st0-quot-quot"><a href="#7-2-3-1-备份脚本tar-czvf-dev-st0-quot-quot" class="headerlink" title="7.2.3.1 备份脚本tar -czvf /dev/st0 &quot;$@&quot;"></a>7.2.3.1 备份脚本<code>tar -czvf /dev/st0 &quot;$@&quot;</code></h4><h3 id="7-2-4-安全性包装器和Bernstein链"><a href="#7-2-4-安全性包装器和Bernstein链" class="headerlink" title="7.2.4 安全性包装器和Bernstein链"></a>7.2.4 安全性包装器和Bernstein链</h3><p>安全性包装器可调用守门程序检查某类凭证，然后根据返回的状态值有条件地执行另一个程序</p>
<p>Bernstein链是一个专用化的安全性包装器。和管线类似，只不过每个继发阶段的程序取代了前一阶段的程序，而不是与之并行。</p>
<ul>
<li>rblsmtpd使用一组exec把几个程序粘在一起</li>
<li>qmail包的condredirect和POP3服务器综合使用fork和exec把几个程序粘在一起</li>
</ul>
<p>如果应用程序需要setuid或setgid优先权来做事，然后放弃这些权限让后续代码无需被信任，Bernstein链非常有用</p>
<h3 id="7-2-5-从进程"><a href="#7-2-5-从进程" class="headerlink" title="7.2.5 从进程"></a>7.2.5 从进程</h3><p>主进程和从进程都需要内部状态机处理它们之间的协议以避免发生死锁和竞争。通常只在这两种条件下使用：</p>
<ol>
<li>设计的协议无足轻重。例如进度显示程序scp安全拷贝命令把ssh作为从进程调用</li>
<li>从进程是以我们在<a href="#ch05-%E6%96%87%E6%9C%AC%E5%8C%96%EF%BC%9A%E5%A5%BD%E5%8D%8F%E8%AE%AE%E4%BA%A7%E7%94%9F%E5%A5%BD%E5%AE%9E%E8%B7%B5">ch05-文本化</a>讨论的应用协议进行通讯而设计的<br>否则要考虑使用套接字或共享内存等更趋对等结构的路</li>
</ol>
<h3 id="7-2-6-对等进程间通信"><a href="#7-2-6-对等进程间通信" class="headerlink" title="7.2.6 对等进程间通信"></a>7.2.6 对等进程间通信</h3><p>迄今我们已经讨论的各种通讯方法都存在隐含的层次关系。接下来分析对等通信方法</p>
<h4 id="7-2-6-1-临时文件"><a href="#7-2-6-1-临时文件" class="headerlink" title="7.2.6.1 临时文件"></a>7.2.6.1 临时文件</h4><p>在shell脚本及一些一次性程序中很有用。优点是容易创建、很灵活；缺点是</p>
<ul>
<li>被中断时往往会遗留垃圾数据</li>
<li>临时文件名冲突，通常把shell变量<code>$$</code>展开为进程ID来保证文件名的唯一性</li>
<li>攻击程序可以读取和修改临时文件来哄骗消费者进程</li>
</ul>
<h4 id="7-2-6-2-信号"><a href="#7-2-6-2-信号" class="headerlink" title="7.2.6.2 信号"></a>7.2.6.2 信号</h4><p>Unix的信号是一种软中断</p>
<p>随信号IPC经常使用的一种技法是pidfile</p>
<h4 id="7-2-6-3-系统守护程序和常规信号"><a href="#7-2-6-3-系统守护程序和常规信号" class="headerlink" title="7.2.6.3 系统守护程序和常规信号"></a>7.2.6.3 系统守护程序和常规信号</h4><ul>
<li>SIGHUP：重新初始化</li>
<li>SIGTERM：温和的关闭信号</li>
<li>SIGKILL：立即杀死进程，不能被阻塞</li>
</ul>
<h4 id="7-2-6-4-fetchmail使用信号通知老进程，避免运行2个实例"><a href="#7-2-6-4-fetchmail使用信号通知老进程，避免运行2个实例" class="headerlink" title="7.2.6.4 fetchmail使用信号通知老进程，避免运行2个实例"></a>7.2.6.4 fetchmail使用信号通知老进程，避免运行2个实例</h4><h4 id="7-2-6-5-套接字通信是按序且可靠的"><a href="#7-2-6-5-套接字通信是按序且可靠的" class="headerlink" title="7.2.6.5 套接字通信是按序且可靠的"></a>7.2.6.5 套接字通信是按序且可靠的</h4><p>性能压力可能会促使你使用共享内存、临时文件或其他要求更多局部性条件的激发，但是现代程序最好设想代码需要增加分布式操作。</p>
<h5 id="7-2-6-5-1-实例分析：PostgreSQL"><a href="#7-2-6-5-1-实例分析：PostgreSQL" class="headerlink" title="7.2.6.5.1 实例分析：PostgreSQL"></a>7.2.6.5.1 实例分析：PostgreSQL</h5><p>前后端分离，包括一个postmaster的服务器程序和至少三个客户应用程序</p>
<h5 id="7-2-6-5-2-实例分析：Freeciv"><a href="#7-2-6-5-2-实例分析：Freeciv" class="headerlink" title="7.2.6.5.2 实例分析：Freeciv"></a>7.2.6.5.2 实例分析：Freeciv</h5><p>所有的游戏逻辑都在服务器端处理，GUI的细节在客户端处理。包协议使用TCP/IP传输。其他那些更像实时模拟游戏（特别是仿真视角射击游戏）使用UDP，因为用户通常连续地发送控制动作，所以零星的信号丢失可以忍受，但是延迟确是致命的</p>
<h4 id="7-2-6-6-共享内存"><a href="#7-2-6-6-共享内存" class="headerlink" title="7.2.6.6 共享内存"></a>7.2.6.6 共享内存</h4><p>Unix中使用mmap把文件映射成可以被多个进程共享的内存</p>
<p>处理共享内存的程序必须自己处理竞争和死锁问题</p>
<p>使用共享内存传递大图像以避免套接字通信的开销是得到经验和测试证实的性能优化</p>
<p>Unix、Win和MacOS都支持套接字，但Win和传统的MacOS不支持mmap调用</p>
<h2 id="7-3-要避免的问题和方法"><a href="#7-3-要避免的问题和方法" class="headerlink" title="7.3 要避免的问题和方法"></a>7.3 要避免的问题和方法</h2><h3 id="7-3-1-废弃的Unix-IPC方法"><a href="#7-3-1-废弃的Unix-IPC方法" class="headerlink" title="7.3.1 废弃的Unix IPC方法"></a>7.3.1 废弃的Unix IPC方法</h3><p>这些废弃的方法在《Unix网络编程》中有更详细的描述</p>
<h4 id="7-3-1-1-System-V-IPC，其Linux版本直到2003年中期还存在bug"><a href="#7-3-1-1-System-V-IPC，其Linux版本直到2003年中期还存在bug" class="headerlink" title="7.3.1.1 System V IPC，其Linux版本直到2003年中期还存在bug"></a>7.3.1.1 System V IPC，其Linux版本直到2003年中期还存在bug</h4><h4 id="7-3-1-2-Steams随着TCP-IP归并到Unix内核而变得越来越无用武之地"><a href="#7-3-1-2-Steams随着TCP-IP归并到Unix内核而变得越来越无用武之地" class="headerlink" title="7.3.1.2 Steams随着TCP/IP归并到Unix内核而变得越来越无用武之地"></a>7.3.1.2 Steams随着TCP/IP归并到Unix内核而变得越来越无用武之地</h4><h3 id="7-3-2-远程过程调用"><a href="#7-3-2-远程过程调用" class="headerlink" title="7.3.2 远程过程调用"></a>7.3.2 远程过程调用</h3><p>尽管偶有例外，如NFS和GNOME，但是其他远程过程调用接口形式的尝试大多失败了</p>
<p>最成功的RPC应用，如NFS，都是那些在应用定义域上本来就只涉及很少量简单数据类型的应用</p>
<p>RPC使胶合层太厚</p>
<h3 id="7-3-3-线程只适合那些进程生成昂贵、IPC功能薄弱的操作系统"><a href="#7-3-3-线程只适合那些进程生成昂贵、IPC功能薄弱的操作系统" class="headerlink" title="7.3.3 线程只适合那些进程生成昂贵、IPC功能薄弱的操作系统"></a>7.3.3 线程只适合那些进程生成昂贵、IPC功能薄弱的操作系统</h3><p>Win和MacOS自带的线程模型和中断功能与Unix差别非常大。不要指望线程程序可移植</p>
<h2 id="7-4-在设计层次上的进程划分"><a href="#7-4-在设计层次上的进程划分" class="headerlink" title="7.4 在设计层次上的进程划分"></a>7.4 在设计层次上的进程划分</h2><p>临时文件、交互性更强的主/从进程关系、套接字、RPC和其他一些双向IPC方法在某种程度上是等价的。我们通过使用套接字或共享内存这种复杂的方法所完成的任务，大多数都可以通过使用临时文件作为信箱和通知信号这种简单的方法来完成。差别很小，主要体现在如何建立通信、何时何地完成信息的列集和散集、可能产生何种缓冲问题，以及如何保障获取信息的原子性</p>
<h1 id="ch08-微型语言"><a href="#ch08-微型语言" class="headerlink" title="ch08 微型语言"></a>ch08 微型语言</h1><p>做好微型语言设计的方法</p>
<ol>
<li>表示法更紧凑、更具表达力。切实利用“软件的缺陷率和使用的语言在很大程度上无关”</li>
<li>如果规格说明试图描述控制流和数据部署，该把规格说明语言中的控制流从隐式提升到显式了。<br>错误的方法是通过扩展变成微型语言：每次增加一个补丁或者一个仓促而就的特性。</li>
</ol>
<h2 id="8-1-理解语言分类法"><a href="#8-1-理解语言分类法" class="headerlink" title="8.1 理解语言分类法"></a>8.1 理解语言分类法</h2><p>图8.1对语言进行分类，由简到繁：<br><code>简单关联名称和属性的文件-&gt;SNG-&gt;正则表达式-&gt;可用于生成代码的声明性语言-&gt;命令性语言-&gt;bc-&gt;解释器</code></p>
<h2 id="8-2-应用微型语言"><a href="#8-2-应用微型语言" class="headerlink" title="8.2 应用微型语言"></a>8.2 应用微型语言</h2><h3 id="8-2-1-sng使那些编辑、转换和生成工具无需知道任何其他方的设计假定"><a href="#8-2-1-sng使那些编辑、转换和生成工具无需知道任何其他方的设计假定" class="headerlink" title="8.2.1 sng使那些编辑、转换和生成工具无需知道任何其他方的设计假定"></a>8.2.1 sng使那些编辑、转换和生成工具无需知道任何其他方的设计假定</h3><h3 id="8-2-2-正则表达式是一个微型语言能够多么简练的极端例子"><a href="#8-2-2-正则表达式是一个微型语言能够多么简练的极端例子" class="headerlink" title="8.2.2 正则表达式是一个微型语言能够多么简练的极端例子"></a>8.2.2 正则表达式是一个微型语言能够多么简练的极端例子</h3><h3 id="8-2-3-Glade是界面创建程序，可生成描述该界面的XML文件"><a href="#8-2-3-Glade是界面创建程序，可生成描述该界面的XML文件" class="headerlink" title="8.2.3 Glade是界面创建程序，可生成描述该界面的XML文件"></a>8.2.3 Glade是界面创建程序，可生成描述该界面的XML文件</h3><h3 id="8-2-4-m4宏处理程序对描述文本转换的声明性微型语言进行解释"><a href="#8-2-4-m4宏处理程序对描述文本转换的声明性微型语言进行解释" class="headerlink" title="8.2.4 m4宏处理程序对描述文本转换的声明性微型语言进行解释"></a>8.2.4 m4宏处理程序对描述文本转换的声明性微型语言进行解释</h3><p>对于缺乏内置命名过程标记法和文件包含功能的微型语言，可以使用m4作为预处理器。</p>
<h3 id="8-2-5-XSLT描述XML数据的变换"><a href="#8-2-5-XSLT描述XML数据的变换" class="headerlink" title="8.2.5 XSLT描述XML数据的变换"></a>8.2.5 XSLT描述XML数据的变换</h3><h3 id="8-2-6-The-Documenter’s-Workbench-Tools"><a href="#8-2-6-The-Documenter’s-Workbench-Tools" class="headerlink" title="8.2.6 The Documenter’s Workbench Tools"></a>8.2.6 The Documenter’s Workbench Tools</h3><p>排版格式器troff包含后处理器（驱动器driver）和预处理器</p>
<p>pic反映了设计主题——用微型语言解释器封装形式的约束条件推理</p>
<h3 id="8-2-7-fetchmail的运行控制语法，使用可选的纯修饰关键字"><a href="#8-2-7-fetchmail的运行控制语法，使用可选的纯修饰关键字" class="headerlink" title="8.2.7 fetchmail的运行控制语法，使用可选的纯修饰关键字"></a>8.2.7 fetchmail的运行控制语法，使用可选的纯修饰关键字</h3><h3 id="8-2-8-awk逐渐被Perl所取代"><a href="#8-2-8-awk逐渐被Perl所取代" class="headerlink" title="8.2.8 awk逐渐被Perl所取代"></a>8.2.8 awk逐渐被Perl所取代</h3><h3 id="8-2-9-PostScript是一个专门向成像设备描述排版文本和图形的微型语言"><a href="#8-2-9-PostScript是一个专门向成像设备描述排版文本和图形的微型语言" class="headerlink" title="8.2.9 PostScript是一个专门向成像设备描述排版文本和图形的微型语言"></a>8.2.9 PostScript是一个专门向成像设备描述排版文本和图形的微型语言</h3><h3 id="8-2-10-bc和dc都有条件和循环，图灵完备，类型包括无限精度的整数和字符串"><a href="#8-2-10-bc和dc都有条件和循环，图灵完备，类型包括无限精度的整数和字符串" class="headerlink" title="8.2.10 bc和dc都有条件和循环，图灵完备，类型包括无限精度的整数和字符串"></a>8.2.10 bc和dc都有条件和循环，图灵完备，类型包括无限精度的整数和字符串</h3><h3 id="8-2-11-Emacs-Lisp足够强大到作为其他程序的前端"><a href="#8-2-11-Emacs-Lisp足够强大到作为其他程序的前端" class="headerlink" title="8.2.11 Emacs Lisp足够强大到作为其他程序的前端"></a>8.2.11 Emacs Lisp足够强大到作为其他程序的前端</h3><h3 id="8-2-12-JavaScript与其通过DOM对象的浏览器环境之间的结合很棒"><a href="#8-2-12-JavaScript与其通过DOM对象的浏览器环境之间的结合很棒" class="headerlink" title="8.2.12 JavaScript与其通过DOM对象的浏览器环境之间的结合很棒"></a>8.2.12 JavaScript与其通过DOM对象的浏览器环境之间的结合很棒</h3><h2 id="8-3-设计微型语言"><a href="#8-3-设计微型语言" class="headerlink" title="8.3 设计微型语言"></a>8.3 设计微型语言</h2><p>只要应用领域的域原语简单而固定不变，微信语言就可能成为一种好办法，但用户可能希望应用方式要灵活多变</p>
<h3 id="8-3-1-选择正确的复杂度"><a href="#8-3-1-选择正确的复杂度" class="headerlink" title="8.3.1 选择正确的复杂度"></a>8.3.1 选择正确的复杂度</h3><p>嵌入微型语言功能容易导致滥用，例如JavaScript弹出式广告与Microsoft Word宏病毒</p>
<p>应用微型语言的风险特性可能必须被禁止。Java和JavaScript已被明确地沙盒化——对环境的访问受限</p>
<p>不宜对微型语言设计的<strong>本身</strong>采取自底向上的方法</p>
<h3 id="8-3-2-扩展和嵌入语言"><a href="#8-3-2-扩展和嵌入语言" class="headerlink" title="8.3.2 扩展和嵌入语言"></a>8.3.2 扩展和嵌入语言</h3><ul>
<li>用C代码扩展脚本语言</li>
<li>在C程序中嵌入脚本语言</li>
</ul>
<ol>
<li>可以扩展或嵌入Perl</li>
<li>扩展Python很容易，但嵌入难</li>
<li>Java有一个接口可调用C的原生方法，只不过这个实践被明确阻止，因为它往往破坏可移植性</li>
<li>shell的大多数版本都不是为嵌入性和扩展性设计的，但Korn shell（ksh93和后续版本）例外</li>
</ol>
<h3 id="8-3-3-编写自定义语法"><a href="#8-3-3-编写自定义语法" class="headerlink" title="8.3.3 编写自定义语法"></a>8.3.3 编写自定义语法</h3><p>数据文件的最小立异 -&gt; XML -&gt; lex和yacc -&gt; m4预处理</p>
<h3 id="8-3-4-宏——慎用"><a href="#8-3-4-宏——慎用" class="headerlink" title="8.3.4 宏——慎用"></a>8.3.4 宏——慎用</h3><p>宏与带副作用的表达式之间的交互作用可能导致不幸的结果</p>
<p>宏扩展往往扰乱了错误诊断</p>
<h3 id="8-3-5-语言还是应用协议"><a href="#8-3-5-语言还是应用协议" class="headerlink" title="8.3.5 语言还是应用协议"></a>8.3.5 语言还是应用协议</h3><p>微型语言能否被其他程序作为从进程交互调用</p>
<p>取决于输出有没有明确地结束标记或提前告诉输出长度</p>
<h1 id="ch09-生成：提升规格说明的层次"><a href="#ch09-生成：提升规格说明的层次" class="headerlink" title="ch09 生成：提升规格说明的层次"></a>ch09 生成：提升规格说明的层次</h1><p>尽可能把设计的复杂度从程序代码转移到数据中</p>
<h2 id="9-1-数据驱动编程需要把代码和代码作用的数据结构划分清楚"><a href="#9-1-数据驱动编程需要把代码和代码作用的数据结构划分清楚" class="headerlink" title="9.1 数据驱动编程需要把代码和代码作用的数据结构划分清楚"></a>9.1 数据驱动编程需要把代码和代码作用的数据结构划分清楚</h2><p>数据驱动编程不同于面向对象，也不同于状态机编写</p>
<h3 id="9-1-1-ascii程序，把所有字符名的字符串都放在一个表结构中"><a href="#9-1-1-ascii程序，把所有字符名的字符串都放在一个表结构中" class="headerlink" title="9.1.1 ascii程序，把所有字符名的字符串都放在一个表结构中"></a>9.1.1 ascii程序，把所有字符名的字符串都放在一个表结构中</h3><h3 id="9-1-2-统计学的垃圾邮件统计"><a href="#9-1-2-统计学的垃圾邮件统计" class="headerlink" title="9.1.2 统计学的垃圾邮件统计"></a>9.1.2 统计学的垃圾邮件统计</h3><p>传统的垃圾邮件过滤器要求系统管理员维护在垃圾邮件中发现的文本模式信息，而统计学垃圾邮件过滤器却根据用户的反馈生成自己的过滤规则</p>
<h3 id="9-1-3-fetchmailconf中的元类改动"><a href="#9-1-3-fetchmailconf中的元类改动" class="headerlink" title="9.1.3 fetchmailconf中的元类改动"></a>9.1.3 fetchmailconf中的元类改动</h3><p>由于用户生成fetchmail的配置文件越来越困难，且fetchmail配置文件语法的分析程序相当复杂。我给fetchmail增加了一个–configdump选项用于分析<code>.fetchmailrc</code>，并把结果以Python初始化器格式转储到标准输出。</p>
<p>如果配置语言会随时间推移增加新的特性和新的类成员，那么用显式的方法编写的对象创建代码将会变得脆弱。更好的方法是数据驱动编程。Lisp和Java程序员称之为内省，其他一些OO语言称之为元类修改；绝大多数OO语言不支持它，但是Python易用</p>
<h2 id="9-2-专用代码的生成"><a href="#9-2-专用代码的生成" class="headerlink" title="9.2 专用代码的生成"></a>9.2 专用代码的生成</h2><p>有一些比第15章更简单且轻巧得多的代码生成方式</p>
<h3 id="9-2-1-生成ascii显示的代码"><a href="#9-2-1-生成ascii显示的代码" class="headerlink" title="9.2.1 生成ascii显示的代码"></a>9.2.1 生成ascii显示的代码</h3><p>ascii程序编译时，splashscreen文件自动被揉制成一系列输出函数调用，然后由C预处理器包含到正确的函数中</p>
<h3 id="9-2-2-为列表生成HTML代码"><a href="#9-2-2-为列表生成HTML代码" class="headerlink" title="9.2.2 为列表生成HTML代码"></a>9.2.2 为列表生成HTML代码</h3><p>旧派Unix的方法是用sed或awk，新学派的解决方案可能集中在Python或Perl</p>
<h1 id="ch10-配置：迈出正确的第一步"><a href="#ch10-配置：迈出正确的第一步" class="headerlink" title="ch10 配置：迈出正确的第一步"></a>ch10 配置：迈出正确的第一步</h1><p>Unix的程序和周边环境交流的方式分类</p>
<ol>
<li>启动环境查询：本章讨论</li>
<li>交互通道：下一章讨论</li>
</ol>
<h2 id="10-1-什么应是可配置的"><a href="#10-1-什么应是可配置的" class="headerlink" title="10.1 什么应是可配置的"></a>10.1 什么应是可配置的</h2><p>答：一切。Unix程序员主要为同行和最老练的用户而设计</p>
<p>什么不应该可配置？</p>
<ol>
<li>能可靠地进行自动检测的东西。经验法则：提高适应能力，除非这样做会产生超过0.7秒的延迟</li>
<li>用户不应该看到优化开关</li>
<li>能用脚本包装器或简单管道实现的任务，不要用配置开关</li>
</ol>
<p>想增加配置选项时问4个问题</p>
<h2 id="10-2-配置在哪里"><a href="#10-2-配置在哪里" class="headerlink" title="10.2 配置在哪里"></a>10.2 配置在哪里</h2><p>局部设置覆盖全局设置：</p>
<ol>
<li>/etc或其他固有位置</li>
<li>由系统设置的环境变量</li>
<li>用户主目录中的运行控制文件</li>
<li>由用户设置的环境变量</li>
<li>启动程序的命令行所传递的开关和参数</li>
</ol>
<h2 id="10-3-运行控制文件"><a href="#10-3-运行控制文件" class="headerlink" title="10.3 运行控制文件"></a>10.3 运行控制文件</h2><p>如果程序是解释器，那运行控制文件就以该语言语法写成。此外，广泛遵循的有关运行控制语法的设计规定：</p>
<ol>
<li>支持说明性注释，并以#开始</li>
<li>不要区别隐匿的空白符</li>
<li>把多个空行和注释行视为单个空行</li>
<li>词法上把文件视作简单的用空白分隔的标记序列，或多行标记</li>
<li>支持以字符串语法对内嵌空白符的标记</li>
<li>支持反斜杠语法以在字符串中嵌入特殊字符</li>
</ol>
<h3 id="10-3-1-实例分析：-netrc文件"><a href="#10-3-1-实例分析：-netrc文件" class="headerlink" title="10.3.1 实例分析：.netrc文件"></a>10.3.1 实例分析：.netrc文件</h3><p>能理解它的有：所有FTP客户端、部分telnet客户端、smbclient命令行工具和fetchmail程序</p>
<h3 id="10-3-2-到其他操作系统的可移植性"><a href="#10-3-2-到其他操作系统的可移植性" class="headerlink" title="10.3.2 到其他操作系统的可移植性"></a>10.3.2 到其他操作系统的可移植性</h3><p>大多数非Unix操作系统缺少用户级主目录的概念，配置信息大多存放在Win注册表或程序运行目录</p>
<h2 id="10-4-环境变量"><a href="#10-4-环境变量" class="headerlink" title="10.4 环境变量"></a>10.4 环境变量</h2><ul>
<li>在shell中键入set查询</li>
<li>在C和C++中由库函数getenv查询</li>
</ul>
<h3 id="10-4-1-系统环境变量"><a href="#10-4-1-系统环境变量" class="headerlink" title="10.4.1 系统环境变量"></a>10.4.1 系统环境变量</h3><p><code>set | egrep &#39;USER|LOGNAME|HOME|COLNUMS|LINES|SHELL|TERM&#39;</code>以及众所周知的PATH</p>
<p>当一个环境变量包含多个值域，使用冒号作为分隔符是一个传统。bash和ksh总是把环境变量中冒号分隔的字段解释为文件名，把字段中的<code>~</code>扩展成用户主目录</p>
<h3 id="10-4-2-用户环境变量"><a href="#10-4-2-用户环境变量" class="headerlink" title="10.4.2 用户环境变量"></a>10.4.2 用户环境变量</h3><p>环境变量值并不真正适合把结构化信息传递到程序中，现代Unix倾向于使用dotfile</p>
<p>必须由大量不同应用程序共享、独立于应用程序的优先选项：<br><code>set | egrep &#39;EDIT|MAILER|PAGER|BROWSER&#39;</code><br>在ubuntu已经查不到这些了</p>
<h3 id="10-4-3-何时使用环境变量"><a href="#10-4-3-何时使用环境变量" class="headerlink" title="10.4.3 何时使用环境变量"></a>10.4.3 何时使用环境变量</h3><ol>
<li>例如：多个仿真终端会查询同样的dotfile，但可能有不同的COLNUMS、LINES和TERM</li>
<li>变量值随点文件不同而频繁改变，但每次启动都不变化。例如：CVS版本控制系统</li>
<li>进程唯一的覆盖必须以不要求改变命令行调用的方式来表述。例如：ld改变库加载的位置</li>
</ol>
<h3 id="10-4-4-到其他操作系统的可移植性非常有限"><a href="#10-4-4-到其他操作系统的可移植性非常有限" class="headerlink" title="10.4.4 到其他操作系统的可移植性非常有限"></a>10.4.4 到其他操作系统的可移植性非常有限</h3><p>Microsoft支持PATH但不支持Unix程序员认为理所应当的进程ID和当前工作路径等等；传统的MacOS没有环境变量的对应物</p>
<h2 id="10-5-命令行选项"><a href="#10-5-命令行选项" class="headerlink" title="10.5 命令行选项"></a>10.5 命令行选项</h2><p>区分命令行选项和普通参数的3中约定</p>
<ol>
<li>原始的Unix风格：以连字符开头，后面不带参数的模式标志选项可组合在一起使用，大写字符通常是小写字符选项的特殊变种</li>
<li>GNU风格：以两个连字符开头，选项参数既可以用空白分隔也可以用等号分隔</li>
<li>X toolkit风格：不能和前两者很好地兼容，不宜使用</li>
</ol>
<p>许多工具都接受一个不带任何选项字母的单个连字符，作为伪文件名，指示应用程序从标准输入中读取数据。也习惯把双连字符后面的参数按照字面意义处理</p>
<h3 id="10-5-1-从-a到-z的命令行选项"><a href="#10-5-1-从-a到-z的命令行选项" class="headerlink" title="10.5.1 从-a到-z的命令行选项"></a>10.5.1 从-a到-z的命令行选项</h3><table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有对象</td>
</tr>
<tr>
<td>-f</td>
<td>指定读入数据的文件</td>
</tr>
<tr>
<td>-l</td>
<td>产生输出的长格式版本</td>
</tr>
<tr>
<td>-o</td>
<td>将所有输出重定向到指定的输出文件</td>
</tr>
<tr>
<td>-q</td>
<td>以安静模式运行</td>
</tr>
<tr>
<td>-r</td>
<td>递归地处理目录和文件</td>
</tr>
<tr>
<td>-s</td>
<td>以绝对缄默（安静）模式运行</td>
</tr>
<tr>
<td>-v</td>
<td>生成详细输出</td>
</tr>
<tr>
<td>-y</td>
<td>对所有问题回答yes</td>
</tr>
</tbody></table>
<h3 id="10-5-2-到其他操作系统的可移植性"><a href="#10-5-2-到其他操作系统的可移植性" class="headerlink" title="10.5.2 到其他操作系统的可移植性"></a>10.5.2 到其他操作系统的可移植性</h3><p>Win的选项字符通常用<code>/</code></p>
<h2 id="10-6-如何挑选方法"><a href="#10-6-如何挑选方法" class="headerlink" title="10.6 如何挑选方法"></a>10.6 如何挑选方法</h2><p>环境变量通常覆盖dotfile的设置，但又可能被命令行选项所覆盖。良好的实践是如同make提供-e选项，从而可以覆盖掉环境变量的设置或运行控制文件中的声明。</p>
<h3 id="10-6-1-fetchmail"><a href="#10-6-1-fetchmail" class="headerlink" title="10.6.1 fetchmail"></a>10.6.1 fetchmail</h3><p>fetchmail仅使用USER和HOME两个环境变量；HOME用于查找<code>.fetchmailrc</code>，没有系统级dotfile，可以从<code>.netrc</code>检索“主机/登录/口令”三元组。</p>
<p>命令行选项集重复了大部分<code>.fetchmailrc</code>所能够表达的内容。但结果是只有<code>--fetchall和--verbose</code>有高需求</p>
<h3 id="10-6-2-XFree86服务器"><a href="#10-6-2-XFree86服务器" class="headerlink" title="10.6.2 XFree86服务器"></a>10.6.2 XFree86服务器</h3><p>在启动时，XFree86服务器检查系统级运行控制文件XF86Config获得硬件配置，然后借助HOME查找<code>.Xdefault</code>和<code>.xinitrc</code></p>
<p>同一台主机运行的多个实例共享同样的运行控制文件，但可以通过选项设置各自唯一的显示号</p>
<h2 id="10-7-论打破规则"><a href="#10-7-论打破规则" class="headerlink" title="10.7 论打破规则"></a>10.7 论打破规则</h2><p>常规方法都失败时，遵循补救原则给出正确的错误反馈</p>
<h1 id="ch11-接口：Unix环境下的用户接口设计模式"><a href="#ch11-接口：Unix环境下的用户接口设计模式" class="headerlink" title="ch11 接口：Unix环境下的用户接口设计模式"></a>ch11 接口：Unix环境下的用户接口设计模式</h1><p>接口代码占用的开发时间通常&gt;40%</p>
<p>Unix接口设计的传统：通讯方式的前瞻性设计、最小立异原则</p>
<h2 id="11-1-最小立异原则的应用"><a href="#11-1-最小立异原则的应用" class="headerlink" title="11.1 最小立异原则的应用"></a>11.1 最小立异原则的应用</h2><p>尽量允许用户将接口功能委派给熟悉的程序来完成。例如git commit调用文本编辑器</p>
<p>不能委派时，那就效仿。如果必须实现一个内嵌的编辑器，编辑明令最好是著名命令集的一个子集</p>
<h2 id="11-2-Unix接口设计的历史"><a href="#11-2-Unix接口设计的历史" class="headerlink" title="11.2 Unix接口设计的历史"></a>11.2 Unix接口设计的历史</h2><p>CLI -&gt; 在字符阵列终端屏幕绘图 -&gt; 开源的 X Window -&gt; 基于X的工具包和窗口管理器</p>
<h2 id="11-3-接口设计评估"><a href="#11-3-接口设计评估" class="headerlink" title="11.3 接口设计评估"></a>11.3 接口设计评估</h2><p>如何挑选接口风格，使之能适合程序应用和受众群体？五种度量标准</p>
<ol>
<li>简洁：一个事务处理需要的动作时间及复杂度有较低的上限</li>
<li>表现力：接口可以触发相当广泛的行为</li>
<li>易用性：与接口要求用户记忆的东西成反比</li>
<li>透明度：所见即所得，用户在使用接口时几乎没有什么状态需要记忆<ul>
<li>可显性大部分独立于接口风格，本章不把可显性作为衡量标准</li>
</ul>
</li>
<li>脚本化能力：接口能够容易地为其他程序所使用<ul>
<li>自动完成重复的任务</li>
</ul>
</li>
</ol>
<h2 id="11-4-CLI和可视接口之间的权衡"><a href="#11-4-CLI和可视接口之间的权衡" class="headerlink" title="11.4 CLI和可视接口之间的权衡"></a>11.4 CLI和可视接口之间的权衡</h2><ol>
<li><p>CLI优势：更具表达力和脚本化能力，通常（但并不总是）更简洁</p>
</li>
<li><p>CLI劣势：易用性低（需要记忆），透明度通常也很低</p>
<ul>
<li>GUI也存在自身的问题：难以找到正确的按钮</li>
</ul>
</li>
<li><p>SQL等等命令式微型语言表达力最强，但是易用性最低。但是当接口能力和灵活性至关重要时，它们的威力就无与伦比。如果设计得当，脚本化能力也能得高分</p>
</li>
<li><p>绘图、网页浏览器和ppt天然就是可视的，这些应用程序定义域具有以下特性</p>
<ul>
<li>透明性有极端价值</li>
<li>问题定义域的原语操作本身就是可视的：画这个、显示所指物、把它放到这儿</li>
</ul>
</li>
<li><p>在那些不是天然可视的应用中，可视接口最适用于初学用户简单一次性的或者很少发生的任务。随着用户变得越来越熟练，CLI的简洁性和表达力变得要比避免记忆负担更有价值。当问题规模变大、程序行为日趋单一、过程化和重复时，CLI也能发挥效用</p>
</li>
<li><p>甚至在天然可视化的定义域中，问题规模的增大也会使天平向CLI风格倾斜。例如网页图片的爬取和图像处理中的批量修改颜色表。</p>
</li>
<li><p>GIMP如果要为一对文件生成缩略图，往往是通过脚本语言编写的插件去调用内部的CLI图形编辑器script-fu</p>
</li>
</ol>
<p>长远来看，既支持CLI又支持可视接口很重要</p>
<h3 id="11-4-1-对比dc-bc与桌面计算器xcalc"><a href="#11-4-1-对比dc-bc与桌面计算器xcalc" class="headerlink" title="11.4.1 对比dc/bc与桌面计算器xcalc"></a>11.4.1 对比dc/bc与桌面计算器xcalc</h3><p>dc可以处理无限精度的算术运算，bc基于dc实现</p>
<h2 id="11-5-透明、表现力和可配置"><a href="#11-5-透明、表现力和可配置" class="headerlink" title="11.5 透明、表现力和可配置"></a>11.5 透明、表现力和可配置</h2><p>接口是程序员写给程序员的。如果不了解终端用户的意图，最好不要迁就或者放马后炮</p>
<ul>
<li>可配置能力的另一面：良好的默认值和简单恢复所有默认值的方法</li>
<li>表现力的另一面：在程序本身或者在文档中指导使用方法</li>
</ul>
<p>透明的接口既具备高级功能又不碍眼</p>
<p>直观性不同于易用性。诺基亚即使有相当规模的记忆负担，然而只要基本操作是容易的，并且存在一个发现路径，允许通过简单操作让隐藏在更深角落的功能能够一次到位地触发</p>
<h2 id="11-6-Unix接口设计模式"><a href="#11-6-Unix接口设计模式" class="headerlink" title="11.6 Unix接口设计模式"></a>11.6 Unix接口设计模式</h2><h3 id="11-6-1-过滤器模式"><a href="#11-6-1-过滤器模式" class="headerlink" title="11.6.1 过滤器模式"></a>11.6.1 过滤器模式</h3><p>定义过滤器的3原则</p>
<ol>
<li>Postel原则：宽进严出</li>
<li>不需要的信息也绝不丢弃</li>
<li>绝不增加无用数据。对格式的控制都应该是可选的</li>
</ol>
<p>下述3个模式类似过滤器</p>
<h3 id="11-6-2-Cantrip模式：clear、rm、touch、startx"><a href="#11-6-2-Cantrip模式：clear、rm、touch、startx" class="headerlink" title="11.6.2 Cantrip模式：clear、rm、touch、startx"></a>11.6.2 Cantrip模式：clear、rm、touch、startx</h3><h3 id="11-6-3-源模式：ls、who、ps、报表产生器"><a href="#11-6-3-源模式：ls、who、ps、报表产生器" class="headerlink" title="11.6.3 源模式：ls、who、ps、报表产生器"></a>11.6.3 源模式：ls、who、ps、报表产生器</h3><h3 id="11-6-4-接收器模式：lpr打印假脱机程序、邮件发送方式下的mail程序"><a href="#11-6-4-接收器模式：lpr打印假脱机程序、邮件发送方式下的mail程序" class="headerlink" title="11.6.4 接收器模式：lpr打印假脱机程序、邮件发送方式下的mail程序"></a>11.6.4 接收器模式：lpr打印假脱机程序、邮件发送方式下的mail程序</h3><h3 id="11-6-5-编译器模式：也用于压缩-解压或图像转换程序上"><a href="#11-6-5-编译器模式：也用于压缩-解压或图像转换程序上" class="headerlink" title="11.6.5 编译器模式：也用于压缩/解压或图像转换程序上"></a>11.6.5 编译器模式：也用于压缩/解压或图像转换程序上</h3><p>上述5个模式都不是交互的</p>
<h3 id="11-6-6-ed模式是交互的，包括：ftp、sh"><a href="#11-6-6-ed模式是交互的，包括：ftp、sh" class="headerlink" title="11.6.6 ed模式是交互的，包括：ftp、sh"></a>11.6.6 ed模式是交互的，包括：ftp、sh</h3><h3 id="11-6-7-Roguelike模式：vi、emacs、lynx网页浏览器、多数Unix邮件阅读器和新闻阅读器"><a href="#11-6-7-Roguelike模式：vi、emacs、lynx网页浏览器、多数Unix邮件阅读器和新闻阅读器" class="headerlink" title="11.6.7 Roguelike模式：vi、emacs、lynx网页浏览器、多数Unix邮件阅读器和新闻阅读器"></a>11.6.7 Roguelike模式：vi、emacs、lynx网页浏览器、多数Unix邮件阅读器和新闻阅读器</h3><p>来自rogue——使用字符阵列显示的游戏</p>
<p>命令通常是单键触发且不回显</p>
<h3 id="11-6-8-引擎和接口分离模式"><a href="#11-6-8-引擎和接口分离模式" class="headerlink" title="11.6.8 引擎和接口分离模式"></a>11.6.8 引擎和接口分离模式</h3><p>MVC</p>
<ol>
<li>模型就是Unix世界的引擎，例如数据库服务器</li>
<li>视图渲染对象，视图由模型通知更新，而不是由控制器显式请求</li>
<li>控制器处理用户的请求并将它们作为命令传递给模型</li>
</ol>
<p>下面是这个模式的几个变种</p>
<h4 id="11-6-8-1-配置者-执行者组合：fetchmail专注于后台，fetchmailconf醉心于GUI"><a href="#11-6-8-1-配置者-执行者组合：fetchmail专注于后台，fetchmailconf醉心于GUI" class="headerlink" title="11.6.8.1 配置者/执行者组合：fetchmail专注于后台，fetchmailconf醉心于GUI"></a>11.6.8.1 配置者/执行者组合：fetchmail专注于后台，fetchmailconf醉心于GUI</h4><h4 id="11-6-8-2-假脱机-守护进程组合：守护进程不断轮询spool目录，作业成功后从spool目录删除相关请求"><a href="#11-6-8-2-假脱机-守护进程组合：守护进程不断轮询spool目录，作业成功后从spool目录删除相关请求" class="headerlink" title="11.6.8.2 假脱机/守护进程组合：守护进程不断轮询spool目录，作业成功后从spool目录删除相关请求"></a>11.6.8.2 假脱机/守护进程组合：守护进程不断轮询spool目录，作业成功后从spool目录删除相关请求</h4><h4 id="11-6-8-3-驱动-引擎组合："><a href="#11-6-8-3-驱动-引擎组合：" class="headerlink" title="11.6.8.3 驱动/引擎组合："></a>11.6.8.3 驱动/引擎组合：</h4><h4 id="11-6-8"><a href="#11-6-8" class="headerlink" title="11.6.8."></a>11.6.8.</h4><p><strong>本章未读完</strong></p>
<h1 id="ch12-优化"><a href="#ch12-优化" class="headerlink" title="ch12 优化"></a>ch12 优化</h1><h2 id="12-1-什么也别做，就站在那儿"><a href="#12-1-什么也别做，就站在那儿" class="headerlink" title="12.1 什么也别做，就站在那儿"></a>12.1 什么也别做，就站在那儿</h2><p>摩尔定律暗示：晚半年买电脑就可以获得26%的性能提升</p>
<h2 id="12-2-先估量，后优化"><a href="#12-2-先估量，后优化" class="headerlink" title="12.2 先估量，后优化"></a>12.2 先估量，后优化</h2><p>性能剖析程序（profiler）注意事项</p>
<ol>
<li>工具误差：很短的子程序往往看起来较实际费时</li>
<li>外部强加的延迟：磁盘和网络访问、缓存填充、进程切换。推荐回归测试</li>
<li>过多地调用图中顶部结点</li>
</ol>
<ul>
<li>gprof等时间分析工具将子程序的时间开销加到了调用程序中</li>
<li>推荐让高级例程尽可能多地调用底层例程、而不是内嵌代码</li>
</ul>
<p>用R或MATLAB研究多大的数据能放入缓存</p>
<h2 id="12-3-非定域性之害"><a href="#12-3-非定域性之害" class="headerlink" title="12.3 非定域性之害"></a>12.3 非定域性之害</h2><p>永远不要将核心数据结构和时间关键循环抛出缓存</p>
<ol>
<li>使用小型的核心数据结构</li>
<li>保持代码短小简单</li>
</ol>
<h2 id="12-4-吞吐量和延迟"><a href="#12-4-吞吐量和延迟" class="headerlink" title="12.4 吞吐量和延迟"></a>12.4 吞吐量和延迟</h2><p>尽量避免协议的往返</p>
<p>经验法则：尽可能低的时延设计，和忽略带宽成本，除非profiler明确告知该反其道而行。</p>
<p>面临吞吐量和延迟时间的权衡时，多数情况下选择低时延。</p>
<p>以“减少时延的三种常规策略”结束本章</p>
<h3 id="12-4-1-对可以共享启动开销的事务进行批处理"><a href="#12-4-1-对可以共享启动开销的事务进行批处理" class="headerlink" title="12.4.1 对可以共享启动开销的事务进行批处理"></a>12.4.1 对可以共享启动开销的事务进行批处理</h3><p>对图形API选择正确的物理刷新间隔</p>
<p>编写持续的服务守护进程，而不是每次启动CLI服务器带来全新会话。理由如下</p>
<ol>
<li>控制共享资源的更新</li>
<li>分期偿还通过多请求读取后台数据库的成本<br>例如DNS后台服务程序named访问保持在内存中的缓存</li>
</ol>
<h3 id="12-4-2-允许事务重叠"><a href="#12-4-2-允许事务重叠" class="headerlink" title="12.4.2 允许事务重叠"></a>12.4.2 允许事务重叠</h3><p>IMAP请求带标记，以允许将好几条读请求以流方式发向IMAP服务器</p>
<h3 id="12-4-3-缓存"><a href="#12-4-3-缓存" class="headerlink" title="12.4.3 缓存"></a>12.4.3 缓存</h3><p>二进制缓存是一项不稳定的技法，应尽量避免。在某种情况下为低延迟而进行的专门优化工作，常常可以更好地改善应用程序设计，从而不再有这样的瓶颈——或者甚至可以转而加速文件系统或是虚拟内存实现</p>
<h1 id="ch13-复杂度：尽可能简单，但别简单过了头"><a href="#ch13-复杂度：尽可能简单，但别简单过了头" class="headerlink" title="ch13 复杂度：尽可能简单，但别简单过了头"></a>ch13 复杂度：尽可能简单，但别简单过了头</h1><p>对“简单”的理解依赖于：</p>
<ul>
<li><a href="#ch04-%E6%A8%A1%E5%9D%97%E6%80%A7%EF%BC%9A%E4%BF%9D%E6%8C%81%E6%B8%85%E6%99%B0%EF%BC%8C%E4%BF%9D%E6%8C%81%E7%AE%80%E6%B4%81">ch04-模块性：保持清晰，保持简洁</a></li>
<li><a href="#ch11-%E6%8E%A5%E5%8F%A3%EF%BC%9AUnix%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">ch11-接口：Unix环境下的用户接口设计模式</a></li>
</ul>
<h2 id="13-1-谈谈复杂度"><a href="#13-1-谈谈复杂度" class="headerlink" title="13.1 谈谈复杂度"></a>13.1 谈谈复杂度</h2><h3 id="13-1-1-复杂度的三个来源"><a href="#13-1-1-复杂度的三个来源" class="headerlink" title="13.1.1 复杂度的三个来源"></a>13.1.1 复杂度的三个来源</h3><ol>
<li>实现负杂度：Unix程序员所注重的</li>
<li>接口复杂度：用户注重于界面的复杂度和记忆负担</li>
<li>代码量：更多行的代码意味着更多的bug</li>
</ol>
<p>两种尺度会导致不同方向变化</p>
<ol>
<li>manularity（人力尺度）陷阱：如果设计时首先考虑容易实现或代码规模，可能就会简单地将许多底层人物都抛给用户</li>
<li>blivet（硬撑）陷阱：通常发生在程序为适应及小规模系统而必须用汇编语言写成</li>
<li>adhocity（过专用）陷阱：例如一个网站工程，本需要集中式的关系数据库，却采用几个不同的关键数据文件，在页面生成时将它们包含的信息聚齐</li>
</ol>
<h3 id="13-1-2-接口复杂度和实现复杂度的折中"><a href="#13-1-2-接口复杂度和实现复杂度的折中" class="headerlink" title="13.1.2 接口复杂度和实现复杂度的折中"></a>13.1.2 接口复杂度和实现复杂度的折中</h3><ul>
<li>MIT哲学：更关注接口简单性。能够引导软件在抽象上做得更好</li>
<li>New Jersey哲学：更重视实现简单性。更具传播特质</li>
</ul>
<h3 id="13-1-3-本质的、选择的和偶然的复杂度"><a href="#13-1-3-本质的、选择的和偶然的复杂度" class="headerlink" title="13.1.3 本质的、选择的和偶然的复杂度"></a>13.1.3 本质的、选择的和偶然的复杂度</h3><p>仅十行的程序，再优雅也无法控制喷气客机</p>
<ul>
<li>偶然复杂度可以由良好的设计或者重新设计来去除</li>
<li>选择复杂度，同某个期望的功能相关联，只能由改变工程的目标来去除</li>
</ul>
<h3 id="13-1-4-映射复杂度"><a href="#13-1-4-映射复杂度" class="headerlink" title="13.1.4 映射复杂度"></a>13.1.4 映射复杂度</h3><p>|  图13.1  | 代码库规模 | 实现复杂度 | 接口复杂度 |<br>|偶然复杂度|<br>|选择复杂度|<br>|本质复杂度|</p>
<h3 id="13-1"><a href="#13-1" class="headerlink" title="13.1."></a>13.1.</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/06/unix-bian-cheng-yi-shu/" data-id="cl310rf3w0016gctkdibhg9yw" data-title="《UNIX编程艺术》读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-tcp-ip-xiang-jie" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/09/tcp-ip-xiang-jie/" class="article-date">
  <time class="dt-published" datetime="2021-05-09T06:01:57.000Z" itemprop="datePublished">2021-05-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/09/tcp-ip-xiang-jie/">《TCP/IP详解》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>读第二遍时做笔记的要求：简单的分组格式不要跳过，复杂的分组格式要指明图x-yy，不要跳过例子和习题。</p>
<ul>
<li><a href="#ch01-%E6%A6%82%E8%BF%B0">ch01 概述</a></li>
<li><a href="#ch02-%E9%93%BE%E8%B7%AF%E5%B1%82">ch02 链路层</a></li>
<li><a href="#ch03-IP%EF%BC%9A%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">ch03 IP：网际协议</a></li>
<li><a href="#ch04-ARP%EF%BC%9A%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">ch04 ARP：地址解析协议</a></li>
<li><a href="#ch05-RARP%EF%BC%9A%E9%80%86%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">ch05 RARP：逆地址解析协议</a></li>
<li><a href="#ch06-ICMP%EF%BC%9AInternet%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE">ch06 ICMP：Internet控制报文协议</a></li>
<li><a href="#ch07-Ping%E7%A8%8B%E5%BA%8F">ch07 Ping程序</a></li>
<li><a href="#ch08-Traceroute%E7%A8%8B%E5%BA%8F">ch08 Traceroute程序</a></li>
<li><a href="#ch09-IP%E9%80%89%E8%B7%AF">ch09 IP选路</a></li>
<li><a href="#ch10-%E5%8A%A8%E6%80%81%E9%80%89%E8%B7%AF%E5%8D%8F%E8%AE%AE">ch10 动态选路协议</a></li>
<li><a href="#ch11-UDP%EF%BC%9A%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">ch11 UDP：用户数据报协议</a></li>
<li><a href="#ch12-%E5%B9%BF%E6%92%AD%E5%92%8C%E5%A4%9A%E6%92%AD">ch12 广播和多播</a></li>
<li><a href="#ch13-IGMP%EF%BC%9AInternet%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE">ch13 IGMP：Internet组管理协议</a></li>
<li><a href="#ch14-DNS%EF%BC%9A%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F">ch14 DNS：域名系统</a></li>
<li><a href="#ch15-TFTP%EF%BC%9A%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">ch15 TFTP：简单文件传送协议</a></li>
<li><a href="#ch16-BOOTP%EF%BC%9A%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F%E5%8D%8F%E8%AE%AE">ch16 BOOTP：引导程序协议</a></li>
<li><a href="#ch17-TCP%EF%BC%9A%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">ch17 TCP：传输控制协议</a></li>
<li><a href="#ch18-TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E7%BB%88%E6%AD%A2">ch18 TCP连接的建立与终止</a></li>
<li><a href="#ch19-TCP%E7%9A%84%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%E6%B5%81">ch19 TCP的交互数据流</a></li>
<li><a href="#ch20-TCP%E7%9A%84%E6%88%90%E5%9D%97%E6%95%B0%E6%8D%AE%E6%B5%81">ch20 TCP的成块数据流</a></li>
<li><a href="#ch21-TCP%E7%9A%84%E8%B6%85%E6%97%B6%E4%B8%8E%E9%87%8D%E4%BC%A0">ch21 TCP的超时与重传</a></li>
<li><a href="#ch22-TCP%E7%9A%84%E5%9D%9A%E6%8C%81%E5%AE%9A%E6%97%B6%E5%99%A8">ch22 TCP的坚持定时器</a></li>
<li><a href="#ch23-TCP%E7%9A%84%E4%BF%9D%E6%B4%BB%E5%AE%9A%E6%97%B6%E5%99%A8">ch23 TCP的保活定时器</a></li>
<li><a href="#ch24-TCP%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%92%8C%E6%80%A7%E8%83%BD">ch24 TCP的未来和性能</a></li>
<li><a href="#ch25-SNMP%EF%BC%9A%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE">ch25 SNMP：简单网络管理协议</a></li>
<li><a href="#ch26-Telnet%E5%92%8CRlogin%EF%BC%9A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95">ch26 Telnet和Rlogin：远程登录</a></li>
<li><a href="#ch27-FTP%EF%BC%9A%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE">ch27 FTP：文件传送协议</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本书用tcpdump观察TCP/IP协议族的运作过程</p>
<h2 id="本书的组织"><a href="#本书的组织" class="headerlink" title="本书的组织"></a>本书的组织</h2><p>自底向上与功能方法</p>
<h2 id="读者"><a href="#读者" class="headerlink" title="读者"></a>读者</h2><p>具有一定TCP/IP背景知识的读者可以从第7章开始阅读，然后着重阅读感兴趣的某些章节。</p>
<h2 id="用作测试的系统"><a href="#用作测试的系统" class="headerlink" title="用作测试的系统"></a>用作测试的系统</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">                                                        Internet</span><br><span class="line">                                                           ^</span><br><span class="line">                                                           |</span><br><span class="line">  AIX 3.2.2        Solaris 2.2       SunOS 4.1.1           | .104.1</span><br><span class="line">+-----------+     +-----------+     +-----------+     +----*------+</span><br><span class="line">|    aix    |     |  solaris  |     |  gemini   |     |  gateway  | Cisco路由器</span><br><span class="line">+-----*-----+     +-----*-----+     +-----*-----+     +----*------+</span><br><span class="line">      | .1.92           | .1.32           | .1.11          | .1.4</span><br><span class="line">      |                 |                 |                |</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">                                   以太网                |</span><br><span class="line">                                                         | .1.183</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                   |   netb    | Telebit</span><br><span class="line">                                                   +-----*-----+ NetBlazer</span><br><span class="line">                                                         |</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                   |调制解调器 |</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                         |</span><br><span class="line">                                                   SLIP  |（拨号）</span><br><span class="line">                                                         |</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                   |调制解调器 |</span><br><span class="line">                                                   +-----*-----+</span><br><span class="line">                                                         |</span><br><span class="line">                                                         |</span><br><span class="line"> BSD&#x2F;386 1.0                   BSD&#x2F;386 1.0    SunOS 4.1.3| .1.29       SVR4</span><br><span class="line">+-----------+                 +-----------+      +-------*---+     +-----------+</span><br><span class="line">|   slip    |-----------------|   bsdi    |      |    sun    |     |   svr4    |</span><br><span class="line">+-----------+ .13.65   .13.66 +----*------+      +----*------+     +----*------+</span><br><span class="line">                                   | .13.35           | .13.33          | .13.34</span><br><span class="line">                                   |                  |                 |</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">                                             以太网</span><br></pre></td></tr></table></figure>
<p>在这个图中（作者的子网），大多数的例子都运行在下面四个系统中。图中所有的IP地址属于B类地址，网络号为140.252。所有的主机名属于.tuc.noao.edu这个域</p>
<h1 id="ch01-概述"><a href="#ch01-概述" class="headerlink" title="ch01 概述"></a>ch01 概述</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p>本章的目的是为本书其余章节提供充分的背景知识</p>
<h2 id="1-2-分层"><a href="#1-2-分层" class="headerlink" title="1.2 分层"></a>1.2 分层</h2><p>TCP/IP通常被认为是一个四层协议系统。下三层则一般在（操作系统）内核中执行。</p>
<p>网络接口层和应用层的目的是很显然的<br>网络层和运输层之间的区别不那么明显。为什么要把它们划分成两个不同的层次呢？为了理解这一点，我们必须把视野从单个网络扩展到一组网络。</p>
<p>网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务。</p>
<p>现在网关这个术语只用来表示应用层网关：一个连接两种不同协议族的进程（例如，TCP/IP和IBM的SNA），它为某个特定的应用程序服务（常常是电子邮件或文件传输）。</p>
<p>TCP/IP倾向于使用路由器而不是网桥来连接网络</p>
<h2 id="1-3-TCP-IP的分层"><a href="#1-3-TCP-IP的分层" class="headerlink" title="1.3 TCP/IP的分层"></a>1.3 TCP/IP的分层</h2><p>在图1-4中，我们给出了一个跳过了运输层而直接访问IP的应用程序。这是很少见的，但也是可能的。</p>
<p>尽管ICMP主要被IP使用，但应用程序也有可能访问它。</p>
<p>IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p>
<p>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p>
<h2 id="1-4-互联网的地址"><a href="#1-4-互联网的地址" class="headerlink" title="1.4 互联网的地址"></a>1.4 互联网的地址</h2><p>多接口主机具有多个IP地址，其中每个接口都对应一个IP地址。</p>
<p>InterNIC只分配网络号。主机号的分配由系统管理员来负责。</p>
<h2 id="1-5-域名系统"><a href="#1-5-域名系统" class="headerlink" title="1.5 域名系统"></a>1.5 域名系统</h2><p>任何应用程序都可以调用一个标准的库函数来查看给定名字的主机的IP地址。</p>
<p>大多数使用主机名作为参数的应用程序也可以把IP地址作为参数。</p>
<h2 id="1-6-封装"><a href="#1-6-封装" class="headerlink" title="1.6 封装"></a>1.6 封装</h2><p>运输层协议在生成报文首部时要存入一个应用程序的标识符。TCP和UDP都用一个16bit的端口号来表示不同的应用程序。</p>
<h2 id="1-7-分用"><a href="#1-7-分用" class="headerlink" title="1.7 分用"></a>1.7 分用</h2><p>这些分层协议盒并不都是完美的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">应用程序...应用程序  应用程序...应用程序</span><br><span class="line">            ^     ^</span><br><span class="line">            |     |</span><br><span class="line">           TCP  UDP</span><br><span class="line">ICMP  IGMP  &#x2F;  &#x2F;</span><br><span class="line">    \   |  &#x2F; &#x2F;</span><br><span class="line">     \  | &#x2F;&#x2F;</span><br><span class="line">        IP</span><br><span class="line">ARP     |       RARP</span><br><span class="line">   \    |     &#x2F;</span><br><span class="line">    \   |    &#x2F;</span><br><span class="line">以太网驱动程序</span><br><span class="line">    ^</span><br><span class="line">    |</span><br><span class="line">进入的帧</span><br></pre></td></tr></table></figure>
<p>图1-8以太网数据帧的分用过程</p>
<h2 id="1-8-客户-服务器模型"><a href="#1-8-客户-服务器模型" class="headerlink" title="1.8 客户-服务器模型"></a>1.8 客户-服务器模型</h2><p>服务分为两种类型：重复型或并发型。</p>
<p>并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。</p>
<p>一般来说，TCP服务器是并发的，而UDP服务器是重复的，但也存在一些例外。</p>
<h2 id="1-9-端口号"><a href="#1-9-端口号" class="headerlink" title="1.9 端口号"></a>1.9 端口号</h2><p>服务器一般都是通过知名端口号来识别的。<br>任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet号分配机构（Internet Assigned Numbers Authority, IANA）来管理。</p>
<p>客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以了。客户端口号又称作临时端口号（即存在时间很短暂）。</p>
<p>大多数TCP/IP实现给临时端口分配1024～5000之间的端口号。大于5000的端口号是为其他服务器预留的（Internet上并不常用的服务)。</p>
<p>Unix系统有保留端口号的概念。只有具有超级用户特权的进程才允许给它自己分配一个保留端口号。</p>
<p>这些端口号介于1～1023之间，一些应用程序（如有名的Rlogin，26.2节）将它作为客户与服务器之间身份认证的一部分。</p>
<h2 id="1-10-标准化过程"><a href="#1-10-标准化过程" class="headerlink" title="1.10 标准化过程"></a>1.10 标准化过程</h2><p>有四个小组在负责Internet技术。</p>
<h2 id="1-11-RFC"><a href="#1-11-RFC" class="headerlink" title="1.11 RFC"></a>1.11 RFC</h2><p>所有关于Internet的正式标准都以RFC（Request for Comment）文档出版。另外，大量的RFC并不是正式的标准，出版的目的只是为了提供信息。RFC的篇幅从1页到200页不等。每一项都用一个数字来标识，如RFC 1122，数字越大说明RFC的内容越新。</p>
<h2 id="1-12-标准的简单服务"><a href="#1-12-标准的简单服务" class="headerlink" title="1.12 标准的简单服务"></a>1.12 标准的简单服务</h2><p>有一些标准的简单服务几乎每种实现都要提供。在本书中我们将使用其中的一些服务程序，而客户程序通常选择Telnet。图1-9描述了这些服务。</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>端口号</th>
<th>RFC</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>echo</td>
<td>7</td>
<td>862</td>
<td>服务器返回客户发送的所有内容</td>
</tr>
<tr>
<td>discard</td>
<td>9</td>
<td>863</td>
<td>服务器返回丢弃发送的所有内容</td>
</tr>
<tr>
<td>daytime</td>
<td>13</td>
<td>867</td>
<td>服务器以可读形式返回时间和日期</td>
</tr>
<tr>
<td>chargen</td>
<td>19</td>
<td>864</td>
<td>TCP服务器发送一串连续的字符流，UDP服务器发送一个随机长度的数据报</td>
</tr>
<tr>
<td>time</td>
<td>37</td>
<td>848</td>
<td>服务器返回一个二进制形式的32bit数，表示从UTC时间1900至今的秒数</td>
</tr>
</tbody></table>
<h2 id="1-13-互联网"><a href="#1-13-互联网" class="headerlink" title="1.13 互联网"></a>1.13 互联网</h2><p>internet意思是用一个共同的协议族把多个网络连接在一起。而Internet指的是世界范围内通过TCP/IP互相通信的所有主机集合</p>
<h2 id="1-14-实现"><a href="#1-14-实现" class="headerlink" title="1.14 实现"></a>1.14 实现</h2><p>在本书中，我们将使用“伯克利派生系统”来指SunOS 4.x、SVR4以及AIX 3.2等那些基于伯克利源代码开发的系统。这些系统有很多共同之处，经常包含相同的错误。</p>
<h2 id="1-15-应用编程接口"><a href="#1-15-应用编程接口" class="headerlink" title="1.15 应用编程接口"></a>1.15 应用编程接口</h2><p>使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口：Transport Layer Interface）。</p>
<h2 id="1-16-测试网络"><a href="#1-16-测试网络" class="headerlink" title="1.16 测试网络"></a>1.16 测试网络</h2><p><a href="#%E7%94%A8%E4%BD%9C%E6%B5%8B%E8%AF%95%E7%9A%84%E7%B3%BB%E7%BB%9F">图1-11</a>是本书中所有的例子运行的测试网络。</p>
<h2 id="1-17-小结"><a href="#1-17-小结" class="headerlink" title="1.17 小结"></a>1.17 小结</h2><p>略</p>
<h2 id="ch01-习题"><a href="#ch01-习题" class="headerlink" title="ch01 习题"></a>ch01 习题</h2><ol>
<li>请计算最多有多少个A类、B类和C类网络号。</li>
</ol>
<ul>
<li>答案：分别为2^7-2、2^14-2、2^21-2。每一部分都减去2是因为全0或全1网络ID是非法的。</li>
</ul>
<ol>
<li>用匿名FTP（见27.3节）从主机nic.merit.edu上获取文件nsfnet/statistics/history.netcount。推算何时会用完所有的网络地址</li>
</ol>
<ul>
<li>答案：2000年</li>
</ul>
<ol>
<li>获取一份主机需求RFC拷贝[Braden 1989a]，阅读有关应用于TCP/IP协议族每一层的稳健性原则。这个原则的参考对象是什么？</li>
</ol>
<ul>
<li>答案：自由地接收，保守地发送</li>
</ul>
<ol>
<li>获取一份最新的赋值RFC拷贝。“quote of the day”协议的有名端口号是什么？哪个RFC对该协议进行了定义？</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>如果你有一个接入TCP/IP互联网的主机帐号，它的主IP地址是多少？这台主机是否接入了Internet？它是多接口主机吗？</li>
</ol>
<ul>
<li>无答案。答：动态分配、是、不是</li>
</ul>
<ol>
<li>获取一份RFC 1000的拷贝，了解RFC这个术语从何而来。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>与Internet协会联系，<a href="mailto:&#105;&#x73;&#111;&#x63;&#x40;&#105;&#x73;&#x6f;&#x63;&#46;&#x6f;&#114;&#103;">&#105;&#x73;&#111;&#x63;&#x40;&#105;&#x73;&#x6f;&#x63;&#46;&#x6f;&#114;&#103;</a>或者+1703 648 9888，了解有关加入的情况。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>用匿名FTP从主机is.internic.net处获取文件about-internic/information-about-the-internic。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<h1 id="ch02-链路层"><a href="#ch02-链路层" class="headerlink" title="ch02 链路层"></a>ch02 链路层</h1><h2 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h2><p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件</p>
<p>在本章中，我们将详细讨论以太网链路层协议，两个串行接口链路层协议（SLIP和PPP），以及大多数实现都包含的环回（loopback）驱动程序。以太网和SLIP是本书中大多数例子使用的链路层。对MTU（最大传输单元）进行了介绍，这个概念在本书的后面章节中将多次遇到。我们还讨论了如何为串行线路选择MTU。</p>
<h2 id="2-2-以太网和IEEE-802封装"><a href="#2-2-以太网和IEEE-802封装" class="headerlink" title="2.2 以太网和IEEE 802封装"></a>2.2 以太网和IEEE 802封装</h2><p>以太网是当今TCP/IP采用的主要的局域网技术。它的速率为10 Mb/s，地址为48 bit。</p>
<p>802.2和802.3定义了一个与以太网不同的帧格式。</p>
<p>图2-1显示了两种不同形式的封装格式。</p>
<p>两种帧格式都采用48 bit（6字节）的目的地址和源地址（802.3允许使用16 bit的地址，但一般是48 bit地址）。这就是我们在本书中所称的硬件地址。ARP和RARP协议（第4章和第5章）对32 bit的IP地址和48 bit的硬件地址进行映射。</p>
<p>802.3标准定义的帧和以太网的帧都有最小长度要求。802.3规定数据部分必须至少为38字节，而对于以太网，则要求最少要有46字节。为了保证这一点，必须在不足的空间插入填充（pad）字节。</p>
<p>在本书中，我们在需要的时候将给出以太网的封装格式，因为这是最为常见的封装格式。</p>
<h2 id="2-3-尾部封装"><a href="#2-3-尾部封装" class="headerlink" title="2.3 尾部封装"></a>2.3 尾部封装</h2><p>通过把变长的字段移到尾部，节省内存到内存的复制过程。</p>
<p>现在，尾部封装已遭到反对</p>
<h2 id="2-4-SLIP：串行线路IP"><a href="#2-4-SLIP：串行线路IP" class="headerlink" title="2.4 SLIP：串行线路IP"></a>2.4 SLIP：串行线路IP</h2><p>SLIP适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet。</p>
<p>大多数实现以一个称作END（0xc0）的特殊字符开始和结束，还对IP报文中的ESC和END做转义。</p>
<p>SLIP是一种简单的帧封装方法，还有一些值得一提的缺陷：</p>
<ol>
<li>每一端必须知道对方的IP地址。没有办法把本端的IP地址通知给另一端。</li>
<li>数据帧中没有类型字段（类似于以太网中的类型字段）。如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输的报文被线路噪声影响而发生错误，只能通过上层协议来发现（另一种方法是，新型的调制解调器可以检测并纠正错误报文）。</li>
</ol>
<h2 id="2-5-压缩的SLIP"><a href="#2-5-压缩的SLIP" class="headerlink" title="2.5 压缩的SLIP"></a>2.5 压缩的SLIP</h2><p>CSLIP一般能把上面的40个字节压缩到3或5个字节。它能在CSLIP的每一端维持多达16个TCP连接</p>
<h2 id="2-6-PPP：点对点协议"><a href="#2-6-PPP：点对点协议" class="headerlink" title="2.6 PPP：点对点协议"></a>2.6 PPP：点对点协议</h2><p>PPP，点对点协议修改了SLIP协议中的所有缺陷。PPP包括以下三个部分：</p>
<ol>
<li>在串行链路上封装IP数据报的方法。PPP既支持数据为8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。</li>
<li>建立、配置及测试数据链路的链路控制协议（LCP：Link Control Protocol）。它允许通信双方进行协商，以确定不同的选项。</li>
<li>针对不同网络层协议的网络控制协议（NCP：Network Control Protocol）体系。当前RFC定义的网络层有IP、OSI网络层、DECnet以及AppleTalk。例如，IP NCP允许双方商定是否对报文首部进行压缩，类似于CSLIP（缩写词NCP也可用在TCP的前面）。</li>
</ol>
<p>图2-3是PPP数据帧的格式</p>
<ol>
<li>每一帧都以标志字符0x7e开始和结束。紧接着是一个地址字节，值始终是0xff，然后是一个值为0x03的控制字节。</li>
<li>接下来是协议字段，类似于以太网中类型字段的功能。当它的</li>
</ol>
<ul>
<li>值为0x0021时，表示信息字段是一个IP数据报；</li>
<li>值为0xc021时，表示信息字段是链路控制数据；</li>
<li>值为0x8021时，表示信息字段是网络控制数据。</li>
</ul>
<ol>
<li>CRC字段（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
<li>由于标志字符的值是0x7e，因此当该字符出现在信息字段中时，PPP需要对它进行转义。</li>
</ol>
<p>与SLIP类似，由于PPP经常用于低速的串行链路，因此减少每一帧的字节数可以降低应用程序的交互时延。利用链路控制协议，大多数的产品通过协商可以省略标志符和地址字段，并且把协议字段由2个字节减少到1个字节。如果我们把PPP的帧格式与前面的SLIP的帧格式（图2-2）进行比较会发现，PPP只增加了3个额外的字节：1个字节留给协议字段，另2个给CRC字段使用。另外，使用IP网络控制协议，大多数的产品可以通过协商采用Van Jacobson报文首部压缩方法（对应于CSLIP压缩），减小IP和TCP首部长度。</p>
<p>总的来说，PPP比SLIP具有下面这些优点：</p>
<ul>
<li>PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>每一帧都有循环冗余检验；</li>
<li>通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>链路控制协议可以对多个数据链路选项进行设置。<br>为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li>
</ul>
<h2 id="2-7-环回接口"><a href="#2-7-环回接口" class="headerlink" title="2.7 环回接口"></a>2.7 环回接口</h2><p>大多数的产品都支持环回接口（Loopback Interface），以允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信。A类网络号127就是为环回接口预留的。根据惯例，大多数系统把IP地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。</p>
<p>看上去用传输层和IP层的方法来处理环回数据似乎效率不高，但它简化了设计，因为环回接口可以被看作是网络层下面的另一个链路层。网络层把一份数据报传送给环回接口，就像传给其他链路层一样，只不过环回接口把它返回到IP的输入队列中。</p>
<h2 id="2-8-最大传输单元MTU"><a href="#2-8-最大传输单元MTU" class="headerlink" title="2.8 最大传输单元MTU"></a>2.8 最大传输单元MTU</h2><p>正如在图2-1看到的那样，以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500和1492字节。链路层的这个特性称作MTU，最大传输单元。不同类型的网络大多数都有一个上限。</p>
<p>图2-5列出了一些典型的MTU值,它们摘自RFC 1191[Mogul and Deering 1990]。点到点的链路层（如SLIP和PPP）的MTU并非指的是网络媒体的物理特性。相反，它是一个逻辑限制，目的是为交互使用提供足够快的响应时间。</p>
<h2 id="2-9-路径MTU"><a href="#2-9-路径MTU" class="headerlink" title="2.9 路径MTU"></a>2.9 路径MTU</h2><p>重要的不是两台主机所在网络的MTU的值，重要的是两台通信主机路径中的最小MTU。它被称作路径MTU。</p>
<p>两台主机之间的路径MTU不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从A到B的路由可能与从B到A的路由不同），因此路径MTU在两个方向上不一定是一致的。</p>
<h2 id="2-10-串行线路吞吐量计算"><a href="#2-10-串行线路吞吐量计算" class="headerlink" title="2.10 串行线路吞吐量计算"></a>2.10 串行线路吞吐量计算</h2><p>如果线路速率是9600 b/s，而一个字节有8bit，加上一个起始比特和一个停止比特，那么线路的速率就是960 B/s（字节/秒）。以这个速率传输一个1024字节的分组需要1066 ms。如果用SLIP链接运行一个交互式应用程序，同时还运行另一个应用程序如FTP发送或接收1024字节的数据，那么一般来说就必须等待一半的时间（533 ms）才能把交互式应用程序的分组数据发送出去。</p>
<p>假定交互分组数据可以在其他“大块”分组数据发送之前被发送出去。大多数的SLIP实现确实提供这类服务排队方法，把交互数据放在大块的数据前面。交互通信一般有Telnet、Rlogin以及FTP的控制部分（用户的命令，而不是数据）。</p>
<p>对于交互应用来说，等待533 ms是不能接受的。关于人的有关研究表明，交互响应时间超过100～200 ms就被认为是不好的</p>
<p>把SLIP的MTU缩短到256就意味着链路传输一帧最长需要266 ms，它的一半是133 ms（这是一般需要等待的时间）。这样情况会好一些，但仍然不完美。我们选择它的原因（与64或128相比）是因为大块数据提供良好的线路利用率（如大文件传输）。<br>如果把MTU降到256以下，那么将降低传输大块数据的最大吞吐量。</p>
<p>在后面的章节中，我们将用这些串行线路吞吐量的计算来验证数据从串行线路上通过的时间。</p>
<h2 id="2-11-小结"><a href="#2-11-小结" class="headerlink" title="2.11 小结"></a>2.11 小结</h2><p>TCP/IP成功的原因之一是它几乎能在任何数据链路技术上运行。</p>
<h2 id="ch02-习题"><a href="#ch02-习题" class="headerlink" title="ch02 习题"></a>ch02 习题</h2><ol>
<li>如果你的系统支持netstat(1)命令（参见3.9节），那么请用它确定系统上的接口及其MTU。</li>
</ol>
<ul>
<li>无答案。已上机实验</li>
</ul>
<h1 id="ch03-IP：网际协议"><a href="#ch03-IP：网际协议" class="headerlink" title="ch03 IP：网际协议"></a>ch03 IP：网际协议</h1><h2 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h2><p>所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输</p>
<p>IP仅提供最好的传输服务。发生错误时：丢弃该数据报，然后发送ICMP消息报给信源端。</p>
<p>无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。</p>
<h2 id="3-2-IP首部"><a href="#3-2-IP首部" class="headerlink" title="3.2 IP首部"></a>3.2 IP首部</h2><p>IP数据报的格式如图3-1所示。</p>
<p><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/3/images2/52im_1.png" alt="图3-1"></p>
<p>首部长度指的是首部占32 bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部最长为60个字节。在第8章中，我们将看到这种限制使某些选项如路由记录选项在当今已没有什么用处。普通IP数据报（没有任何选择项）字段的值是5。</p>
<p>服务类型（TOS）字段包括一个3bit的优先权子字段（现在已被忽略），4bit的TOS子字段和1bit未用位但必须置0。4bit的TO S分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4bit中只能置其中1bit。如果所有4bit均为0，那么就意味着是一般服务。RFC 1340[Reynolds and Postel 1992]描述了所有的标准应用如何设置这些服务类型。RFC 1349[Almquist 1992]对该RFC进行了修正，更为详细地描述了TOS的特性。</p>
<p>图3-2列出了对不同应用建议的TO S值。在最后一列中给出的是十六进制值，因为这就是在后面将要看到的tcpdump命令输出。</p>
<p>总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节</p>
<p>TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。<br>当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</p>
<p>首部检验和字段是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p>
<p>为了计算一份数据报的IP检验和，首先把检验和字段置为0。然后，对首部中每个16 bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中。当收到一份IP数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传。</p>
<p>ICMP、IGMP、UDP和TCP都采用相同的检验和算法，尽管TCP和UDP除了本身的首部和数据外，在IP首部中还包含不同的字段。<br>由于路由器经常只修改TTL字段（减1），因此当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算。</p>
<p>最后一个字段是任选项，是数据报中的一个可变长的可选信息。目前，这些任选项定义如下：</p>
<ul>
<li>安全和处理限制（用于军事领域，详细内容参见RFC 1108[Kent 1991]）</li>
<li>记录路径（让每个路由器都记下它的IP地址，见7.3节）</li>
<li>时间戳（让每个路由器都记下它的IP地址和时间，见7.4节）</li>
<li>宽松的源站选路（为数据报指定一系列必须经过的IP地址，见8.5节）</li>
<li>严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。<br>这些选项很少被使用，并非所有的主机和路由器都支持这些选项。</li>
</ul>
<p>选项字段一直都是以32 bit作为界限，在必要的时候插入值为0的填充字节。这样就保证IP首部始终是32 bit的整数倍（这是首部长度字段所要求的）。</p>
<h2 id="3-3-IP路由选择"><a href="#3-3-IP路由选择" class="headerlink" title="3.3 IP路由选择"></a>3.3 IP路由选择</h2><ul>
<li>主机发送数据报：如果目的主机与源主机直接相连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。</li>
<li>路由器转发数据报：查找路由表。<h4 id="例子已理解"><a href="#例子已理解" class="headerlink" title="例子已理解"></a>例子已理解</h4></li>
</ul>
<h2 id="3-4-子网寻址"><a href="#3-4-子网寻址" class="headerlink" title="3.4 子网寻址"></a>3.4 子网寻址</h2><p>现在所有的主机都要求支持子网编址</p>
<p>与30个C类地址相比，用一个包含30个子网的B类地址的好处是，它可以缩小Internet路由表的规模。</p>
<h2 id="3-5-子网掩码"><a href="#3-5-子网掩码" class="headerlink" title="3.5 子网掩码"></a>3.5 子网掩码</h2><h4 id="例子已理解-1"><a href="#例子已理解-1" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="3-6-特殊情况的IP地址"><a href="#3-6-特殊情况的IP地址" class="headerlink" title="3.6 特殊情况的IP地址"></a>3.6 特殊情况的IP地址</h2><table>
<thead>
<tr>
<th>类型</th>
<th>前缀</th>
<th>网络号</th>
<th>主机号</th>
</tr>
</thead>
<tbody><tr>
<td>A类</td>
<td>0</td>
<td>7位网络号</td>
<td>24位主机号</td>
</tr>
<tr>
<td>B类</td>
<td>10</td>
<td>14位网络号</td>
<td>16位主机号</td>
</tr>
<tr>
<td>C类</td>
<td>110</td>
<td>21位网络号</td>
<td>8位主机号</td>
</tr>
<tr>
<td>D类</td>
<td>1110</td>
<td>多播组号</td>
<td></td>
</tr>
<tr>
<td>E类</td>
<td>11110</td>
<td>留待后用</td>
<td></td>
</tr>
</tbody></table>
<p>下表的子网号栏为空表示该地址没有进行子网划分</p>
<table>
<thead>
<tr>
<th>网络号</th>
<th>子网号</th>
<th>主机号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td></td>
<td>0</td>
<td>网络上的主机</td>
</tr>
<tr>
<td>0</td>
<td></td>
<td>hostid</td>
<td>网络上的特定主机</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>127</td>
<td></td>
<td>任何值</td>
<td>环回地址</td>
</tr>
<tr>
<td>—-</td>
<td>—-</td>
<td>—-</td>
<td>—-</td>
</tr>
<tr>
<td>-1</td>
<td></td>
<td>-1</td>
<td>受限的广播（永远不被转发）</td>
</tr>
<tr>
<td>netid</td>
<td></td>
<td>-1</td>
<td>以网络为目的向netid广播</td>
</tr>
<tr>
<td>netid</td>
<td>subnetid</td>
<td>-1</td>
<td>以子网为目的向netid、subnetid广播</td>
</tr>
<tr>
<td>netid</td>
<td>subnetid</td>
<td>-1</td>
<td>以所有子网为目的向netid广播</td>
</tr>
</tbody></table>
<p>上表的头两项，网络号为0，如主机使用BOOTP协议确定本机IP地址时只能作为初始化过程中的源地址出现。</p>
<h2 id="3-7-一个子网的例子"><a href="#3-7-一个子网的例子" class="headerlink" title="3.7 一个子网的例子"></a>3.7 一个子网的例子</h2><p>使用两个不同的子网掩码<br>需要变长子网</p>
<p>RIP不支持变长子网，RIP第2版和OSPF都支持</p>
<h2 id="3-8-ifconfig命令"><a href="#3-8-ifconfig命令" class="headerlink" title="3.8 ifconfig命令"></a>3.8 ifconfig命令</h2><p>ifconfig可以配置和查询主机上的每个接口</p>
<p>SLIP的LINK标志</p>
<ul>
<li>LINK0：允许压缩slip的数据（CSLIP）</li>
<li>LINK1：如果从另一端收到一份压缩报文，就允许采用CSLIP</li>
<li>LINK2：所有外出的ICMP报文都被丢弃</li>
</ul>
<h2 id="3-9-netstat命令"><a href="#3-9-netstat命令" class="headerlink" title="3.9 netstat命令"></a>3.9 netstat命令</h2><p><code>netstat -in</code>打印出每个接口的MTU、输入分组数、输入错误、输出分组数、输出错误、冲突以及当前的输出队列长度。</p>
<h2 id="3-10-IP的未来"><a href="#3-10-IP的未来" class="headerlink" title="3.10 IP的未来"></a>3.10 IP的未来</h2><p>IP主要存在三个方面的问题</p>
<p>有四个建议之一会被选为IPv4的替换者，你读到此书时可能已经对新版IP做出选择。</p>
<h2 id="3-11-小结"><a href="#3-11-小结" class="headerlink" title="3.11 小结"></a>3.11 小结</h2><p>数据报在各站的传输过程中目的IP地址始终不变，但是封装和目的链路层地址在每一站都可以改变。</p>
<h2 id="ch03-习题"><a href="#ch03-习题" class="headerlink" title="ch03 习题"></a>ch03 习题</h2><ol>
<li>环回地址必须是127.0.0.1吗？</li>
</ol>
<ul>
<li>答案：不，任何网络ID为127的A类地址都是可行的</li>
</ul>
<ol>
<li>在图3-6中指出有两个网络接口的路由器。</li>
</ol>
<ul>
<li>已理解</li>
</ul>
<ol>
<li>子网号为16 bit的A类地址与子网号为8bit的B类地址的子网掩码有什么不同？</li>
</ol>
<ul>
<li>答案：没有区别：作为一个没有再区分子网的C类地址，它们都有一个255.255.255.0的子网掩码。</li>
</ul>
<ol>
<li>阅读RFC 1219[Tsuchiya 1991]，学习分配子网号和主机号的有关推荐技术。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>子网掩码255.255.0.255是否对A类地址有效？</li>
</ol>
<ul>
<li>答案：它是合法的，被称为非连续的子网掩码，因为其用于子网掩码的16位是不连续的。但是RFC建议反对使用非连续的子网掩码。</li>
</ul>
<ol>
<li>你认为为什么3.9小节中打印出来的环回接口的MTU要设置为1536？</li>
</ol>
<ul>
<li>答案：这是一个历史遗留问题。值是1024＋512，但是打印的MTU值包含了所有需要的首部字节数。</li>
</ul>
<ol>
<li>TCP/IP协议族是基于一种数据报的网络技术，即IP层，其他的协议族则基于面向连接的网络技术。阅读文献[Clark 1988]，找出数据报网络层提供的三个优点。答案：</li>
</ol>
<ul>
<li>数据报降低了路由器中对于连接状态的需求。</li>
<li>数据报提供了基本的构件，在它的上面可以构造不可靠的（UDP）和可靠的（TCP）的运输层。</li>
<li>数据报代表了最小的网络层假定，使得可以使用很大范围的数据链路层服务。</li>
</ul>
<h1 id="ch04-ARP：地址解析协议"><a href="#ch04-ARP：地址解析协议" class="headerlink" title="ch04 ARP：地址解析协议"></a>ch04 ARP：地址解析协议</h1><h2 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h2><p>一个网络如以太网可以同时被不同的网络层使用</p>
<ul>
<li>ARP是自动完成的</li>
<li>RARP是被那些没有磁盘驱动器的系统使用，需要手工设置</li>
</ul>
<h2 id="4-2-一个例子"><a href="#4-2-一个例子" class="headerlink" title="4.2 一个例子"></a>4.2 一个例子</h2><h4 id="例子已理解-2"><a href="#例子已理解-2" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射</p>
<p>点对点链路不使用ARP。当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址。</p>
<h2 id="4-3-ARP高速缓存"><a href="#4-3-ARP高速缓存" class="headerlink" title="4.3 ARP高速缓存"></a>4.3 ARP高速缓存</h2><p><code>arp -a</code>显示ARP高速缓存中多有的内容</p>
<p>每一项的生存时间一般为20分钟</p>
<h2 id="4-4-ARP的分组格式"><a href="#4-4-ARP的分组格式" class="headerlink" title="4.4 ARP的分组格式"></a>4.4 ARP的分组格式</h2><p>ARP请求和应答分组的格式如图4-3所示</p>
<p>分组中的重复信息：在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址。</p>
<p>对于一个ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。</p>
<h2 id="4-5-ARP举例"><a href="#4-5-ARP举例" class="headerlink" title="4.5 ARP举例"></a>4.5 ARP举例</h2><h3 id="4-5-1-一般的例子"><a href="#4-5-1-一般的例子" class="headerlink" title="4.5.1 一般的例子"></a>4.5.1 一般的例子</h3><h4 id="例子已理解-3"><a href="#例子已理解-3" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>单词arp或ip后面的值60指的是以太网数据帧的长度，包含14字节的以太网帧头，但是不包括4个字节的以太网帧尾。</p>
<p>arp who has和arp reply都接近自然语言的描述。 </p>
<h3 id="4-5-2-对不存在主机的ARP请求"><a href="#4-5-2-对不存在主机的ARP请求" class="headerlink" title="4.5.2 对不存在主机的ARP请求"></a>4.5.2 对不存在主机的ARP请求</h3><p>会产生不完整的表项<code>? (140.252.13.36) at (incomplete)</code></p>
<p>直到ARP回答返回时，TCP报文段才可以被发送。</p>
<h3 id="4-5-3-ARP高速缓存超时设置"><a href="#4-5-3-ARP高速缓存超时设置" class="headerlink" title="4.5.3 ARP高速缓存超时设置"></a>4.5.3 ARP高速缓存超时设置</h3><ul>
<li>完整的表项超时值为20分钟</li>
<li>不完整的表项超时值为3分钟</li>
<li>管理员可以用arp命令把地址放入高速缓存中而不设置超时值</li>
</ul>
<h2 id="4-6-ARP代理"><a href="#4-6-ARP代理" class="headerlink" title="4.6 ARP代理"></a>4.6 ARP代理</h2><p>如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理(Proxy ARP)。这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。</p>
<p>拨号SLIP链路的两端只拥有一个IP地址</p>
<p>ARP代理也称作混合ARP（promiscuousARP）或ARP出租(ARP hack)。这些名字来自于ARP代理的其他用途：通过两个物理网络之间的路由器可以互相隐藏物理网络。在这种情况下，两个物理网络可以使用相同的网络号，只要把中间的路由器设置成一个ARP代理，以响应一个网络到另一个网络主机的ARP请求。</p>
<h2 id="4-7-免费ARP"><a href="#4-7-免费ARP" class="headerlink" title="4.7 免费ARP"></a>4.7 免费ARP</h2><p>免费ARP(gratuitous ARP)是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候。</p>
<p>免费ARP可以有两个方面的作用：</p>
<ul>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的IP地址。主机bsdi并不希望对此请求有一个回答。</li>
<li>如果发送免费ARP的主机正好改变了硬件地址（很可能是主机关机了，并换了一块接口卡，然后重新启动），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。</li>
</ul>
<p>通过发送含有备份硬件地址和故障服务器的IP地址的免费ARP请求，使得备份文件服务器可以顺利地接替故障服务器进行工作。</p>
<h2 id="4-8-arp命令"><a href="#4-8-arp命令" class="headerlink" title="4.8 arp命令"></a>4.8 arp命令</h2><p>-a：显示ARP高速缓存中的所有内容。这里介绍其他参数的功能。<br>-d：删除ARP高速缓存中的某一项内容（需超级用户）。<br>-s：来增加高速缓存中的内容。这个参数需要主机名和以太网地址：对应于主机名的IP地址和以太网地址被增加到高速缓存中。新增加的内容是永久性的（比如，它没有超时值），除非在命令行的末尾附上关键字temp。<br>位于命令行末尾的关键字pub和-s选项一起：可以使系统起着主机ARP代理的作用。系统将回答与主机名对应的IP地址的ARP请求，并以指定的以太网地址作为应答。如果广播的地址是系统本身，那么系统就为指定的主机名起着委托ARP代理的作用。</p>
<h2 id="4-9-小结"><a href="#4-9-小结" class="headerlink" title="4.9 小结"></a>4.9 小结</h2><p>略</p>
<h1 id="ch04-习题"><a href="#ch04-习题" class="headerlink" title="ch04 习题"></a>ch04 习题</h1><ol>
<li>当输入命令以生成类似图4-4那样的输出时，发现本地ARP快速缓存为空以后，输入命令<code>bsdi % rsh svr4 arp -a</code>如果发现目的主机上的ARP快速缓存也是空的，那将发生什么情况？(该命令将在svr4主机上运行arp -a命令）。</li>
</ol>
<ul>
<li>答案：发出一条rsh命令与另一台主机建立一个TCP连接。这样做引起在两个主机之间交换IP数据报。为此，在那台主机的ARP缓存中必须有我们这台主机的登记项。因此，即使在执行rsh命令之前，ARP缓存是空的，当rsh服务器执行arp命令时，必须保证ARP缓存中登记有我们这台主机。</li>
</ul>
<ol>
<li>请描述如何判断一个给定主机是否能正确处理接收到的非必要的ARP请求的方法。</li>
</ol>
<ul>
<li>答案：保证你的主机上的ARP缓存中没有登记以太网上的某个叫作foo的主机。保证foo引导时发送一个免费ARP请求，也许是在foo引导时，在那台主机上运行tcpdump。然后关闭主机foo，使用说明了temp选项的arp命令，在你的系统的ARP缓存中为foo输入一个不正确的登记项。引导foo并在它启动好之后，察看主机的ARP缓存，看看不正确的登记项是不是已经被更正了。</li>
</ul>
<ol>
<li>由于发送一个数据包后ARP将等待响应，因此4.2节所描述的步骤7可能会持续一段时间。你认为ARP将如何处理在这期间收到相同目的IP地址发来的多个数据包？</li>
</ol>
<ul>
<li>答案：CF：RFC的2.3.2.2节和本书中的<a href="#">11.9节</a>。</li>
</ul>
<ol>
<li>在4.5节的最后，我们指出Host Requirements RFC和伯克利派生系统在处理活动ARP表目的超时时存在差异。那么如果我们在一个由伯克利派生系统的客户端上，试图与一个正在更换以太网卡而处于关机状态的服务器主机联系，这时会发生什么情况？如果服务器在引导过程中广播一份免费ARP，这种情况是否会发生变化？</li>
</ol>
<ul>
<li>答案：假设当服务器关闭时，客户机保存了关于服务器的一个完整的ARP登记项。如果我们继续试图与（已关闭的）服务器联系，过了20分钟以后，ARP将超时。最后，当服务器以另一个新的硬件地址重启动。如果它没有发出一个免费ARP，旧的、不再正确的ARP登记项仍然存在于客户机上。我们将无法和在新硬件地址上的服务器联系直到我们手工删除这个ARP登记项，或者在20分钟内停止与服务器联系的尝试。</li>
</ul>
<h1 id="ch05-RARP：逆地址解析协议"><a href="#ch05-RARP：逆地址解析协议" class="headerlink" title="ch05 RARP：逆地址解析协议"></a>ch05 RARP：逆地址解析协议</h1><h2 id="5-1-引言"><a href="#5-1-引言" class="headerlink" title="5.1 引言"></a>5.1 引言</h2><p>无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求，请求某个主机响应该无盘系统的IP地址</p>
<h2 id="5-2-RARP的分组格式"><a href="#5-2-RARP的分组格式" class="headerlink" title="5.2 RARP的分组格式"></a>5.2 RARP的分组格式</h2><p>RARP分组的格式与ARP分组基本一致（见图4-3）。它们之间主要的差别是RARP请求或应答的帧类型代码为0x8035，而且RARP请求的操作代码为3，应答操作代码为4。</p>
<h2 id="5-3-RARP举例"><a href="#5-3-RARP举例" class="headerlink" title="5.3 RARP举例"></a>5.3 RARP举例</h2><p>当无盘系统从RARP应答中收到它的IP地址后，它将发送TFTP请求来读取引导映象。</p>
<h2 id="5-4-RARP服务器的设计"><a href="#5-4-RARP服务器的设计" class="headerlink" title="5.4 RARP服务器的设计"></a>5.4 RARP服务器的设计</h2><p>虽然RARP在概念上很简单，但是一个RARP服务器的设计与系统相关而且比较复杂。</p>
<h3 id="5-4-1-作为用户进程的RARP服务器"><a href="#5-4-1-作为用户进程的RARP服务器" class="headerlink" title="5.4.1 作为用户进程的RARP服务器"></a>5.4.1 作为用户进程的RARP服务器</h3><p>由于内核一般不读取和分析磁盘文件，因此RARP服务器的功能就由用户进程来提供，而不是作为内核的TCP/IP实现的一部分。</p>
<p>由于发送和接收特殊类型的以太网数据帧与系统有关，因此RARP服务器的实现是与系统捆绑在一起的。</p>
<h3 id="5-4-2-每个网络有多个RARP服务器"><a href="#5-4-2-每个网络有多个RARP服务器" class="headerlink" title="5.4.2 每个网络有多个RARP服务器"></a>5.4.2 每个网络有多个RARP服务器</h3><p>通常在一个网络上（例如一根电缆）要提供多个RARP服务器。</p>
<p>当服务器的数目增加时（以提供冗余备份），网络流量也随之增加，因为每个服务器对每个RARP请求都要发送RARP应答。发送RARP请求的无盘系统一般采用最先收到的RARP应答。</p>
<h2 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h2><p>在第16章中，我们将看到BOOTP在无盘系统引导时会返回更多的信息：IP地址和引导主机的名字等。</p>
<h2 id="ch05-习题"><a href="#ch05-习题" class="headerlink" title="ch05 习题"></a>ch05 习题</h2><ol>
<li>RARP需要不同的帧类型字段吗？ARP和RARP都使用相同的值0x0806吗？</li>
</ol>
<ul>
<li>答案：一个单独的帧类型并不是必需的，因为图4-3中的op字段对于所有的四个操作（ARP请求、ARP应答、RARP请求和RARP应答）都有一个不同的值。但是实现一个RARP服务器，独立于内核中的ARP服务器，更容易处理不同的帧类型字段。</li>
</ul>
<ol>
<li>在一个有多个RARP服务器的网络上，如何防止它们的响应发生冲突？</li>
</ol>
<ul>
<li>答案： 每个RARP服务器在发送一个响应之前可以延迟一个小的随机时间。作为一个优化，可以指定一个RARP服务器为主服务器，其他的为次服务器。主服务器发出响应不需要延迟，而次服务器发出响应则需要一个随机的延迟。作为另一个优化，也是指定一个主RARP服务器，其他为次服务器。次服务器只对在一个短时间段内发生的重复请求进行响应。这里假设出现重复请求的原因是由于主服务器停机了。</li>
</ul>
<h1 id="ch06-ICMP：Internet控制报文协议"><a href="#ch06-ICMP：Internet控制报文协议" class="headerlink" title="ch06 ICMP：Internet控制报文协议"></a>ch06 ICMP：Internet控制报文协议</h1><h2 id="6-1-引言"><a href="#6-1-引言" class="headerlink" title="6.1 引言"></a>6.1 引言</h2><p>ICMP报文的格式如图6-2所示。类型字段可以有15个不同的值，以描述特定类型的ICMP报文。某些ICMP报文还使用代码字段的值来进一步描述不同的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0        7 8      15 16               31</span><br><span class="line">+---------+---------+------------------+</span><br><span class="line">| 8位类型 | 8位代码 |    16位检验和    |</span><br><span class="line">+---------*---------*------------------+</span><br><span class="line">|    （不同类型和代码有不同的内容）    | </span><br><span class="line">+--------------------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="6-2-ICMP报文的类型"><a href="#6-2-ICMP报文的类型" class="headerlink" title="6.2 ICMP报文的类型"></a>6.2 ICMP报文的类型</h2><p>各种类型的ICMP报文如图6-3所示</p>
<p>图中的最后两列表明ICMP报文是一份查询报文还是一份差错报文。</p>
<p>下面各种情况都不会导致产生ICMP差错报文：</p>
<ol>
<li>ICMP差错报文（但是，ICMP查询报文可能会产生ICMP差错报文）。</li>
<li>目的地址是广播地址（见图3-9）或多播地址（D类地址，见图1-5）的IP数据报。</li>
<li>作为链路层广播的数据报。</li>
<li>不是IP分片的第一片（将在11.5节介绍分片）。</li>
<li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。<br>这些规则是为了防止过去允许ICMP差错报文对广播分组响应所带来的广播风暴。</li>
</ol>
<h2 id="6-3-ICMP地址掩码请求与应答"><a href="#6-3-ICMP地址掩码请求与应答" class="headerlink" title="6.3 ICMP地址掩码请求与应答"></a>6.3 ICMP地址掩码请求与应答</h2><p>ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码</p>
<p>ICMP报文中的标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回。这样，发送端就可以把应答与请求进行匹配。</p>
<p>广播的一般特性：发送主机也能通过某种内部环回机制收到一份广播报文拷贝。</p>
<p>通常，应答地址必须是单播地址，除非请求端的源IP地址是0.0.0.0。</p>
<p>RFC规定，除非系统是地址掩码的授权代理，否则它不能发送地址掩码应答（为了成为授权代理，它必须进行特殊配置，以发送这些应答。参见附录E）。但是，正如我们从本例中看到的那样，大多数主机在收到请求时都发送一个应答，甚至有一些主机还发送差错的应答。</p>
<p>ICMP地址掩码应答必须是收到请求接口的子网掩码</p>
<h2 id="6-4-ICMP时间戳请求与应答"><a href="#6-4-ICMP时间戳请求与应答" class="headerlink" title="6.4 ICMP时间戳请求与应答"></a>6.4 ICMP时间戳请求与应答</h2><p>ICMP时间戳请求允许系统向另一个系统查询当前的时间。返回的建议值是自午夜开始计算的毫秒数。这种ICMP报文的好处是它提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间（如某些Unix系统提供的rdate命令）只能提供秒级的分辨率。由于返回的时间是从午夜开始计算的，因此调用者必须通过其他方法获知当时的日期，这是它的一个缺陷。</p>
<p>请求端填写发起时间戳，然后发送报文。应答系统收到请求报文时填写接收时间戳，在发送应答时填写发送时间戳。但是，实际上，大多数的实现把后面两个字段都设成相同的值</p>
<h3 id="6-4-1-举例"><a href="#6-4-1-举例" class="headerlink" title="6.4.1 举例"></a>6.4.1 举例</h3><p>往返时间（rtt），它的值是收到应答时的时间值减去发送请求时的时间值。difference的值是接收时间戳值减去发起时间戳值。</p>
<p>如果我们相信RTT的值，并且相信RTT的一半用于请求报文的传输，另一半用于应答报文的传输，那么为了使本机时钟与查询主机的时钟一致，本机时钟需要进行调整，调整值是difference减去RTT的一半。</p>
<h3 id="6-4-2-另一种方法"><a href="#6-4-2-另一种方法" class="headerlink" title="6.4.2 另一种方法"></a>6.4.2 另一种方法</h3><p>还可以用另一种方法来获得时间和日期。</p>
<ul>
<li>在1.12节中描述了日期服务程序和时间服务程序（前面我们提过的rdate命令使用的是TCP时间服务程序）。</li>
<li>严格的计时器使用网络时间协议（NTP），该协议在RFC 1305中给出了描述[Mills1992]。这个协议采用先进的技术来保证LAN或WA N上的一组系统的时钟误差在毫秒级以内。对计算机精确时间感兴趣的读者应该阅读这份RFC文档。</li>
<li>开放软件基金会（OSF）的分布式计算环境（DCE）定义了分布式时间服务（DTS），它也提供计算机之间的时钟同步。文献[Rosenberg, Kenney and Fisher 1992]提供了该服务的其他细节描述。</li>
<li>伯克利大学的Unix系统提供守护程序timed(8)，来同步局域网上的系统时钟。不像NTP和DTS，timed不在广域网范围内工作。</li>
</ul>
<h2 id="6-5-ICMP端口不可达差错"><a href="#6-5-ICMP端口不可达差错" class="headerlink" title="6.5 ICMP端口不可达差错"></a>6.5 ICMP端口不可达差错</h2><p>UDP的规则之一是，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。</p>
<p>ICMP差错报文必须包括生成该差错报文的数据报IP首部（包含任何选项），还必须至少包括跟在该IP首部后面的前8个字节。</p>
<p>当ICMP报文返回时，为什么TFTP客户程序还要继续重发请求呢？这是由于网络编程中的一个因素，即BSD系统不把从插口(socket)接收到的ICMP报文中的UDP数据通知用户进程，除非该进程已经发送了一个connect命令给该插口。</p>
<h2 id="6-6-ICMP报文的4-4BSD处理"><a href="#6-6-ICMP报文的4-4BSD处理" class="headerlink" title="6.6 ICMP报文的4.4BSD处理"></a>6.6 ICMP报文的4.4BSD处理</h2><p>由于ICMP覆盖的范围很广，从致命差错到信息差错，因此即使在一个给定的系统实现中，对每个ICMP报文的处理都是不相同的。图6-12的内容与图6-3相同，它显示的是4.4BSD系统对每个可能的ICMP报文的处理方法。</p>
<ul>
<li>如果最后一列标明是“内核”，那么ICMP就由内核来处理。</li>
<li>如果最后一列指明是“用户进程”，那么报文就被传送到所有在内核中登记的用户进程，以读取收到的ICMP报文。</li>
<li>如果不存在任何这样的用户进程，那么报文就悄悄地被丢弃（这些用户进程还会收到所有其他类型的ICMP报文的拷贝，虽然它们应该由内核来处理，当然用户进程只有在内核处理以后才能收到这些报文）。</li>
<li>有一些报文完全被忽略。</li>
<li>如果最后一列标明的是引号内的一串字符，那么它就是对应的Unix差错。</li>
</ul>
<h2 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h2><p>略</p>
<h2 id="ch06-习题"><a href="#ch06-习题" class="headerlink" title="ch06 习题"></a>ch06 习题</h2><ol>
<li>在6.2节的末尾，我们列出了5种不发送ICMP差错报文的特殊条件。如果这些条件不满足而我们又在局域网上向一个似乎不存在的端口号发送一份广播UDP数据报，这时会发生什么样的情况？</li>
</ol>
<ul>
<li>答案：如果在局域网线上有一百个主机，每个都可能在同一时刻发送一个ICMP端口不可达的报文。很多报文的传输都可能发生冲突（如果使用的是以太网），这将导致1秒或2秒的时间里网络不可用。</li>
</ul>
<ol>
<li>阅读RFC [Braden 1989a]，注意生成一个ICMP端口不可达差错是否为“必须”，“应该”或者“可能”。这些信息所在的页码和章节是多少？</li>
</ol>
<ul>
<li>答案：它是一个“should”。</li>
</ul>
<ol>
<li>阅读RFC 1349 [Almquist 1992]，看看IP的服务类型字段（见图3-2）是如何被ICMP设置的？</li>
</ol>
<ul>
<li>答案：如我们在图3-2所指出的，发送一个ICMP差错总是将TOS置为0。发送一个ICMP查询请求可以将TOS置为任何值，但是发送相应的应答必须将TOS置为相同的值。</li>
</ul>
<ol>
<li>如果你的系统提供netstat命令，请用它来查看接收和发送的ICMP报文类型。</li>
</ol>
<ul>
<li>答案：netstat -s是查看每个协议统计数据的常用方法。</li>
</ul>
<h1 id="ch07-Ping程序"><a href="#ch07-Ping程序" class="headerlink" title="ch07 Ping程序"></a>ch07 Ping程序</h1><h2 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h2><p>Ping还给我们提供了检测IP记录路由和时间戳选项的机会</p>
<p>出现了提供访问控制清单的路由器和防火墙以后，一台主机的可达性可能不只取决于IP层是否可达</p>
<h2 id="7-2-Ping程序"><a href="#7-2-Ping程序" class="headerlink" title="7.2 Ping程序"></a>7.2 Ping程序</h2><p>大多数的TCP/IP实现都在内核中直接支持Ping服务器——这种服务器不是一个用户进程。<br>回显请求，地址掩码和时间戳请求，都是直接在内核中进行处理的</p>
<p>ICMP回显请求和回显应答报文如图7-1所示。</p>
<p>对于其他类型的ICMP查询报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显，假设客户对这些信息都会感兴趣。</p>
<p>Unix系统在实现ping程序时是把ICMP报文中的标识符字段置成发送进程的ID号。这样即使在同一台主机上同时运行了多个ping程序实例，ping程序也可以识别出返回的信息。</p>
<p>序列号从0开始，每发送一次新的回显请求就加1。ping程序打印出返回的每个分组的序列号，允许我们查看是否有分组丢失、失序或重复。IP是一种尽力而为的数据报传递服务，因此这三个条件都有可能发生。</p>
<h3 id="7-2-1-LAN输出"><a href="#7-2-1-LAN输出" class="headerlink" title="7.2.1 LAN输出"></a>7.2.1 LAN输出</h3><p>ping程序通过在ICMP报文数据中存放发送请求的时间值来计算往返时间。</p>
<p>键入ping命令，几秒钟过后会在第1行打印出IP地址，DNS就是利用这段时间来确定主机名所对应的IP地址。</p>
<h3 id="7-2-2-WAN输出"><a href="#7-2-2-WAN输出" class="headerlink" title="7.2.2 WAN输出"></a>7.2.2 WAN输出</h3><p>像52%这样高的分组丢失率是不正常的。即使是在工作日的下午，对于Internet来说也是不正常的。</p>
<p>通过广域网还有可能看到重复的分组（即相同序列号的分组被打印两次或更多次），失序的分组（序列号为N+1的分组在序列号为N的分组之前被打印）。</p>
<h3 id="7-2-3-线路SLIP链接"><a href="#7-2-3-线路SLIP链接" class="headerlink" title="7.2.3 线路SLIP链接"></a>7.2.3 线路SLIP链接</h3><p>让我们再来看看SLIP链路上的往返时间，因为它们经常运行于低速的异步方式，如9600b/s或更低。</p>
<p>对于SVR4来说，往返时间大约是1.5秒，但是程序仍然每间隔1秒钟发送一次ICMP回显请求。这就是为什么总结行指出丢失了一个分组。实际上分组并未丢失，很可能仍然在返回的途中。</p>
<h3 id="7-2-4-拨号SLIP链路"><a href="#7-2-4-拨号SLIP链路" class="headerlink" title="7.2.4 拨号SLIP链路"></a>7.2.4 拨号SLIP链路</h3><p>对于拔号SLIP链路来说，调制解调器带来了时延</p>
<p>这些调制解调器的参数对RTT的影响很大，使用错误控制和数据压缩方式似乎效果最好。</p>
<h2 id="7-3-IP记录路由选项"><a href="#7-3-IP记录路由选项" class="headerlink" title="7.3 IP记录路由选项"></a>7.3 IP记录路由选项</h2><p>ping程序为我们提供了查看IP记录路由（RR）选项的机会。大多数不同版本的ping程序都提供-R选项，以提供记录路由的功能。它使得ping程序在发送出去的IP数据报中设置IPRR选项（该IP数据报包含ICMP回显请求报文）。这样，每个处理该数据报的路由器都把它的IP地址放入选项字段中。当数据报到达目的端时，IP地址清单应该复制到ICMP回显应答中，这样返回途中所经过的路由器地址也被加入清单中。当ping程序收到回显应答时，它就打印出这份IP地址清单。</p>
<p>有一些系统不把ICMP请求中的IP清单复制到ICMP应答中。</p>
<p>但是，最大的问题是IP首部中只有有限的空间来存放IP地址。</p>
<p>IP数据报中的RR选项的一般格式如图7-3所示。</p>
<p>当路由器（根据定义应该是多穴的）在清单中记录IP地址时，它应该记录哪个地址呢？是入口地址还是出口地址？为此，RFC 791[Postel 1981a]指定路由器记录出口IP地址。</p>
<h3 id="7-3-1-通常的例子"><a href="#7-3-1-通常的例子" class="headerlink" title="7.3.1 通常的例子"></a>7.3.1 通常的例子</h3><p>我们举一个用RR选项运行ping程序的例子，在主机svr4上运行ping程序到主机slip。一个中间路由器(bsdi)将处理这个数据报。</p>
<p>分组所经过的四站如图7-4所示（每个方向各有两站），每一站都把自己的出口IP地址加入RR清单。</p>
<p>通过运行带有-v选项的tcpdump命令来查看主机sun上进行的分组交换（参见IP选项）。输出如图7-5所示。</p>
<p>输出中optlen=40表示在IP首部中有40个字节的选项空间（IP首部长度必须为4字节的整数倍）。RR{39}的意思是记录路由选项已被设置，它的长度字段是39。然后是9个IP地址，符号“#”用来标记RR选项中的ptr字段所指向的IP地址。</p>
<p>位于路由信息末尾的标记EOL表示IP选项“end of list（清单结束）”的值。EOL选项的值可以为0。这时表示39个字节的RR数据位于IP首部中的40字节空间中。由于在数据报发送之前空间选项被设置为0，因此跟在39个字节的RR数据之后的0字符就被解释为EOL。这正是我们所希望的结果。如果在IP首部中的选项字段中有多个选项，在开始下一个选项之前必须填入空白字符，另外还可以用另一个值为1的特殊字符NOP（“no operation”）。</p>
<h3 id="7-3-2-异常的输出"><a href="#7-3-2-异常的输出" class="headerlink" title="7.3.2 异常的输出"></a>7.3.2 异常的输出</h3><p>为什么传出的数据报（ICMP回显请求）直接从netb传到aix，而返回的数据报（ICMP回显应答）却从aix开始经路由器gateway再到netb？</p>
<p>路由器gateway比子网140.252.1上的任何主机都具备更强的选路能力（在这个以太网上有超过150台主机，每台主机的路由表中都有一个默认项指向路由器gateway，这样就不用在每台主机上都运行一个选路守护程序）。</p>
<p>这里没有应答的一个问题是为什么gateway不直接发送ICMP报文重定向到aix（9.5节），以更新它的路由表？由于某种原因（很可能是由于数据报产生的重定向是一份ICMP回显请求报文），重定向并没有产生。但是如果我们用Te lnet登录到aix上的daytime服务器，ICMP就会产生重定向</p>
<h2 id="7-4-IP时间戳选项"><a href="#7-4-IP时间戳选项" class="headerlink" title="7.4 IP时间戳选项"></a>7.4 IP时间戳选项</h2><p>IP时间戳选项与记录路由选项类似。IP时间戳选项的格式如图7-7所示（请与图7-3进行比较）。</p>
<p>时间戳选项的代码为0x44。其他两个字段len和ptr与记录路由选项相同：选项的总长度（一般为36或40）和指向下一个可用空间的指针（5，9，13等）。</p>
<p>接下来的两个字段是4bit的值：OF表示溢出字段，FL表示标志字段。时间戳选项的操作根据标志字段来进行，如图7-8所示。</p>
<p>如果路由器由于没有空间而不能增加时间戳选项，那么它将增加溢出字段的值。</p>
<p>时间戳的取值一般为自UTC午夜开始计的毫秒数，与ICMP时间戳请求和应答相类似。如果路由器不使用这种格式，它就可以插入任何它使用的时间表示格式，但是必须打开时间戳中的高位以表明为非标准值。</p>
<p>与我们遇到的记录路由选项所受到的限制相比，时间戳选项遇到情况要更坏一些。如果我们要同时记录IP地址和时间戳（标志位为1），那么就可以同时存入其中的四对值。只记录时间戳是没有用处的，因为我们没有标明时间戳与路由器之间的对应关系（除非有一个永远不变的拓扑结构）。标志值取3会更好一些，因为我们可以插入时间戳的路由器。一个更为基本的问题是，很可能无法控制任何给定路由器上时间戳的正确性。这使得试图用IP选项来计算路由器之间的跳站数是徒劳的。</p>
<h2 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5 小结"></a>7.5 小结</h2><p>略</p>
<h2 id="ch07-习题"><a href="#ch07-习题" class="headerlink" title="ch07 习题"></a>ch07 习题</h2><ol>
<li>请画出7.2节中ping输出的时间线。</li>
</ol>
<ul>
<li>无答案。已思考</li>
</ul>
<ol>
<li>若把bsdi和slip主机之间的SLIP链路设置为9600 b/s，请计算这时的RTT。假定默认的数据是56字节。</li>
</ol>
<ul>
<li>已对答案：86字节除以960字节/秒，乘以2 = 179.2ms</li>
</ul>
<ol>
<li>当前BSD版中的ping程序允许我们为ICMP报文的数据部分指定一种模式（数据部分的前8个字节不用来存放模式，因为它要存放发送报文的时间）。如果我们指定的模式为0xc0，请重新计算上一题中的答案（提示：阅读2.4节）。</li>
</ol>
<ul>
<li>答案：（86＋48）除以960字节/秒，乘以2得到279.2ms。另外的48字节是因为56字节的数据部分的最后48字节必须忽略：0xc0是SLIP END字符。</li>
</ul>
<ol>
<li>使用压缩SLIP（CSLIP，见2.5节）是否会影响我们在7.2节中看到的ping输出中的时间值？</li>
</ol>
<ul>
<li>答案：CSLIP只压缩了TCP报文段的TCP首部和IP首部。它对ping使用的ICMP报文没有作用。</li>
</ul>
<ol>
<li>在图2-4中，ping环回地址与ping主机以太网地址会出现什么不同？</li>
</ol>
<ul>
<li>在一个SPA RC工作站ELC上，对回环地址的ping操作产生一个1.310 ms的RTT，而对一个主机的以太网地址的ping操作产生一个1.460 ms的RTT。这个差值是由于以太网驱动程序需要时间来判定这个数据报的目的地址是一个本地的主机。需要一个产生微秒级输出的ping来验证这一点。</li>
</ul>
<h1 id="ch08-Traceroute程序"><a href="#ch08-Traceroute程序" class="headerlink" title="ch08 Traceroute程序"></a>ch08 Traceroute程序</h1><h2 id="8-1-引言"><a href="#8-1-引言" class="headerlink" title="8.1 引言"></a>8.1 引言</h2><p>尽管不能保证从源端发往目的端的两份连续的IP数据报具有相同的路由，但是大多数情况下是这样的。Traceroute程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由。Traceroute程序还可以让我们使用IP源路由选项。</p>
<h2 id="8-2-Traceroute程序的操作"><a href="#8-2-Traceroute程序的操作" class="headerlink" title="8.2 Traceroute程序的操作"></a>8.2 Traceroute程序的操作</h2><p>在7.3节中，我们描述了IP记录路由选项（RR）。为什么不使用这个选项而另外开发一个新的应用程序？有三个方面的原因。</p>
<ul>
<li>Traceroute程序不需要中间路由器具备任何特殊的或可选的功能</li>
<li>Traceroute程序只需要目的端运行一个UDP模块—其他不需要任何特殊的服务器应用程序</li>
<li>最主要的原因是，在IP首部选项字段中最多只能存放9个IP地址</li>
</ul>
<p>TTL的初始值由分配数字RFC指定，当前值为64。发送ICMP回显应答时经常把TTL设为最大值255。</p>
<p>每个处理数据报的路由器都需要把TTL的值减1或减去数据报在路由器中停留的秒数。由于大多数的路由器转发数据报的时延都小于1秒钟，因此TTL最终成为一个跳站的计数器，所经过的每个路由器都将其值减1。</p>
<p>当路由器收到一份IP数据报，如果其TTL字段是0或1，路由器将该数据报丢弃，并给信源机发一份ICMP“超时”信息。</p>
<p>目的主机哪怕接收到TTL值为1的IP数据报，也不会丢弃该数据报并产生一份超时ICMP报文，这是因为数据报已经到达其最终目的地。那么我们该如何判断是否已经到达目的主机了呢？</p>
<p>Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于30 000），使目的主机的任何一个应用程序都不可能使用该端口。因为，当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”错误（见6.5节）的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。</p>
<h2 id="8-3-局域网输出"><a href="#8-3-局域网输出" class="headerlink" title="8.3 局域网输出"></a>8.3 局域网输出</h2><p>对于每个TTL值，发送3份数据报。每接收到一份ICMP报文，就计算并打印出往返时间。如果在5秒种内仍未收到3份数据报的任意一份的响应，则打印一个星号，并发送下一份数据报。</p>
<ul>
<li>目的主机UDP端口号最开始设置为33435，且每发送一个数据报加1。</li>
<li>traceroute程序将其发送的UDP数据报的源端口号设置为Unix进程号与32768之间的逻辑或值。对于在同一台主机上多次运行traceroute程序的情况，每个进程都查看ICMP返回的UDP首部的源端口号，并且只处理那些对自己发送应答的报文。</li>
</ul>
<p>当TTL值为0或1时，tcpdump打印出注释<code>[ttl 1]</code></p>
<p>有两种不同的ICMP“超时”报文（见6.2节的图6-3），它们的ICMP报文中code字段不同。图8-2给出了这种ICMP差错报文的格式。</p>
<ul>
<li>code字段为0：在TTL值等于0时产生</li>
<li>code字段为1：主机在组装分片时发生超时</li>
</ul>
<p>与Ping不一样的是，返回的数据报大小是变化的。从图6-9可以看出，返回的ICMP报文包含发生差错的数据报的IP首部以及紧随该IP首部的8字节数据</p>
<p>关于traceroute程序，还有一些必须指出的事项。</p>
<ul>
<li>并不能保证现在的路由也是将来所要采用的路由</li>
<li>不能保证ICMP报文的路由与traceroute程序发送的UDP数据报采用同一路由。</li>
<li>从A主机到B主机上运行traceroute程序和从B主机到A主机上运行traceroute程序所得到的结果可能是不同的。</li>
</ul>
<p>在广域网情况下，如果traceroute程序的输出是可读的域名形式，而不是IP地址形式，那么会更好理解一些。但是由于traceroute程序接收到ICMP报文时，它所获得的唯一信息就是IP地址，因此，在给定IP地址的情况下，它做一个“反向域名查看”工作来获得域名。这就需要路由器或主机的管理员正确配置其反向域名查看功能（并非所有的情况下都是如此）。</p>
<h2 id="8-4-广域网输出"><a href="#8-4-广域网输出" class="headerlink" title="8.4 广域网输出"></a>8.4 广域网输出</h2><h4 id="例子已理解-4"><a href="#例子已理解-4" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="8-5-IP源站选路选项"><a href="#8-5-IP源站选路选项" class="headerlink" title="8.5 IP源站选路选项"></a>8.5 IP源站选路选项</h2><p>源站选路(source routing)的思想是由发送者指定路由。它可以采用以下两种形式：</p>
<ol>
<li>严格的源路由选择。发送端指明IP数据报所必须采用的确切路由。如果一个路由器发现源路由所指定的下一个路由器不在其直接连接的网络上，那么它就返回一个“源站路由失败”的ICMP差错报文。</li>
<li>宽松的源站选路。发送端指明了一个数据报经过的IP地址清单，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器。</li>
</ol>
<p>Traceroute程序提供了一个查看源站选路的方法，我们可以在选项中指明源站路由，然后检查其运行情况。</p>
<p>这个格式与我们在图7-3中所示的记录路由选项格式基本一致。不同之处是，对于源站选路，我们必须在发送IP数据报前填充IP地址清单；而对于记录路由选项，我们需要为IP地址清单分配并清空一些空间，并让路由器填充该清单中的各项。</p>
<p>对于宽松的源站选路来说，code字段的值是0x83；而对于严格的源站选路，其值为0x89。len和ptr字段与7.3节中所描述的一样。</p>
<p>在图8-7中，我们假设主机S上的发送应用程序发送一份数据报给D，指定源路由为R1，R2和R3。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/8/images2/52im_net_9.png" alt="图8-7 IP源路由示例"></p>
<p>当一个应用程序接收到由信源指定路由的数据时，在发送应答时，应该读出接收到的路由值，并提供反向路由。</p>
<h3 id="8-5-1-宽松的源站选路的-traceroute-程序示例"><a href="#8-5-1-宽松的源站选路的-traceroute-程序示例" class="headerlink" title="8.5.1 宽松的源站选路的 traceroute 程序示例"></a>8.5.1 宽松的源站选路的 traceroute 程序示例</h3><p>使用traceroute程序的-g选项，可以为宽松的源站选路指明一些中间路由器。采用该选项可以最多指定8个中间路由器（其个数是8而不是9的原因是，所使用的编程接口要求最后的表目是目的主机）。</p>
<h4 id="例子已理解-5"><a href="#例子已理解-5" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>使用traceroute程序的-g选项，可以为宽松的源站选路指明一些中间路由器。采用该选项可以最多指定8个中间路由器（其个数是8而不是9的原因是，所使用的编程接口要求最后的表目是目的主机）。</p>
<h3 id="8-5-2-严格的源站选路的-traceroute-程序示例"><a href="#8-5-2-严格的源站选路的-traceroute-程序示例" class="headerlink" title="8.5.2 严格的源站选路的 traceroute 程序示例"></a>8.5.2 严格的源站选路的 traceroute 程序示例</h3><p>在作者的traceroute程序版本中，-G选项是严格的源站选路而不是宽松的源站选路。我们可以采用这个选项来观察在指明无效的严格的源站选路时其结果会是什么样的。</p>
<p>RTT后面的!S。这表明traceroute程序接收到ICMP“源站路由失败”的差错报文</p>
<p>在tcpdump中指定-v选项以显示出源站路由信息。宽松的源站选路和严格的源站选路，分别用LSRR和SSRR表示</p>
<h3 id="8-5-3-宽松的源站选路traceroute程序的往返路由"><a href="#8-5-3-宽松的源站选路traceroute程序的往返路由" class="headerlink" title="8.5.3 宽松的源站选路traceroute程序的往返路由"></a>8.5.3 宽松的源站选路traceroute程序的往返路由</h3><p>从A到B的路径并不一定与从B到A的路径完全一样。除非同时在两个系统中登录并在每个终端上运行traceroute程序，否则很难发现两条路径是否不同。但是，采用宽松的源站选路，就可以决定两个方向上的路径。</p>
<p>这里的窍门就在于指定一个宽松的源站路由，该路由的目的端和宽松路径一样，但发送端为目的主机。</p>
<h4 id="例子已理解-6"><a href="#例子已理解-6" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="8-6-小结"><a href="#8-6-小结" class="headerlink" title="8.6 小结"></a>8.6 小结</h2><p>略</p>
<h2 id="ch08-习题"><a href="#ch08-习题" class="headerlink" title="ch08 习题"></a>ch08 习题</h2><ol>
<li>当IP将接收到的TTL字段减1，发现它为0时，将会发生什么结果？</li>
</ol>
<ul>
<li>答案：如果一个输入数据报的TTL为0，做减一操作然后测试会将把TTL设置为255，并且让数据报继续传输。尽管一个路由器永远不会收到一个TTL为0的数据报，但这种情况确实会发生。</li>
</ul>
<ol>
<li>traceroute程序是如何计算RTT的？将这种计算RTT的方法与ping相比较。</li>
</ol>
<ul>
<li>答案：traceroute保存了它发送分组的时间，当收到一个ICMP应答时，取出当时的时间，把两个值相减就可以得出RTT。</li>
<li>回忆一下第7章中，ping在输出的ICMP回显请求中存储了时间，这个值被服务器回显了回来。这样即使分组返回时失序，ping也能打印出正确的RTT。</li>
</ul>
<ol>
<li>（本习题与下一道习题是基于开发traceroute程序过程中遇到的实际问题，它们来自于traceroute程序源代码注释）。假设源主机和目的主机之间有三个路由器（R1、R2和R3），而中间的路由器（R2）在进入TTL字段为1时，将TTL字段减1，但却错误地将该IP数据报发往下一个路由器。请描述会发生什么结果。在运行traceroute程序时会看到什么样的现象？</li>
</ol>
<ul>
<li>答案：第1行输出是正确的，并且标识了R1。下一个探测分组启动时将TTL置为2，并且这个值被R1减1。当R2收到这个分组时，把TTL从1减为0，但是错误地将它传递给了R3。R3看见进入的TTL是0就将超时的分组发送回来。这就意味着第2行输出（TTL为2）标识了R3，而不是R2。第3行输出正确地标识了R3。这个错误所表现出来的线索就是两个连续的输出行标识了同一个路由器。</li>
</ul>
<ol>
<li>同样，假设源主机和目的主机之间有三个路由器。由于目的主机上存在错误，因此，它总是将进入TTL值作为外出ICMP报文的TTL值。请描述这将发生什么结果，你会看到什么现象。</li>
</ol>
<ul>
<li>答案：TTL为1、2和3的行正确地标识了R1、R2和R3，接下来的三行每个都包含三个超时，再接下来的TTL为7的行标识了目的地。</li>
</ul>
<ol>
<li>在图8-8运行例子中，我们可以在sun和netb之间的SLIP链路上运行tcpdump程序。如果指定-v选项，就可以看到返回ICMP报文的TTL值。这样，我们可以看到进入netb、butch、Gabby和enss142.UT.westnet.net的TTL值分别为255、253、252和249。这是否为我们判断是否存在丢失路由器提供了额外的信息？</li>
</ol>
<ul>
<li>答案：未觉察的路由器没有正确地处理向外输出的UDP数据报，但它们都对返回的ICMP报文正确地进行了TTL减1操作。</li>
<li>我们必须在查看输入的TTL时非常小心，因为有时候一个和我们想要的不同的值可能是由于返回的ICMP报文采用了一条与输出UDP数据报不同的路径。</li>
</ul>
<ol>
<li>SunOS和SVR4都提供了带-l选项的ping版本，以提供松源选路。手册上说明，该选项可以与-R选项（指定记录路由选项）一起使用。如果已经进入到这些系统中，请尝试同时用这两个选项。其结果是什么？如果采用tcpdump来观测数据报，请描述其过程。</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>比较ping和traceroute程序在处理同一台主机上客户的多个实例的不同点。</li>
</ol>
<ul>
<li>答案：ping的客户把ICMP回显请求报文（图7-1）的标识符字段设置为它的进程ID。ICMP回显应答报文包含同样值的标识符字段。每个客户都要查看这个返回的标识符字段，并且只处理那些它发送过的报文。</li>
<li>traceroute客户将它的UDP源端口号设置为它的进程ID和32768的逻辑或。因为返回的ICMP报文总是包含产生错误的IP数据报的前8个字节（图6-9），这8个字节包括了完整的UDP首部，所以这个源端口号在ICMP差错报文中被返回。</li>
</ul>
<ol>
<li>比较ping和traceroute程序在计算往返时间上的不同点。</li>
</ol>
<ul>
<li>答案：ping客户将ICMP回显请求报文的可选数据部分设置为分组发送的时间。这个可选的数据必须在ICMP回显应答中返回。这样使得即使分组返回时失序，客户也能计算出精确的回环时间。</li>
<li>traceroute客户不能这样操作，因为在ICMP差错报文中返回的只是UDP首部（图6-9），没有UDP数据。因此，traceroute必须记住它发送一个请求的时间，等待应答，然后计算两者的时间差。</li>
<li>这里显示了ping和traceroute的另一个不同点：ping每秒发送一个分组，而不管是否收到任何应答；traceroute发送一个请求，然后在发送下一个请求前等待一个应答或者一个超时。</li>
</ul>
<ol>
<li>我们已经说过，traceroute程序选取开始UDP目的主机端口号为33453，每发送一个数据报将此数加1。在1.9节中，我们说过暂时端口号通常是1024~5000之间的值，因此traceroute程序的目的主机端口号不可能是目的主机上所使用的端口号。在Solaris2.2系统中的情况也是如此吗？（提示：查看E.4节）</li>
</ol>
<ul>
<li>答案：因为默认情况下Solaris 2.2从32768开始使用临时的UDP端口，所以目的主机上的目的端口已经被使用的机会更大。</li>
</ul>
<ol>
<li>RFC 1393 [Malkin 1993b]提出了另一种判断到目的主机路径的方法。请问其优缺点是什么？</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<h1 id="ch09-IP选路"><a href="#ch09-IP选路" class="headerlink" title="ch09 IP选路"></a>ch09 IP选路</h1><h2 id="9-1-引言"><a href="#9-1-引言" class="headerlink" title="9.1 引言"></a>9.1 引言</h2><p>路由表经常被IP访问（在一个繁忙的主机上，一秒钟内可能要访问几百次），但是它被路由守护程序更新的频度却要低得多（可能大约30秒种一次）。当接收到ICMP重定向，报文时，路由表也要被更新</p>
<h2 id="9-2-选路的原理"><a href="#9-2-选路的原理" class="headerlink" title="9.2 选路的原理"></a>9.2 选路的原理</h2><p>IP执行选路机制，而路由守护程序则一般提供选路策略。</p>
<h3 id="9-2-1-简单路由表"><a href="#9-2-1-简单路由表" class="headerlink" title="9.2.1 简单路由表"></a>9.2.1 简单路由表</h3><p>先执行带-r选项的netstat命令列出路由表，然后以-n选项再次执行该命令，以数字格式打印出IP地址</p>
<p>对于一个给定的路由器，可以打印出五种不同的标志（flag）：</p>
<ul>
<li>U 该路由可以使用。</li>
<li>G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。</li>
<li>H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址：一个网络号，或者网络号与子网号的组合。</li>
<li>D 该路由是由重定向报文创建的（9.5节）。</li>
<li>M 该路由已被重定向报文修改（9.5节）。</li>
</ul>
<p>G标志区分了直接路由和间接路由。但是H标志表明，目的地址是一个完整的主机地址。</p>
<p>参考记数Refcnt（Reference count）列给出的是正在使用路由的活动进程个数。面向连接的协议如TCP在建立连接时要固定路由。</p>
<p>下一列（“use”）显示的是通过该路由发送的分组数。</p>
<p>最后一列（interface）是本地接口的名字。</p>
<p>Host Requirements RFC文档特别说明，IP层必须支持多个默认路由。但是，许多实现系统并不支持这一点。当存在多个默认路由时，一种常用的技术是按轮转方式使用它们</p>
<p>由于内核知道每个路由表项对应的接口，而且每个接口都有一个对应的子网掩码，因此每个路由表项都有一个隐含的子网掩码。</p>
<p>主机路由表的复杂性取决于主机所在网络的拓扑结构</p>
<ul>
<li>主机连在一个局域网上，只能访问局域网上的主机。这时路由表包含两项：一项是环回接口，另一项是局域网（如以太网）。</li>
<li>如果主机能够通过单个路由器访问其他网络（如Internet）时，那么就要进行下一步。一般情况下增加一个默认表项指向该路由器。</li>
<li>如果要新增其他的特定主机或网络路由，那么就要进行最后一步。</li>
</ul>
<h4 id="例子已理解-7"><a href="#例子已理解-7" class="headerlink" title="例子已理解"></a>例子已理解</h4><h3 id="9-2-2-初始化路由表"><a href="#9-2-2-初始化路由表" class="headerlink" title="9.2.2 初始化路由表"></a>9.2.2 初始化路由表</h3><p>每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。</p>
<p>到达主机或网络的路由如果不是直接相连的，那么就必须加入路由表。一个常用的方法是在系统引导时显式地在初始化文件中运行route命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route add default sun 1</span><br><span class="line">route add slip bsdi 1</span><br></pre></td></tr></table></figure>
<p>第3个参数（default和slip）代表目的端，第4个参数代表网关（路由器），最后一个参数代表路由的度量(metric)。route命令在度量值大于0时要为该路由设置G标志，否则，当耗费值为0时就不设置G标志。</p>
<p>初始化路由表的其他方法是运行路由守护程序（第10章）或者用较新的路由器发现协议（9.6节）。</p>
<h3 id="9-2-3-较复杂的路由表"><a href="#9-2-3-较复杂的路由表" class="headerlink" title="9.2.3 较复杂的路由表"></a>9.2.3 较复杂的路由表</h3><p>路由表中的目的地址就是点对点链路的另一端，网关地址为外出接口的本地IP地址</p>
<p>默认的路由表项的网关地址是路由器的地址，而不是SLIP链路的本地IP地址。其原因还是因为是间接路由，不是直接路由。</p>
<h3 id="9-2-4-没有到达目的地的路由"><a href="#9-2-4-没有到达目的地的路由" class="headerlink" title="9.2.4 没有到达目的地的路由"></a>9.2.4 没有到达目的地的路由</h3><p>如果路由表中没有默认项，而又没有找到匹配项，这时会发生什么情况呢？</p>
<ul>
<li>如果数据报是由本地主机产生的，那么就给发送该数据报的应用程序返回一个“主机不可达差错”或者“网络不可达差错”。</li>
<li>如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文。</li>
</ul>
<h2 id="9-3-ICMP主机与网络不可达差错"><a href="#9-3-ICMP主机与网络不可达差错" class="headerlink" title="9.3 ICMP主机与网络不可达差错"></a>9.3 ICMP主机与网络不可达差错</h2><p>当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文</p>
<p>但令人感兴趣的是，我们可以看到在返回差错报文之前，分组要在Internet上传送多远：</p>
<h4 id="例子已理解-8"><a href="#例子已理解-8" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>许多路由器只能在局部范围内工作。</p>
<p>顶层选路域维护大多数Internet网站的路由信息，而不使用默认路由。在Internet上存在5个这样的顶层选路域：NSFNET主干网、商业互联网交换（Commercial Internet Exchange: CIX）、NASA科学互联网（NASA Science Internet: NSI）、SprintLink以及欧洲IP主干网（EBONE）。</p>
<h2 id="9-4-转发或不转发"><a href="#9-4-转发或不转发" class="headerlink" title="9.4 转发或不转发"></a>9.4 转发或不转发</h2><p>一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用。如何进行这样的配置呢？</p>
<p>大多数伯克利派生出来的系统都有一个内核变量ipforwarding</p>
<h2 id="9-5-ICMP重定向差错"><a href="#9-5-ICMP重定向差错" class="headerlink" title="9.5 ICMP重定向差错"></a>9.5 ICMP重定向差错</h2><p>当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给IP数据报的发送端。这在概念上是很简单的，正如图9-3所示的那样。只有当主机可以选择路由器发送分组的情况下，我们才可能看到ICMP重定向报文（回忆我们在图7-6中看过的例子）。</p>
<ol>
<li>我们假定主机发送一份IP数据报给R1。这种选路决策经常发生，因为R1是该主机的默认路由。</li>
<li>R1收到数据报并且检查它的路由表，发现R2是发送该数据报的下一站。当它把数据报发送给R2时，R1检测到它正在发送的接口与数据报到达接口是相同的（即主机和两个路由器所在的LAN）。这样就给路由器发送重定向报文给原始发送端提供了线索。</li>
<li>R1发送一份ICMP重定向报文给主机，告诉它以后把数据报发送给R2而不是R1。</li>
</ol>
<p>重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。<br>ICMP重定向允许TCP/IP主机在进行选路时不需要具备智能特性，而把所有的智能特性放在路由器端。<br>连在LAN上的所有主机在启动时只需一个默认路由，通过接收重定向报文来逐步学习。</p>
<h3 id="9-5-1-一个例子"><a href="#9-5-1-一个例子" class="headerlink" title="9.5.1 一个例子"></a>9.5.1 一个例子</h3><p>子网140.252.1上的主机是如何访问作者所在子网（图中底下的四台主机）的呢？</p>
<ol>
<li>首先，如果在SLIP链路的一端只有一台主机，那么就要使用代理ARP（<a href="#4-6-ARP%E4%BB%A3%E7%90%86">4.6节</a>）。这意味着位于拓扑图顶部的子网（140.252.1）中的主机不需要其他特殊条件就可以访问主机sun（140.252.1.29）。位于netb上的代理ARP软件处理这些事情。</li>
<li>但是，当网络位于SLIP链路的另一端时，就要涉及到选路了。</li>
</ol>
<ul>
<li>一个办法是让所有的主机和路由器都知道路由器netb是网络140.252.13的网关。这可以<ul>
<li>在每个主机的路由表中设置静态路由</li>
<li>或者在每个主机上运行守护程序来实现。</li>
</ul>
</li>
<li>另一个更简单的办法（也是实际采用的方法）是利用ICMP重定向报文来实现。</li>
</ul>
<p>如果为ping程序指定-v选项，可以看到主机接收到的任何ICMP报文。我们需要指定该选项以观察发送的重定向报文。<code>ICMP Host redirect from ... to ... for ...</code></p>
<h3 id="9-5-2-更多的细节"><a href="#9-5-2-更多的细节" class="headerlink" title="9.5.2 更多的细节"></a>9.5.2 更多的细节</h3><p>ICMP重定向报文的格式如图9-4所示。</p>
<p>有四种不同类型的重定向报文，有不同的代码值，如图9-5所示。</p>
<p>ICMP重定向报文的接收者必须查看三个IP地址：(1)导致重定向的IP地址（即ICMP重定向报文的数据网络重定向主机重定向位于IP数据报的首部）；(2)发送重定向报文的路由器的IP地址（包含重定向信息的IP数据报中的源地址；(3)应该采用的路由器IP地址（在ICMP报文中的4~7字节）。</p>
<p>关于ICMP重定向报文有很多规则。首先，重定向报文只能由路由器生成，而不能由主机生成。另外，重定向报文是为主机而不是为路由器使用的。假定路由器和其他一些路由器共同参与某一种选路协议，则该协议就能消除重定向的需要</p>
<p>路由器应该发送的只是对主机的重定向（代码1或3，如图9-5所示），而不是对网络的重定向。子网的存在使得难于准确指明何时应发送对网络的重定向而不是对主机的重定向。</p>
<h2 id="9-6-ICMP路由器发现报文"><a href="#9-6-ICMP路由器发现报文" class="headerlink" title="9.6 ICMP路由器发现报文"></a>9.6 ICMP路由器发现报文</h2><p>初始化路由表的方法</p>
<ul>
<li>在配置文件中指定静态路由.</li>
<li>利用ICMP路由器通告和请求报文。</li>
</ul>
<p>一般认为，主机在引导以后要广播或多播传送一份路由器请求报文。一台或更多台路由器响应一份路由器通告报文。另外，路由器定期地广播或多播传送它们的路由器通告报文，允许每个正在监听的主机相应地更新它们的路由表。</p>
<p>ICMP路由器请求报文的格式如图9-6所示。ICMP路由器通告报文的格式如图9-7所示。</p>
<p>路由器在一份报文中可以通告多个地址。地址数指的是报文中所含的地址数。地址项大小指的是每个路由器地址32 bit字的数目，始终为2。生存期指的是通告地址有效的时间（秒数）。</p>
<p>接下来是一对或多对IP地址和优先级。IP地址必须是发送路由器的某个地址。优先级是一个有符号的32 bit整数，指出该IP地址作为默认路由器地址的优先等级，这是与子网上的其他路由器相比较而言的。值越大说明优先级越高。优先级为0x80000000说明对应的地址不能作为默认路由器地址使用，尽管它也包含中通告报文中。优先级的默认值一般为0。</p>
<h3 id="9-6-1-路由器操作"><a href="#9-6-1-路由器操作" class="headerlink" title="9.6.1 路由器操作"></a>9.6.1 路由器操作</h3><p>当路由器启动时，它定期在所有广播或多播传送接口上发送通告报文。</p>
<p>当路由器上的某个接口被关闭时，路由器可以在该接口上发送最后一份通告报文，并把生命周期值设为0。</p>
<p>路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。</p>
<p>如果子网上有多台路由器，由系统管理员为每个路由器设置优先等级。</p>
<h3 id="9-6-2-主机操作"><a href="#9-6-2-主机操作" class="headerlink" title="9.6.2 主机操作"></a>9.6.2 主机操作</h3><p>主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。</p>
<p>主机也监听来自相邻路由器的请求报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。</p>
<p>只要有一般的默认路由器，该路由器就会每隔10分钟发送通告报文，报文的生命周期是30分钟。这说明主机的默认表项是不会超时的，即使错过一份或两份通告报文。</p>
<h3 id="9-6-3-实现"><a href="#9-6-3-实现" class="headerlink" title="9.6.3 实现"></a>9.6.3 实现</h3><p>路由器发现报文一般由用户进程（守护程序）创建和处理。</p>
<p>这两种ICMP报文是新加的，不是所有的系统都支持它们。</p>
<h2 id="9-7-小结"><a href="#9-7-小结" class="headerlink" title="9.7 小结"></a>9.7 小结</h2><p>路由表项的内容很简单，包括：5bit标志、目的IP地址（主机、网络或默认）、下一站路由器的IP地址（间接路由）或者本地接口的IP地址（直接路由）及指向本地接口的指针。</p>
<h2 id="ch09-习题"><a href="#ch09-习题" class="headerlink" title="ch09 习题"></a>ch09 习题</h2><ol>
<li>为什么你认为存在两类ICMP重定向报文—网络和主机？</li>
</ol>
<ul>
<li>答案：当ICMP标准第1次发布时，RFC 792 [Postel 1981b]所述的划分子网技术还没有使用。另外，使用一个网络重定向而不是N个主机重定向（对于目的网络中的所有N个主机）也节省了路由表的空间。</li>
</ul>
<ol>
<li>在9.2节开头列出的svr4主机上的路由表中，到主机slip（140.252.13.65）的特定路由是必需的吗？如果把这一项从路由表中删除会有什么变化？</li>
</ol>
<ul>
<li>答案：这一项并不需要，但是如果把它删除了，所有到slip的IP数据报将被发送到默认的路由器（sun），后者又将把它们送到路由器bsdi。既然sun将数据报从与接收数据报相同的接口转发出去，它把一个ICMP重定向到svr4。这样在svr4中又创建了我们删除过的同样的路由表项，尽管这一次是因为重定向而创建的，而不是在引导时增加的。</li>
</ul>
<ol>
<li>考虑有一电缆连接4.2BSD主机和4.3BSD主机。假定网络号是140.1。4.2BSD主机把主机号为全0的地址识别为广播地址(140.1.0.0)，而4.3BSD通常使用全1的主机号（140.1.255.255）发送广播。另外，4.2BSD主机在默认条件下要尽力转发接收到的数据报，尽管它们只有一个接口。请描述当4.2BSD主机收到一份目的地址为140.1.255.255的IP数据报时会发生什么事。</li>
</ol>
<ul>
<li>答案：当那个4.2BSD主机收到目的地址是140.1.255.255的数据报，发现它有一个通往该网络（140.1）的路由，因此就试图转发数据报。它发送一个ARP广播来寻找140.1.255.255。这个ARP请求没有收到任何应答，所以这个数据报最终被丢弃。如果在网线上有很多这样的4.2BSD主机，每一个都在差不多同一时刻发送ARP这个广播，将会暂时地阻塞网络。</li>
</ul>
<ol>
<li>继续前一个习题，假定有人在子网140.1上的某个系统ARP高速缓存中增加了一项（用arp命令）内容，指定IP地址140.1.255.255对应的以太网地址为全1（以太网广播地址）。请描述此时发生的情况。</li>
</ol>
<ul>
<li>答案：这次，每一个ARP请求都收到一个应答，告诉每个4.2BSD主机向一个指定的硬件地址（以太网广播）发送数据报。如果网线上有k个这样的4.2BSD主机，全部收到了它们自己的ARP应答，使得每一个生成了另一个广播。每个主机都收到了每一个目的地址为140.1.255.255的广播IP数据报，既然现在每个主机都有一个ARP缓存项，这个数据报又被转发给了广播地址。这个过程继续下去，就会产生一次以太网的熔毁(Ethernetmeltdown)。[Manber 1990]描述了网络中另一种形式的链式反应。</li>
</ul>
<ol>
<li>检查你所使用的系统上的路由表，并解释每一项内容。</li>
</ol>
<ul>
<li>无答案。已上机实验</li>
</ul>
<h1 id="ch10-动态选路协议"><a href="#ch10-动态选路协议" class="headerlink" title="ch10 动态选路协议"></a>ch10 动态选路协议</h1><h2 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言"></a>10.1 引言</h2><p>在前面各章中，我们讨论了静态选路。在配置接口时，以默认方式生成路由表项（对于直接连接的接口），并通过route命令增加表项（通常从系统自引导程序文件），或是通过ICMP重定向生成表项（通常是在默认方式出错的情况下）。</p>
<p>在网络很小，且与其他网络只有单个连接点且没有多余路由时（若主路由失败，可以使用备用路由），采用这种方法是可行的。如果上述三种情况不能全部满足，通常使用动态选路。</p>
<h2 id="10-2-动态选路"><a href="#10-2-动态选路" class="headerlink" title="10.2 动态选路"></a>10.2 动态选路</h2><p>动态选路并不改变我们在9.2节中所描述的内核在IP层的选路方式。这种选路方式称为选路机制（routing mechanism）。<br>仅仅是放置到路由表中的信息改变了</p>
<p>Internet是以一组自治系统(AS，Autonomous System)的方式组织的，每个自治系统通常由单个实体管理。</p>
<p>每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为内部网关协议IGP（Interior Gateway Protocol）或域内选路协议（intradomain routing protocol）。</p>
<h2 id="10-3-Unix选路守护程序"><a href="#10-3-Unix选路守护程序" class="headerlink" title="10.3 Unix选路守护程序"></a>10.3 Unix选路守护程序</h2><p>Unix系统上常常运行名为routed路由守护程序。</p>
<p>图10-1对routed和两种不同版本的gated所支持的不同选路协议进行了比较。大多数运行路由守护程序的系统都可以运行routed，除非它们需要支持gated所支持的其他协议。</p>
<h2 id="10-4-RIP：选路信息协议"><a href="#10-4-RIP：选路信息协议" class="headerlink" title="10.4 RIP：选路信息协议"></a>10.4 RIP：选路信息协议</h2><h3 id="10-4-1-报文格式"><a href="#10-4-1-报文格式" class="headerlink" title="10.4.1 报文格式"></a>10.4.1 报文格式</h3><p>RIP报文包含中在UDP数据报中</p>
<p>图10-3给出了使用IP地址时的RIP报文格式。</p>
<p>命令字段为1表示请求，2表示应答。还有两个舍弃不用的命令（3和4），两个非正式的命令：轮询（5）和轮询表项（6）。请求表示要求其他系统发送其全部或部分路由表。应答则包含发送者全部或部分路由表。</p>
<p>版本字段通常为1，而第2版RIP（10.5节）将此字段设置为2。</p>
<p>紧跟在后面的20字节指定地址系列（address family）（对于IP地址来说，其值是2）、IP地址以及相应的度量。在本节的后面可以看出，RIP的度量是以跳计数的。</p>
<p>采用这种20字节格式的RIP报文可以通告多达25条路由。<br>为了发送整个路由表，经常需要多个报文。</p>
<h3 id="10-4-2-正常运行"><a href="#10-4-2-正常运行" class="headerlink" title="10.4.2 正常运行"></a>10.4.2 正常运行</h3><p>让我们来看一下采用RIP协议的routed程序正常运行的结果。RIP常用的UDP端口号是520。</p>
<ul>
<li>初始化：在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。</li>
<li>接收到请求。如果这个请求是刚才提到的特殊请求，那么路由器就将完整的路由表发送给请求者。否则，就处理请求中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量置为16</li>
<li>接收到响应。使响应生效，可能会更新路由表。可能会增加新表项，对已有的表项进行修改，或是将已有表项删除。</li>
<li>定期选路更新。每过30秒，所有或部分路由器会将其完整路由表发送给相邻路由器。<br>触发更新。每当一条路由的度量发生变化时，就对它进行更新。不需要发送完整路由表，而只需要发送那些发生变化的表项。</li>
</ul>
<p>每条路由都有与之相关的定时器。如果运行RIP的系统发现一条路由在3分钟内未更新，就将该路由的度量设置成无穷大（16），并标注为删除。这意味着已经在6个30秒更新时间里没收到通告该路由的路由器的更新了。再过60秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。</p>
<h3 id="10-4-3-度量"><a href="#10-4-3-度量" class="headerlink" title="10.4.3 度量"></a>10.4.3 度量</h3><p>RIP所使用的度量是以跳(hop)计算的。所有直接连接接口的跳数为1。</p>
<p>度量为16表示到无路由到达该IP地址。</p>
<h3 id="10-4-4-问题"><a href="#10-4-4-问题" class="headerlink" title="10.4.4 问题"></a>10.4.4 问题</h3><p>这种方法看起来很简单，但它有一些缺陷。首先，RIP没有子网地址的概念。<br>有一些实现中通过接收到的RIP信息，来使用接口的网络掩码，而这有可能出错。</p>
<p>其次，在路由器或链路发生故障后，需要很长的一段时间才能稳定下来。这段时间通常需要几分钟。</p>
<h3 id="10-4-5-举例"><a href="#10-4-5-举例" class="headerlink" title="10.4.5 举例"></a>10.4.5 举例</h3><p>ripquery程序通过发送一个非正式请求（图10-3中命令字段为5的“poll”）给路由器，要求得到其完整的路由表。如果在5秒内未收到响应，则发送标准的RIP请求</p>
<p>我们为tcpdump程序指定-s600选项，以让它从网络中读取600个字节。采用-i s10选项指定SLIP接口。</p>
<p>英文输出</p>
<ul>
<li><code>metric 2</code>表示度量为2</li>
<li><code>rip-poll 24</code>表示RIP轮询命令；请求报文的长度为24</li>
<li><code>rip-req 24</code>表示常规的RIP请求；请求报文的长度为24</li>
<li><code>rip-resp 25</code>表示应答报文，又叫响应报文；包含了25个地址和度量对</li>
</ul>
<h3 id="10-4-6-另一个例子"><a href="#10-4-6-另一个例子" class="headerlink" title="10.4.6 另一个例子"></a>10.4.6 另一个例子</h3><p>snoop程序只捕获广播报文、多播报文以及发送给主机的报文。</p>
<p>-P标志以非混杂模式捕获报文，-tr打印出相应的时戳，而udp port 520只捕获信源或信宿端口号为520的UDP数据报。</p>
<p>加上-v参数来查看RIP报文的全部内容</p>
<p>snoop输出“BROADCAST”符号，它表示目的IP地址是有限的广播地址255.255.255.255（12.2节），而不是其他路由器用来指向子网的广播地址</p>
<h2 id="10-5-RIP版本2"><a href="#10-5-RIP版本2" class="headerlink" title="10.5 RIP版本2"></a>10.5 RIP版本2</h2><p>RIP-2并不改变协议本身，而是利用图10-3中的一些标注为“必须为0”的字段来传递一些额外的信息。</p>
<p>图10-10重新给出了由RIP-2定义的图。对于RIP-2来说，其版本字段为2。</p>
<p>选路域(routing domain)允许管理者在单个路由器上运行多个RIP实例，每个实例在一个选路域内运行。</p>
<p>选路标记(routing tag)是为了支持外部网关协议而存在的。它携带着一个EGP和BGP的自治系统号。</p>
<p>每个表项的子网掩码应用于相应的IP地址上。下一站IP地址指明发往目的IP地址的报文该发往哪里。该字段为0意味着发往目的地址的报文应该发给发送RIP报文的系统。</p>
<p>RIP-2提供了一种简单的鉴别机制。可以指定RIP报文的前20字节表项地址系列为0xffff，路由标记为2。表项中的其余16字节包含一个明文口令。</p>
<p>最后，RIP-2除了广播（第12章）外，还支持多播。这可以减少不收听RIP-2报文的主机的负载。</p>
<h2 id="10-6-OSPF：开放最短路径优先"><a href="#10-6-OSPF：开放最短路径优先" class="headerlink" title="10.6 OSPF：开放最短路径优先"></a>10.6 OSPF：开放最短路径优先</h2><p>与采用距离向量的RIP协议不同的是，OSPF是一个链路状态协议。</p>
<p>链路状态协议总是比距离向量协议收敛更快。</p>
<p>OSPF直接使用IP。也就是说，它并不使用UDP或TCP。对于IP首部的protocol字段，OSPF有其自己的值</p>
<p>OSPF还有着一些优于RIP的特点。</p>
<ul>
<li>OSPF可以对每个IP服务类型（图3-2）计算各自的路由集。这意味着对于任何目的，可以有多个路由表表项，每个表项对应着一个IP服务类型。</li>
<li>给每个接口指派一个无维数的费用。可以通过吞吐率、往返时间、可靠性或其他性能来进行指派。可以给每个IP服务类型指派一个单独的费用。</li>
<li>当对同一个目的地址存在着多个相同费用的路由时，OSPF在这些路由上平均分配流量。我们称之为流量平衡。</li>
<li>OSPF支持子网：子网掩码与每个通告路由相连。这样就允许将一个任何类型的IP地址分割成多个不同大小的子网（我们在3.7节中给出了这样的一个例子，称之为变长度子网）。到一个主机的路由是通过全1子网掩码进行通告的。默认路由是以IP地址为0.0.0.0、网络掩码为全0进行通告的。</li>
<li>路由器之间的点对点链路不需要每端都有一个IP地址，我们称之为无编号网络。这样可以节省IP地址—现在非常紧缺的一种资源。</li>
<li>采用了一种简单鉴别机制。可以采用类似于RIP-2机制（10.5节）的方法指定一个明文口令。</li>
<li>OSPF采用多播（第12章），而不是广播形式，以减少不参与OSPF的系统负载。</li>
</ul>
<h2 id="10-7-BGP：边界网关协议"><a href="#10-7-BGP：边界网关协议" class="headerlink" title="10.7 BGP：边界网关协议"></a>10.7 BGP：边界网关协议</h2><p>可以将Internet的总拓扑结构看成是由一些残桩自治系统、多接口自治系统以及转送自治系统的任意互连。残桩自治系统和多接口自治系统不需要使用BGP——它们通过运行EGP在自治系统之间交换可到达信息。</p>
<p>指定策略允许BGP实现在存在多个可选路径时选择路径，并控制信息的重发送。选路策略与政治、安全或经济因素有关。</p>
<p>BGP与RIP和OSPF的不同之处在于BGP使用TCP作为其传输层协议。</p>
<h2 id="10-8-CIDR：无类型域间选路"><a href="#10-8-CIDR：无类型域间选路" class="headerlink" title="10.8 CIDR：无类型域间选路"></a>10.8 CIDR：无类型域间选路</h2><p>每个C类网络都需要一个路由表表项。无类型域间选路（CIDR）是一个防止Internet路由表膨胀的方法，它也称为超网（supernetting）。</p>
<p>CIDR的基本观点是采用一种分配多个IP地址的方式，使其能够将路由表中的许多表项总和(summarization)成更少的数目。</p>
<p>要使用这种总和，必须满足以下三种特性：</p>
<ul>
<li>这些IP地址必须具有相同的高位地址比特。</li>
<li>路由表和选路算法必须扩展成根据32 bit IP地址和32 bit掩码做出选路决策。</li>
<li>必须扩展选路协议使其除了32 bit地址外，还要有32 bit掩码。OSPF（10.6节）和RIP-2（10.5节）都能够携带第4版BGP所提出的32 bit掩码。</li>
</ul>
<p>CIDR同时还使用一种技术，使最佳匹配总是最长的匹配</p>
<p>“无类型”的意思是现在的选路决策是基于整个32 bit IP地址的掩码操作，而不管其IP地址是A类、B类或是C类，都没有什么区别。</p>
<h2 id="10-9-小结"><a href="#10-9-小结" class="headerlink" title="10.9 小结"></a>10.9 小结</h2><ol>
<li>在图10-9中哪些路由是从路由器kpno进入gateway的？</li>
</ol>
<ul>
<li>答案：路由表中有13条来自于kpno：除了140.252.101.0和140.252.104.0之外的所有gateway直接相连的其他网络。</li>
</ul>
<ol>
<li>假设一个路由器要使用RIP通告30个路由，这需要一个包含25条路由和另一个包含5条路由的数据报。如果每过一个小时，第一个包含25条路由的数据报丢失一次，那么其结果如何？</li>
</ol>
<ul>
<li>答案：丢失的数据报中通告的25条路由需要60秒才能得到更新。这不成问题，因为一般来说一条路由如果连续3分钟没有得到更新，RIP才会声明它失效。</li>
</ul>
<ol>
<li>OSPF报文格式中有一个检验和字段，而RIP报文则没有此项，这是为什么？</li>
</ol>
<ul>
<li>答案：RIP运行在UDP上，而UDP提供了UDP数据报中数据部分的一个可选的检验和（11.3节）。然而，OSPF运行在IP上，IP的检验和只覆盖了IP首部，所以OSPF必须增加它自己的检验和字段。</li>
</ul>
<ol>
<li>像OSPF这样的负载平衡，对于传输层的影响是什么？</li>
</ol>
<ul>
<li>答案：负载平衡增加了分组被失序交付的机会，并且很可能使得运输层计算的环回时间出错。</li>
</ul>
<ol>
<li>查阅RFC1058 关于实现RIP的其他资料。在图10-8中，140.252.1网络的每个路由器只通告它所提供的路由，而它并不能通过其他路由器的广播中知道任何其他路由。这种技术的名称是什么？</li>
</ol>
<ul>
<li>答案：这叫作简单的分裂范围（split horizon）。</li>
</ul>
<ol>
<li>在3.4节中，我们说过除了图10-7中所示的8个路由器外，140.252.1子网上还有超过100个主机。那么这100个主机是如何处理每30秒到达它们的8个广播信息呢（图10-8）？</li>
</ol>
<ul>
<li>答案：在图12-1中，我们显示了100个主机的每一个都通过设备驱动程序、IP层和UDP层来处理这个广播的UDP数据报。当它们发现UDP端口520没有被使用时，这个广播数据报才最终被丢弃。</li>
</ul>
<h1 id="ch11-UDP：用户数据报协议"><a href="#ch11-UDP：用户数据报协议" class="headerlink" title="ch11 UDP：用户数据报协议"></a>ch11 UDP：用户数据报协议</h1><h2 id="11-1-引言"><a href="#11-1-引言" class="headerlink" title="11.1 引言"></a>11.1 引言</h2><p>UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。这与面向流字符的协议不同，如TCP</p>
<h2 id="11-2-UDP首部"><a href="#11-2-UDP首部" class="headerlink" title="11.2 UDP首部"></a>11.2 UDP首部</h2><p>UDP首部的各字段如图11-2所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0            15 16            31</span><br><span class="line">+--------------+---------------+</span><br><span class="line">| 16位源端口号 | 16位目的端口号|</span><br><span class="line">+--------------+---------------+</span><br><span class="line">| 16位UDP长度  | 16位UDP检验和 |</span><br><span class="line">+--------------*---------------+</span><br><span class="line">|         数据（如果有）       |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure>
<p>端口号表示发送进程和接收进程。<br>IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值）</p>
<p>UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为8字节（发送一份0字节的UDP数据报是OK）。</p>
<h2 id="11-3-UDP检验和"><a href="#11-3-UDP检验和" class="headerlink" title="11.3 UDP检验和"></a>11.3 UDP检验和</h2><p>UDP检验和覆盖UDP首部和UDP数据。回想IP首部的检验和，它只覆盖IP的首部</p>
<p>其次，UDP数据报和TCP段都包含一个12字节长的伪首部，它是为了计算检验和而设置的。伪首部包含IP首部一些字段。其目的是让UDP两次检查数据是否已经正确到达目的地（例如，IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）。UDP数据报中的伪首部格式如图11-3所示。</p>
<p>TCP的检验和是必需的。UDP的检验和是可选的。如果检验和的计算结果为0，则存入的值为全1（65535），这在二进制反码计算中是等效的。如果传送的检验和为0，说明发送端没有计算检验和。</p>
<h3 id="11-3-1-tcpdump输出"><a href="#11-3-1-tcpdump输出" class="headerlink" title="11.3.1 tcpdump输出"></a>11.3.1 tcpdump输出</h3><p>作者在tcpdump程序中增加了一个选项</p>
<p><code>udp 9 (UDP cksum=0)</code>表示包含9个字节数据的UDP数据报，它没有计算检验和</p>
<h3 id="11-3-2-一些统计结果"><a href="#11-3-2-一些统计结果" class="headerlink" title="11.3.2 一些统计结果"></a>11.3.2 一些统计结果</h3><p>TCP发生检验和差错的比例与UDP相比要高得多。这很可能是因为在该系统中的TCP连接经常是“远程”连接（经过许多路由器和网桥等中间设备），而UDP一般为本地通信。</p>
<h2 id="11-4-一个简单的例子"><a href="#11-4-一个简单的例子" class="headerlink" title="11.4 一个简单的例子"></a>11.4 一个简单的例子</h2><p>用我们自己编写的sock程序生成一些可以通过tcpdump观察的UDP数据报：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bsdi % sock -v -u -i -n4 svr4 discard</span><br><span class="line">connected on 140.252.13.35.1108 to 140.252.13.34.9</span><br><span class="line">bsdi % sock -v -u -i -n4 -w0 svr4 discard</span><br><span class="line">connected on 140.252.13.35.1110 to 140.252.13.34.9</span><br></pre></td></tr></table></figure>
<p>第1次执行这个程序时，我们指定verbose模式（-v）来观察ephemeral端口号，指定UDP（-u）而不是默认的TCP，并且指定源模式（-i）来发送数据，而不是读写标准的输入和输出。-n4选项指明输出4份数据报（默认条件下为1024），目的主机为svr4。在1.12节描述了丢弃服务。每次写操作的输出长度取默认值1024。</p>
<p>第2次运行该程序时我们指定-w0，意思是写长度为0的数据报。</p>
<p>每次运行程序时，源端的UDP端口号都发生变化。</p>
<h2 id="11-5-IP分片"><a href="#11-5-IP分片" class="headerlink" title="11.5 IP分片"></a>11.5 IP分片</h2><p>正如我们在2.8节描述的那样，物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</p>
<p>把一份IP数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。IP首部中包含的数据为分片和重新组装提供了足够的信息。</p>
<p>回忆IP首部（图3-1）的标志字段</p>
<ul>
<li>其中一个比特来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该比特置1。片偏移字段指的是该片偏移原始数据报开始处的位置。另外，当数据报被分片后，每个片的总长度值要改为该片的长度值。</li>
<li>有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。相反把数据报丢弃并发送一个ICMP差错报文（“需要进行分片但设置了不分片比特”，见图6-3）给起始端。</li>
</ul>
<p>尽管IP分片过程看起来是透明的，但有一点让人不想使用它：即使只丢失一片数据也要重传整个数据报。</p>
<p>如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。</p>
<p>我们可以用sock程序来增加数据报的长度，直到分片发生。</p>
<p>相应的tcpdump输出中，<code>(frag 36304:1480@0+)</code>表示IP首部中标识字段的值为26304，除IP首部外的片长为1480，位于@符号后的数字是从数据报开始处计算的片偏移值</p>
<p>任何运输层首部只出现在第1片数据中。</p>
<p>另外需要解释几个术语：IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后），分组是指在IP层和链路层之间传送的数据单元。一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。</p>
<h2 id="11-6-ICMP不可达差错（需要分片）"><a href="#11-6-ICMP不可达差错（需要分片）" class="headerlink" title="11.6 ICMP不可达差错（需要分片）"></a>11.6 ICMP不可达差错（需要分片）</h2><p>发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首部又设置了不分片（DF）的标志比特。如果某个程序需要判断到达目的端的路途中最小MTU是多少—称作路径MTU发现机制（2.9节），那么这个差错就可以被该程序使用。</p>
<p>这种情况下的ICMP不可达差错报文格式如图11-9所示。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在点到点的链路中，不要求两个方向的MTU为相同值。</p>
<p>所采用的技术是在主机solaris上运行ping程序到主机bsdi，增加数据分组长度，直到看见进入的分组被分片为止。</p>
<p>相应的tcpdump输出中</p>
<ul>
<li>(DF) 说明在IP首部中设置了不分片比特。</li>
<li>mtu=0 表示主机sun没有在ICMP不可达报文中返回出口MTU值</li>
</ul>
<p>DF标志被复制到回显应答报文中。这就带来了问题。</p>
<p>分组的路径如图11-12所示。</p>
<h2 id="11-7-用Traceroute确定路径MTU"><a href="#11-7-用Traceroute确定路径MTU" class="headerlink" title="11.7 用Traceroute确定路径MTU"></a>11.7 用Traceroute确定路径MTU</h2><p>尽管大多数的系统不支持路径MTU发现功能，但可以很容易地修改traceroute程序（第8章），用它来确定路径MTU。要做的是发送分组，并设置“不分片”标志比特。发送的第一个分组的长度正好与出口MTU相等，每次收到ICMP“不能分片”差错时（在上一节讨论的）就减小分组的长度。如果路由器发送的ICMP差错报文是新格式，包含出口的MTU，那么就用该MTU值来发送，否则就用下一个最小的MTU值来发送。</p>
<h4 id="例子已理解-9"><a href="#例子已理解-9" class="headerlink" title="例子已理解"></a>例子已理解</h4><h3 id="全球互联网"><a href="#全球互联网" class="headerlink" title="全球互联网"></a>全球互联网</h3><p>现在许多但不是所有的广域网都可以处理大于512字节的分组。利用路径MTU发现机制，应用程序就可以充分利用更大的MTU来发送报文。</p>
<h2 id="11-8-采用UDP的路径MTU发现"><a href="#11-8-采用UDP的路径MTU发现" class="headerlink" title="11.8 采用UDP的路径MTU发现"></a>11.8 采用UDP的路径MTU发现</h2><p>如果应用程序写了一个对于一些中间链路来说太长的数据报时会发生什么情况。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>可以用下面的命令行来产生650字节UDP数据报，每两个UDP数据报之间的间隔是5秒：<br><code>solaris %sock -u -i -n10 -w650 -p5 slip discard</code></p>
<p>在本例中，solaris不应该对外出数据报分片，它应该将DF比特置0，让具有最小MTU的路由器来完成分片工作。</p>
<h2 id="11-9-UDP和ARP之间的交互作用"><a href="#11-9-UDP和ARP之间的交互作用" class="headerlink" title="11.9 UDP和ARP之间的交互作用"></a>11.9 UDP和ARP之间的交互作用</h2><p>我们用sock程序来产生一个包含8192字节数据的UDP数据报。预测这将会在以太网上产生6个数据报片（见习题11.3）。同时也确保在运行该程序前，ARP缓存是清空的，这样，在发送第一个数据报片前必须交换ARP请求和应答。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bsdi % arp -a         #验证ARP高速缓存是空的</span><br><span class="line">bsdi % sock -u -i -nl -w8192 svr4 discard</span><br></pre></td></tr></table></figure>
<p>两个问题：在接收到ARP回答前，其余数据报片是否已经做好了发送准备？如果是这样，那么在ARP等待应答时，它会如何处理发往给定目的的多个报文？</p>
<ul>
<li>在第一个ARP应答返回以前，总共产生了6个ARP请求。我们认为其原因是IP很快地产生了6个数据报片，而每个数据报片都引发了一个ARP请求。</li>
<li>在接收到第一个ARP应答时（第7行），只发送最后一个数据报片（第9行）！看来似乎将前5个数据报片全都丢弃了。实际上，这是ARP的正常操作。<br>在大多数的实现中，在等待一个ARP应答时，只将最后一个报文发送给特定目的主机。</li>
</ul>
<p>Host Requirements RFC要求实现中必须防止这种类型的ARP洪泛（ARP flooding，即以高速率重复发送到同一个IP地址的ARP请求）。建议最高速率是每秒一次。</p>
<p>在给定数据报的第一个到达数据报片出现时，IP层必须启动一个定时器。如果定时器超时而该数据报的所有数据报片未能全部到达，那么将这些数据报片丢弃。如果不这么做，那些永远不会到达的数据报片（正如我们在本例中所看到的那样）迟早会引起接收端缓存满。</p>
<p>最后要指出的是，在最后一个ARP应答返回后，并没有发送ICMP“组装超时”差错。原因有两个</p>
<ul>
<li>大多数从Berkeley派生的实现从不产生该差错！这些实现会设置定时器，也会在定时器溢出时将数据报片丢弃，但是不生成ICMP差错。</li>
<li>并未接收到包含UDP首部的偏移量为0的第一个数据报片</li>
</ul>
<h2 id="11-10-最大UDP数据报长度"><a href="#11-10-最大UDP数据报长度" class="headerlink" title="11.10 最大UDP数据报长度"></a>11.10 最大UDP数据报长度</h2><p>除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。</p>
<p>我们将遇到两个限制因素。</p>
<ul>
<li>第一，应用程序可能会受到其程序接口的限制。</li>
<li>第二个限制来自于TCP/IP的内核实现。</li>
</ul>
<p>在3.2节中提过，要求主机必须能够接收最短为576字节的IP数据报。在许多UDP应用程序的设计中，其应用程序数据被限制成512字节或更小，因此比这个限制值小。</p>
<h3 id="数据报截断"><a href="#数据报截断" class="headerlink" title="数据报截断"></a>数据报截断</h3><p>由于IP能够发送或接收特定长度的数据报并不意味着接收应用程序可以读取该长度的数据。因此，UDP编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？</p>
<p>不幸的是，该问题的答案取决于编程接口和实现。</p>
<h2 id="11-11-ICMP源站抑制差错"><a href="#11-11-ICMP源站抑制差错" class="headerlink" title="11.11 ICMP源站抑制差错"></a>11.11 ICMP源站抑制差错</h2><p>当一个系统（路由器或主机）接收数据报的速度比其处理速度快时，<strong>可能</strong>产生这个差错。</p>
<p>图11-18给出了ICMP源站抑制差错报文的格式。有一个很好的方案可以在我们的测试网络里产生该差错报文。</p>
<p><code>sock -u -i -w1024 -n100 solaris discard</code>从主机bsdi通过路由器sun发送100个1024字节长数据报给solaris。</p>
<p>相对应的tcpdump输出中，<code>icmp source quench</code>表示源站抑制差错报文</p>
<p>由于源站抑制要消耗网络带宽，且对于拥塞来说是一种无效而不公平的调整，因此现在人们对于源站抑制差错的态度是不支持的。</p>
<h2 id="11-12-UDP服务器的设计"><a href="#11-12-UDP服务器的设计" class="headerlink" title="11.12 UDP服务器的设计"></a>11.12 UDP服务器的设计</h2><h3 id="11-12-1-客户IP地址及端口号"><a href="#11-12-1-客户IP地址及端口号" class="headerlink" title="11.12.1 客户IP地址及端口号"></a>11.12.1 客户IP地址及端口号</h3><p>这个特性允许一个交互UDP服务器对多个客户进行处理。给每个发送请求的客户发回应答。</p>
<h3 id="11-12-2-目的IP地址"><a href="#11-12-2-目的IP地址" class="headerlink" title="11.12.2 目的IP地址"></a>11.12.2 目的IP地址</h3><p>一些应用程序需要知道数据报是发送给谁的。</p>
<p>这就要求操作系统从接收到的UDP数据报中将目的IP地址交给应用程序。不幸的是，并非所有的实现都提供这个功能。</p>
<h3 id="11-12-3-UDP输入队列"><a href="#11-12-3-UDP输入队列" class="headerlink" title="11.12.3 UDP输入队列"></a>11.12.3 UDP输入队列</h3><p>我们在1.8节中说过，大多数UDP服务器是交互服务器。这意味着，单个服务器进程对单个UDP端口上（服务器上的名知端口）的所有客户请求进行处理。</p>
<p>通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。</p>
<p>然而，排队溢出造成内核中的UDP模块丢弃数据报的可能性是存在的。可以进行以下试验。我们在作为UDP服务器的bsdi主机上运行sock程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bsdi % sock -s -u -v -E -R256 -P30 6666</span><br><span class="line">from 140.252.13.33, to 140.252.13.63: 1111111111  从发送到广播地址</span><br><span class="line">from 140.252.13.34, to 140.252.13.35: 4444444444444  从svr4发送到单播地址</span><br></pre></td></tr></table></figure>
<p>我们指明以下标志：-s表示作为服务器运行，-u表示UDP，-v表示打印客户的IP地址，-E表示打印目的IP地址（该系统支持这个功能）。另外，我们将这个端口的UDP接收缓存设置为256字节（-R），其每次应用程序读取的大小也是这个数（-r）。标志-P30表示创建UDP端口后，先暂停30秒后再读取第一个数据报。这样，我们就有时间在另两台主机上启动客户程序，发送一些数据报，以查看接收队列是如何工作的。</p>
<ul>
<li>首先，应用程序并不知道其输入队列何时溢出。只是由UDP对超出数据报进行丢弃处理。</li>
<li>同时，从tcpdump输出结果，我们看到，没有发回任何信息告诉客户其数据报被丢弃。这里不存在像ICMP源站抑制这样发回发送端的消息。</li>
<li>最后，看来UDP输出队列是FIFO（先进先出）的，而我们在11.9节中所看到的ARP输入却是LIFO（后进先出）的。</li>
</ul>
<h3 id="11-12-4-限制本地IP地址"><a href="#11-12-4-限制本地IP地址" class="headerlink" title="11.12.4 限制本地IP地址"></a>11.12.4 限制本地IP地址</h3><p>大多数UDP服务器在创建UDP端点时都使其本地IP地址具有通配符(wildcard)的特点。这就表明进入的UDP数据报如果其目的地为服务器端口，那么在任何本地接口均可接收到它。例如，我们以端口号777启动一个UDP服务器：<br><code>sun % sock -u -s 7777</code><br>然后，用netstat命令观察端点的状态：<br>-a选项表示报告所有网络端点的状态。-n选项表示以点数格式打印IP地址而不用DNS把地址转换成名字，打印数字端口号而不是服务名称。-finet选项表示只报告TCP和UDP端点。</p>
<p>当服务器创建端点时，它可以把其中一个主机本地IP地址包括广播地址指定为端点的本地IP地址。只有当目的IP地址与指定的地址相匹配时，进入的UDP数据报才能被送到这个端点。用我们的sock程序，如果在端口号之前指定一个IP地址，那么该IP地址就成为该端点的本地IP地址。例如：<br><code>sun % sock -u -s 140.252.1.29 7777</code><br>就限制服务器在SLIP接口(140.252.1.29)处接收数据报</p>
<p>有可能在相同的端口上启动不同的服务器，每个服务器具有不同的本地IP地址。但是<br>除了第一个以外，其他的服务器都必须以-A选项启动，告诉系统可以重用同一个端口号。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/11/images2/52im_net_27.png" alt="5个服务器的netstat输出结果"><br>使用sockets API时，必须指定SO_REUSEADDR socket选项。在sock程序中是通过-A选项来完成的。</p>
<h3 id="11-12-5-限制远端IP地址"><a href="#11-12-5-限制远端IP地址" class="headerlink" title="11.12.5 限制远端IP地址"></a>11.12.5 限制远端IP地址</h3><p>在前面所有的netstat输出结果中，远端IP地址和远端端口号都显示为*.*，其意思是该端点将接受来自任何IP地址和任何端口号的UDP数据报。大多数系统允许UDP端点对远端地址进行限制。</p>
<p>这说明端点将只能接收特定IP地址和端口号的UDP数据报。sock程序用-f选项来指定远端IP地址和端口号：<code>sun % sock -u -s -f 140.252.13.35.4444 5555</code><br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/11/images2/52im_net_28.png" alt="图11-22 为UDP服务器指定本地和远端IP地址及端口号"></p>
<h3 id="11-12-6-每个端口有多个接收者"><a href="#11-12-6-每个端口有多个接收者" class="headerlink" title="11.12.6 每个端口有多个接收者"></a>11.12.6 每个端口有多个接收者</h3><p>尽管在RFC中没有指明，但大多数的系统在某一时刻只允许一个程序端点与某个本地I P地址及UDP端口号相关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun % sock -u -s 9999</span><br><span class="line">sun % sock -u -s -A 9999</span><br></pre></td></tr></table></figure>
<p>如果启动另一个具有相同本地地址和端口号的服务器，那么它将不运行，尽管我们指定了-A选项</p>
<p>在一个支持多播的系统上（第12章），这种情况将发生变化。多个端点可以使用同一个IP地址和UDP端口号，尽管应用程序通常必须告诉API是可行的（如，用-A标志来指明SO_REUSEADDRsocket选项）。</p>
<p>当UDP数据报到达的目的IP地址为广播地址或多播地址，而且在目的IP地址和端口号处有多个端点时，就向每个端点传送一份数据报的复制（端点的本地IP地址可以含有星号，它可匹配任何目的IP地址）。但是，如果UDP数据报到达的是一个单播地址，那么只向其中一个端点传送一份数据报的复制。选择哪个端点传送数据取决于各个不同的系统实现。</p>
<h2 id="11-13-小结"><a href="#11-13-小结" class="headerlink" title="11.13 小结"></a>11.13 小结</h2><p>UDP向用户进程提供的服务位于IP层之上，包括端口号和可选的检验和。我们用UDP来检查检验和，并观察分片是如何进行的。</p>
<p>接着，我们讨论了ICMP不可达差错，它是新的路径MTU发现功能中的一部分（2.9节）。用Tr aceroute和UDP来观察路径MTU发现过程。还查看了UDP和ARP之间的接口，大多数的ARP实现在等待ARP应答时只保留最近传送给目的端的数据报。</p>
<p>当系统接收IP数据报的速率超过这些数据报被处理的速率时，系统可能发送ICMP源站抑制差错报文。</p>
<h2 id="ch11-习题"><a href="#ch11-习题" class="headerlink" title="ch11 习题"></a>ch11 习题</h2><ol>
<li>在11.5节中，向UDP数据报中写入1473字节用户数据时导致以太网数据报片的发生。在采用以太网IEEE 802封装格式时，导致分片的最小用户数据长度为多少？</li>
</ol>
<ul>
<li>答案是：因为使用IEEE 802封装时，存在8个额外的首部字节，所以1465个字节的用户数据是引起分片的最小长度。</li>
</ul>
<ol>
<li>阅读RFC 791 [Postel 1981a]，理解为什么除最后一片外，其他片中的数据长度均要求为8字节的整数倍？</li>
</ol>
<ul>
<li>无答案</li>
</ul>
<ol>
<li>假定有一个以太网和一份8192字节的UDP数据报，那么需要分成多少个数据报片，每个数据报片的偏移和长度为多少？</li>
</ol>
<ul>
<li>答案是：对于IP来说有8200字节的数据需要发送，8192字节的用户数据和8个字节的UDP首部。采用tcpdump记号，第1个分片是1480@0+（1480字节的数据，偏移为0，将“更多片”比特置1）。第2个是1480@1480+，第3个是1480@2960+，第4个是1480@4440+，第5个是1480@5920+，第6个是800@7400。1480×5+800=8200，正好是要发送的字节。</li>
</ul>
<ol>
<li>继续前一习题，假定这些数据报片要经过一条MTU为552的SLIP链路。必须记住每一个数据报片中的数据（除IP首部外）为8字节的整数倍。那么又将分成多少个数据报片？每个数据报片的偏移和长度为多少？</li>
</ol>
<ul>
<li>答案是：每个1480字节的数据报片被分成三小片：两个528字节和一个424字节。小于532（55220）的8的最大倍数是528。800字节的数据报片被分成两小片：一个528字节和一个272字节。这样，原来8192字节的数据报变成了SLIP链路上的17个帧。</li>
</ul>
<ol>
<li>一个用UDP发送数据报的应用程序，它把数据报分成4个数据报片。假定第1片和第2片到达目的端，而第3片和第4片丢失了。应用程序在10秒钟后超时重发该UDP数据报，并且被分成相同的4片（相同的偏移和长度）。假定这一次接收主机重新组装的时间为60秒，那么当重发的第3片和第4片到达目的端时，原先收到的第1片和第2片还没有被丢弃。接收端能否把这4片数据重新组装成一份IP数据报？</li>
</ol>
<ul>
<li>答案是：不。问题是当应用程序超时重传时，重传产生的IP数据报有一个新的标识字段。而重新装配只针对那些具有相同标识字段的分段。</li>
</ul>
<ol>
<li>你是如何知道图11-15中的片实际上与图11-14中第5行和第6行相对应？</li>
</ol>
<ul>
<li>答案是：IP首部中的标识字段（47942）是一样的。</li>
</ul>
<ol>
<li>主机gemini开机33天后，netstat程序显示48 000 000份IP数据报中由于首部检验和差错被丢弃129份，在30 000 000个TCP段中由于TCP检验和差错而被丢弃20个。但是，在大约18 000 000份UDP数据报中，因为UDP检验和差错而被丢弃的数据报一份也没有。请说明两个方面的原因（提示：参见图11-4）。</li>
</ol>
<ul>
<li>答案是：第一，从图11-4我们看到gemini没有使能输出UDP的检验和。如果输出UDP的检验和没有被使能，这个主机上的操作系统（SunOS 4.1.1）就不会验证一个进入UDP的检验和。第二，大多数的UDP通信量都是本地的，而不是WA N的，因此没有服从所有的WA N特征。</li>
</ul>
<ol>
<li>在讨论分片时没有提及任何关于IP首部中的选项——它们是否也要被复制到每个数据报片中，或者只留在第一个数据报片中？我们已经讨论过下面这些IP选项：记录路由（7.3节）、时间戳（7.4节）、严格和宽松的源站选路（8.5节）。你希望分片如何处理这些选项？对照RFC 791检查你的答案。</li>
</ol>
<ul>
<li>答案是：<strong>不严格的和严格的源站选路选项被复制到每一个数据报片中。</strong>时间戳选项和记录路由选项没有被复制到每一个数据报片中—它们只出现在第1个数据报片中。</li>
</ul>
<ol>
<li>在图1-8中，我们说UDP数据报是根据目的UDP端口号进行分配的。这正确吗？</li>
</ol>
<ul>
<li>答案是：不。在11.12节中，我们看到很多实现可以根据目的IP地址、源IP地址和源端口号来过滤送往一个给定UDP端口号的输入数据报。</li>
</ul>
<h1 id="ch12-广播和多播"><a href="#ch12-广播和多播" class="headerlink" title="ch12 广播和多播"></a>ch12 广播和多播</h1><h2 id="12-1-引言"><a href="#12-1-引言" class="headerlink" title="12.1 引言"></a>12.1 引言</h2><p>广播和多播仅应用于UDP</p>
<p>为了弄清广播和多播，需要了解主机对由信道传送过来帧的过滤过程。图12-1说明了这一过程。</p>
<p>首先，网卡查看由信道传送过来的帧，确定是否接收该帧，若接收后就将它传往设备驱动程序。通常网卡仅接收那些目的地址为网卡物理地址或广播地址的帧。另外，多数接口均被设置为混合模式，这种模式能接收每个帧的一个复制。作为一个例子，tcpdump使用这种模式。</p>
<p>目前，大多数的网卡经过配置都能接收目的地址为多播地址或某些子网多播地址的帧。对于以太网，当地址中最高字节的最低位设置为1时表示该地址是一个多播地址，用十六进制可表示为01:00:00:00:00:00（以太网广播地址ff:ff:ff:ff:ff:ff可看作是以太网多播地址的特例）。</p>
<p>如果网卡收到一个帧，这个帧将被传送给设备驱动程序（如果帧检验和错，网卡将丢弃该帧）。设备驱动程序将进行另外的帧过滤。首先，帧类型中必须指定要使用的协议（IP、ARP等等）。其次，进行多播过滤来检测该主机是否属于多播地址说明的多播组。</p>
<p>设备驱动程序随后将数据帧传送给下一层，比如，当帧类型指定为IP数据报时，就传往IP层。IP根据IP地址中的源地址和目的地址进行更多的过滤检测。如果正常，就将数据报传送给下一层（如TCP或UDP）。</p>
<p>每次UDP收到由IP传送来的数据报，就根据目的端口号，有时还有源端口号进行数据报过滤。如果当前没有进程使用该目的端口号，就丢弃该数据报并产生一个ICMP不可达报文（TCP根据它的端口号作相似的过滤）。如果UDP数据报存在检验和错，将被丢弃。</p>
<p>使用广播的问题在于它增加了对广播数据不感兴趣主机的处理负荷。拿一个使用UDP广播应用作为例子。如果网内有50个主机，但仅有20个参与该应用，每次这20个主机中的一个发送UDP广播数据时，其余30个主机不得不处理这些广播数据报。一直到UDP层，收到的UDP广播数据报才会被丢弃。</p>
<p>多播的出现减少了对应用不感兴趣主机的处理负荷。使用多播，主机可加入一个或多个多播组。这样，网卡将获悉该主机属于哪个多播组，然后仅接收主机所在多播组的那些多播帧。</p>
<h2 id="12-2-广播"><a href="#12-2-广播" class="headerlink" title="12.2 广播"></a>12.2 广播</h2><h3 id="12-2-1-受限的广播"><a href="#12-2-1-受限的广播" class="headerlink" title="12.2.1 受限的广播"></a>12.2.1 受限的广播</h3><p>受限的广播地址是255.255.255.255。</p>
<p>路由器不转发目的地址为受限的广播地址的数据报</p>
<p>如果一个主机是多接口的，广播是否应该将数据报发送到每个相连的接口上？<br>大多数BSD系统将255.255.255.255看作是配置后第一个接口的广播地址，并且不提供向所属具备广播能力的接口传送数据报的功能。</p>
<h3 id="12-2-2-指向网络的广播"><a href="#12-2-2-指向网络的广播" class="headerlink" title="12.2.2 指向网络的广播"></a>12.2.2 指向网络的广播</h3><p>指向网络的广播地址是主机号为全1的地址。A类网络广播地址为netid.255.255.255</p>
<p>一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p>
<h3 id="12-2-3-指向子网的广播"><a href="#12-2-3-指向子网的广播" class="headerlink" title="12.2.3 指向子网的广播"></a>12.2.3 指向子网的广播</h3><p>指向子网的广播地址为主机号为全1且有特定子网号的地址。</p>
<h3 id="12-2-4-指向所有子网的广播"><a href="#12-2-4-指向所有子网的广播" class="headerlink" title="12.2.4 指向所有子网的广播"></a>12.2.4 指向所有子网的广播</h3><p>指向所有子网的广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。</p>
<h2 id="12-3-广播的例子"><a href="#12-3-广播的例子" class="headerlink" title="12.3 广播的例子"></a>12.3 广播的例子</h2><p><code>ping 255.255.255.255</code>无法进行，原因在于本网广播地址（255.255.255.255）也被当作存在差错而返回-1。</p>
<p>指向子网的广播是我们应该使用的。IP通过目的地址（140.252.13.63）来确定，这是指向子网的广播地址</p>
<p>广播与ARP之间的相互作用。执行ping命令前ARP缓存是空的，而执行后是满的</p>
<p>如果使用tcpdump来观察ping的执行过程，可以看到广播数据帧的接收者在发送它的响应之前，首先产生一个对sun主机的ARP请求，因为它的应答是单播的。在4.5节我们介绍了一个ARP请求的接收者（该例中是sun）通常在发送ARP应答外，还将请求主机的IP地址和物理地址加入到ARP缓存中去。</p>
<p>如果使用不支持广播的应用如TFTP，程序立即产生了一个差错，但不向网络发送任何信息。产生这一切的原因在于，插口提供的应用程序接口API只有在进程明确打算进行广播时才允许它向广播地址发送UDP数据报。</p>
<p>下一个问题是是否转发广播数据。有些系统内核和路由器有一选项来控制允许或禁止这一特性（见附录E）。</p>
<p>如果让路由器bsdi能够转发广播数据，然后在主机slip上运行ping程序，就能够观察到由路由器bsdi转发的子网广播数据报。</p>
<p>BSD系统中的ping程序检查重复的数据报序列号。如果出现重复序列号的数据报就显示DUP!，这意味着一个数据报已经在某处重复了，然而它正是我们所期望看到的，因为我们正向一个广播地址发送数据。</p>
<p>广播是一种应该谨慎使用的功能。在许多情况下，IP多播被证明是一个更好的解决办法。</p>
<h2 id="12-4-多播"><a href="#12-4-多播" class="headerlink" title="12.4 多播"></a>12.4 多播</h2><p>IP多播提供两类服务：</p>
<ul>
<li>向多个目的地址传送数据。</li>
<li>客户对服务器的请求。例如，无盘工作站需要确定启动引导服务器。目前，这项服务是通过广播来提供的（正如第16章的BOOTP），但是使用多播可降低不提供这项服务主机的负担。</li>
</ul>
<h3 id="12-4-1-多播组地址"><a href="#12-4-1-多播组地址" class="headerlink" title="12.4.1 多播组地址"></a>12.4.1 多播组地址</h3><p>能够接收发往一个特定多播组地址数据的主机集合称为主机组(host group)。一个主机组可跨越多个网络。主机组中成员可随时加入或离开主机组。主机组中对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送信息。</p>
<p>一些多播组地址被IANA确定为知名地址。它们也被当作永久主机组，这和TCP及UDP中的熟知端口相似。同样，这些知名多播地址在RFC最新分配数字中列出。注意这些多播地址所代表的组是永久组，而它们的组成员却不是永久的。</p>
<h3 id="12-4-2-多播组地址到以太网地址的转换"><a href="#12-4-2-多播组地址到以太网地址的转换" class="headerlink" title="12.4.2 多播组地址到以太网地址的转换"></a>12.4.2 多播组地址到以太网地址的转换</h3><p>IANA拥有一个以太网地址块，即高位24 bit为00:00:5e（十六进制表示），这意味着该地址块所拥有的地址范围从00:00:5e:00:00:00到00:00:5e:ff:ff:ff。IANA将其中的一半分配为多播地址。为了指明一个多播地址，任何一个以太网地址的首字节必须是01，这意味着与IP多播相对应的以太网地址范围从01:00:5e:00:00:00到01:00:5e:7f:ff:ff。</p>
<p>这种地址分配将使以太网多播地址中的23bit与IP多播组号对应起来，通过将多播组号中的低位23bit映射到以太网地址中的低位23bit实现，这个过程如图12-3所示。</p>
<p>由于多播组号中的最高5bit在映射过程中被忽略，因此每个以太网多播地址对应的多播组是不唯一的。32个不同的多播组号被映射为一个以太网地址。例如，多播地址224.128.64.32（十六进制e0.80.40.20）和224.0.64.32（十六进制e0.00.40.20）都映射为同一以太网地址01:00:5e:00:40:20。</p>
<p>既然地址映射是不唯一的，那么设备驱动程序或IP层（见图12-1）就必须对数据报进行过滤。因为网卡可能接收到主机不想接收的多播数据帧。另外，如果网卡不提供足够的多播数据帧过滤功能，设备驱动程序就必须接收所有多播数据帧，然后对它们进行过滤。</p>
<p>局域网网卡趋向两种处理类型：一种是网卡根据对多播地址的散列值实行多播过滤，这意味仍会接收到不想接收的多播数据；另一种是网卡只接收一些固定数目的多播地址，这意味着当主机想接收超过网卡预先支持多播地址以外的多播地址时，必须将网卡设置为“多播混杂(multicast promiscuous)”模式。因此，这两种类型的网卡仍需要设备驱动程序检查收到的帧是否真是主机所需要的。</p>
<p>即使网卡实现了完美的多播过滤（基于48 bit的硬件地址），由于从D类IP地址到48 bit的硬件地址的映射不是一对一的，过滤过程仍是必要的。尽管存在地址映射不完美和需要硬件过滤的不足，多播仍然比广播好。</p>
<p>单个物理网络的多播是简单的。多播进程将目的IP地址指明为多播地址，设备驱动程序将它转换为相应的以太网地址，然后把数据发送出去。这些接收进程必须通知它们的IP层，它们想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧。这个过程就是“加入一个多播组”（使用“接收进程”复数形式的原因在于对一确定的多播信息，在同一主机或多个主机上存在多个接收者，这也是为什么要首先使用多播的原因）。当一个主机收到多播数据报时，它必须向属于那个多播组的每个进程均传送一个复制。这和单个进程收到单播UDP数据报的UDP不同。使用多播，一个主机上可能存在多个属于同一多播组的进程。</p>
<p>当把多播扩展到单个物理网络以外需要通过路由器转发多播数据时，复杂性就增加了。需要有一个协议让多播路由器了解确定网络中属于确定多播组的任何一个主机。这个协议就是Internet组管理协议（IGMP），也是下一章介绍的内容。</p>
<h3 id="12-4-3-FDDI和令牌环网络中的多播"><a href="#12-4-3-FDDI和令牌环网络中的多播" class="headerlink" title="12.4.3 FDDI和令牌环网络中的多播"></a>12.4.3 FDDI和令牌环网络中的多播</h3><p>FDDI网络使用相同的D类IP地址到48 bit FDDI地址的映射过程[Katz 1990]。令牌环网络通常使用不同的地址映射方法，这是因为大多数令牌控制中的限制。</p>
<h2 id="12-5-小结"><a href="#12-5-小结" class="headerlink" title="12.5 小结"></a>12.5 小结</h2><p>目前有四种类型的广播地址：受限的广播、指向网络的广播、指向子网的广播和指向所有子网的广播。最常用的是指向子网的广播。受限的广播通常只在系统初始启动时才会用到。</p>
<h2 id="ch12-习题"><a href="#ch12-习题" class="headerlink" title="ch12 习题"></a>ch12 习题</h2><ol>
<li>广播是否增加了网络通信量？</li>
</ol>
<ul>
<li>答案是：广播本身不会增加网络通信量，但它增加了额外的主机处理时间。如果接收主机不正确地响应了诸如ICMP端口不可达之类的差错，那么广播也可能导致额外的网络通信量。路由器一般不转发广播分组，而网桥一般转发，所以在一个桥接网络上的广播分组可能比在一个路由网络上走得更远。</li>
</ul>
<ol>
<li>考虑一个拥有50台主机的以太网：20台运行TCP/IP，其他30台运行其他的协议族。主机如何处理来自运行另一个协议族主机的广播？</li>
</ol>
<ul>
<li>答案是：每个主机都收到了所有广播分组的一个副本。接口层收到了帧，把它传递给设备驱动程序。如果类型字段指的是其他协议，设备驱动程序就会丢弃该帧。</li>
</ul>
<ol>
<li>登录到一个过去从来没有用过的Unix系统，并且打算找出所有支持广播的接口的指向子网的广播地址。如何做到这点？</li>
</ol>
<ul>
<li>答案是：首先执行netstat -r来看一下路由表，结果显示了所有接口的名字。然后对每个接口执行ifconfig（3.8节）：标志指出了一个接口是否支持广播，如果支持，相应的广播地址也会被输出。</li>
</ul>
<ol>
<li>如果我们用ping程序向一个广播地址发送一个长的分组，如<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/12/images2/52im_net_7.png"><br>它正常工作，但将分组的长度再增加一个字节后出现如下差错：<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/12/images2/52im_net_8.png"><br>究竟出了什么问题?</li>
</ol>
<ul>
<li>答案是：伯克利演变的实现不允许对一个广播数据报进行分片。当我们说明了1472字节的长度，产生的IP数据报将是1500字节，正好是以太网的MTU。不允许分片一个广播数据报是一个策略上的决定—没有技术上的原因（并不是想要减少广播分组的数目）。</li>
</ul>
<ol>
<li>重做习题10.6，假定8个RIP报文是通过多播而不是广播（使用RIP版本2）。有什么变化？</li>
</ol>
<ul>
<li>答案是：依赖于100个主机上不同的以太网接口卡的多播支持，多播数据报可能被接口卡忽略，或者被设备驱动程序丢弃。</li>
</ul>
<h1 id="ch13-IGMP：Internet组管理协议"><a href="#ch13-IGMP：Internet组管理协议" class="headerlink" title="ch13 IGMP：Internet组管理协议"></a>ch13 IGMP：Internet组管理协议</h1><h2 id="13-1-引言"><a href="#13-1-引言" class="headerlink" title="13.1 引言"></a>13.1 引言</h2><p>本章将介绍用于支持主机和路由器进行多播的Internet组管理协议（IGMP）。它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。</p>
<p>不像我们已经见到的其他协议，IGMP有固定的报文长度，没有可选数据。</p>
<h2 id="13-2-IGMP报文"><a href="#13-2-IGMP报文" class="headerlink" title="13.2 IGMP报文"></a>13.2 IGMP报文</h2><p>图13-2显示了长度为8字节的IGMP报文格式。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/13/images2/52im_net_2.png" alt="图13-2 IGMP报文的字段格式"><br>这是版本为1的IGMP。IGMP类型为1说明是由多播路由器发出的查询报文，为2说明是主机发出的报告报文。检验和的计算和ICMP协议相同。</p>
<p>组地址为D类IP地址。在查询报文中组地址设置为0，在报告报文中组地址为要参加的组地址。</p>
<h2 id="13-3-IGMP协议"><a href="#13-3-IGMP协议" class="headerlink" title="13.3 IGMP协议"></a>13.3 IGMP协议</h2><h3 id="13-3-1-加入一个多播组"><a href="#13-3-1-加入一个多播组" class="headerlink" title="13.3.1 加入一个多播组"></a>13.3.1 加入一个多播组</h3><p>进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加入的多播组。这些是一个支持多播主机中任何API所必需的部分。</p>
<h3 id="13-3-2-IGMP报告和查询"><a href="#13-3-2-IGMP报告和查询" class="headerlink" title="13.3.2 IGMP报告和查询"></a>13.3.2 IGMP报告和查询</h3><p>多播路由器使用IGMP报文来记录与该路由器相连网络中组成员的变化情况。使用规则如下：</p>
<ul>
<li>当第一个进程加入一个组时，主机就发送一个IGMP报告。如果一个主机的多个进程加入同一组，只发送一个IGMP报告。这个报告被发送到进程加入组所在的同一接口上。</li>
<li>进程离开一个组时，主机不发送IGMP报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的IGMP查询中就不再发送报告报文。</li>
<li>多播路由器定时发送IGMP查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个IGMP查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此IGMP查询报文中的组地址被设置为0。</li>
<li>主机通过发送IGMP报告来响应一个IGMP查询，对每个至少还包含一个进程的组均要发回IGMP报告。<br>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。<h3 id="13-3-3-实现细节"><a href="#13-3-3-实现细节" class="headerlink" title="13.3.3 实现细节"></a>13.3.3 实现细节</h3>如果一个主机在等待发送报告的过程中，却收到了发自其他主机的相同报告，则该主机的响应就可以不必发送了。因为多播路由器并不关心有多少主机属于该组，而只关心该组是否还至少拥有一个主机。的确，一个多播路由器甚至不关心哪个主机属于一个多播组。</li>
</ul>
<p>在没有任何多播路由器的单个物理网络中，仅有的IGMP通信量就是在主机加入一个新的多播组时，支持IP多播的主机所发出的报告。</p>
<h3 id="13-3-4-生存时间字段"><a href="#13-3-4-生存时间字段" class="headerlink" title="13.3.4 生存时间字段"></a>13.3.4 生存时间字段</h3><p>在默认情况下，待传多播数据报的TTL被设置为1，这将使多播数据报仅局限在同一子网内传送。更大的TTL值能被多播路由器转发。</p>
<p>回顾6.2节，对发往一个多播地址的数据报从不会产生ICMP差错。</p>
<p>通过增加TTL值的方法，一个应用程序可实现对一个特定服务器的扩展环搜索(expanding ring search)。</p>
<p>从224.0.0.0到224.0.0.255的特殊地址空间是打算用于多播范围不超过1跳的应用。不管TTL值是多少，多播路由器均不转发目的地址为这些地址中的任何一个地址的数据报。</p>
<h3 id="13-3-5-所有主机组"><a href="#13-3-5-所有主机组" class="headerlink" title="13.3.5 所有主机组"></a>13.3.5 所有主机组</h3><p>在图13-3中，我们看到了路由器的IGMP查询被送到目的IP地址224.0.0.1。该地址被称为所有主机组地址。它涉及在一个物理网络中的所有具备多播能力的主机和路由器。当接口初始化后，所有具备多播能力接口上的主机均自动加入这个多播组。这个组的成员无需发送IGMP报告。</p>
<h2 id="13-4-一个例子"><a href="#13-4-一个例子" class="headerlink" title="13.4 一个例子"></a>13.4 一个例子</h2><p>采用一个经过修改的netstat命令来报告每个接口上的多播组成员情况</p>
<p>其中，-n参数将以数字形式显示IP地址（而不是按名字来显示它们），-i参数将显示接口的统计结果，-a参数将显示所有配置的接口。</p>
<p><code>netstat -rn</code>显示IP路由表，用于多播的路由表同正常的路由表一样。黑体表项显示了所有传往224.0.0.0的数据报均被送往以太网</p>
<p>现在使用一个测试程序来让我们能在一个接口上加入一个多播组</p>
<p>加入多播组只发生在一个接口上。</p>
<p>相对应的tcpdump输出中，加入多播组和IGMP报告都显示<code>igmp report 224.1.2.3 [ttl 1]</code></p>
<p>个多播路由器必须接收在它所有接口上的所有多播数据报。路由器无法确定主机可能加入哪个多播组。</p>
<h3 id="多播路由器的例子"><a href="#多播路由器的例子" class="headerlink" title="多播路由器的例子"></a>多播路由器的例子</h3><p>相对应的tcpdump输出中，<code>igmp query</code>表示IGMP查询的目的IP地址为224.0.0.1（所有主机组）</p>
<h2 id="13-5-小结"><a href="#13-5-小结" class="headerlink" title="13.5 小结"></a>13.5 小结</h2><p>简单的主机成员报告协议(IGMP)是多播的基本模块。</p>
<p>在一个局域网中或跨越邻近局域网的多播需要使用本章介绍的技术。</p>
<p>然而，多播还未解决的一个问题是在广域网内的多播。</p>
<h2 id="ch13-习题"><a href="#ch13-习题" class="headerlink" title="ch13 习题"></a>ch13 习题</h2><ol>
<li>我们知道主机通过设置随机时延来调度IGMP的发送。一个局域网中的主机采取什么措施才能避免两台主机产生相同的随机时延？</li>
</ol>
<ul>
<li>答案是：生成随机数时要使用对于主机唯一的值。IP地址和链路层地址是每个主机都应该不一样的两个值。日期时间是一个不好的选择，尤其是在所有的主机都运行了一个类似于NTP的协议来同步它们的时钟的情况下。</li>
</ul>
<ol>
<li>在[Casner and Deering 1992]中，他们提到UDP缺少两个通过MBONE传送音频采样数据的条件：分组失序检测和分组重复检测。你怎样在UDP上增加这些功能？</li>
</ol>
<ul>
<li>答案是：他们增加了一个包括一个序号和一个时间戳的应用协议首部。</li>
</ul>
<h1 id="ch14-DNS：域名系统"><a href="#ch14-DNS：域名系统" class="headerlink" title="ch14 DNS：域名系统"></a>ch14 DNS：域名系统</h1><h2 id="14-1-引言"><a href="#14-1-引言" class="headerlink" title="14.1 引言"></a>14.1 引言</h2><p>DNS是用于TCP/IP的分布式数据库。<br>每个站点（如大学、公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供Internet上的其他系统查询。</p>
<p>在一个应用程序请求TCP打开一个连接或使用UDP发送一个数据报之前。心须将一个主机名转换为一个IP地址。操作系统内核中的TCP/IP协议族对于DNS一点都不知道。</p>
<h2 id="14-2-DNS基础"><a href="#14-2-DNS基础" class="headerlink" title="14.2 DNS基础"></a>14.2 DNS基础</h2><p>顶级域名被分为三个部分</p>
<ul>
<li>arpa用作地址到名字的转换（<a href="#14-5-%E6%8C%87%E9%92%88%E6%9F%A5%E8%AF%A2">CF：14.5节</a>）</li>
<li>7个3字符长的普通域com、org等等，也称为组织域</li>
<li>所有2字符长的域均是国家域或地理域</li>
</ul>
<p>通常认为3字符长的普通域仅用于美国的组织机构，但情况并不总是这样。普通域中只有gov和mil域局限于美国。</p>
<p>NIC负责分配顶级域和委派其他指定地域的授权机构。<br>一个独立管理的DNS子树被称为一个区域(zone)</p>
<p>一旦一个区域的授权机构被委派后，由它负责向该区域提供多个名字服务器。<br>一个名字服务器负责一个或多个区域。一个区域的管理者必须为该区域提供一个主名字服务器和至少一个辅助名字服务器。</p>
<p>当一个新主机加入一个区域时，区域管理者将适当的信息（最少包括名字和IP地址）加入到运行在主名字服务器上的一个磁盘文件中，然后通知主名字服务器重新调入它的配置文件。辅名字服务器定时（通常是每隔3小时）向主名字服务器询问是否有新数据。如果有新数据，则通过区域传送方式获得新数据。</p>
<h2 id="14-3-DNS的报文格式"><a href="#14-3-DNS的报文格式" class="headerlink" title="14.3 DNS的报文格式"></a>14.3 DNS的报文格式</h2><p>DNS定义了一个用于查询和响应的报文格式。图14-3显示这个报文的总体格式。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_3.png" alt="图14-3 DNS查询和响应的一般格式"><br>这个报文由12字节长的首部和4个长度可变的字段组成。</p>
<ul>
<li>查询问题</li>
<li>回答</li>
<li>授权</li>
<li>额外信息</li>
</ul>
<p>标识字段由客户程序设置并由服务器返回结果。客户程序通过它来确定响应与查询是否匹配。</p>
<p>16 bit的标志字段被划分为若干子字段，如图14-4所示。</p>
<ul>
<li>QR是1bit字段：0表示查询报文，1表示响应报文。</li>
<li>opcode是一个4bit字段：通常值为0（标准查询），其他值为1（反向查询）和2（服务器状态请求）。</li>
<li>AA是1bit标志，表示“授权回答(authoritative answer)”。该名字服务器是授权于该域的。</li>
<li>TC是1bit字段，表示“可截断的(truncated)”。使用UDP时，它表示当应答的总长度超过512字节时，只返回前512个字节。</li>
<li>RD是1bit字段表示“期望递归（recursion desired）”。该比特能在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个递归查询。如果该位为0，且被请求的名字服务器没有一个授权回答，它就返回一个能解答该查询的其他名字服务器列表，这称为迭代查询。在后面的例子中，我们将看到这两种类型查询的例子。</li>
<li>RA是1bit字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为1。在后面的例子中可看到大多数名字服务器都提供递归查询，除了某些根服务器。</li>
<li>随后的3bit字段必须为0。</li>
<li>rcode是一个4bit的返回码字段。通常的值为0（没有差错）和3（名字差错）。名字差错只有从一个授权名字服务器上返回，它表示在查询中制定的域名不存在。<br>随后的4个16 bit字段说明最后4个变长字段中包含的条目数。对于查询报文，问题(question)数通常是1，而其他3项则均为0。类似地，对于应答报文，回答数至少是1，剩下的两项可以是0或非0。</li>
</ul>
<h3 id="14-3-1-DNS查询报文中的问题部分"><a href="#14-3-1-DNS查询报文中的问题部分" class="headerlink" title="14.3.1 DNS查询报文中的问题部分"></a>14.3.1 DNS查询报文中的问题部分</h3><p>问题部分中的每个问题的格式如图14-5所示，通常只有一个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0                             31</span><br><span class="line">+-----------------------------+</span><br><span class="line">|            查询名            |</span><br><span class="line">+---------------*-------------+</span><br><span class="line">|    查询类型    |    查询类    |</span><br><span class="line">+---------------+-------------+</span><br><span class="line">             图14-5</span><br></pre></td></tr></table></figure>
<ul>
<li>查询名是要查找的名字，它是一个或多个标识符的序列。每个标识符以首字节的计数值来说明随后标识符的字节长度，每个名字以最后字节为0结束。</li>
<li>每个问题有一个查询类型，而每个响应也有一个类型。最常用的查询类型是A类型，表示期望获得查询名的IP地址</li>
<li>查询类通常是1，指互联网地址。</li>
</ul>
<h3 id="14-3-2-DNS响应报文中的资源记录部分"><a href="#14-3-2-DNS响应报文中的资源记录部分" class="headerlink" title="14.3.2 DNS响应报文中的资源记录部分"></a>14.3.2 DNS响应报文中的资源记录部分</h3><p>回答字段、授权字段和附加信息字段均采用一种称为资源记录RR的相同格式。图14-8显示了资源记录的格式。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_8.png" alt="图14-8 DNS资源记录格式"><br>域名是记录中资源数据对应的名字。它的格式和前面介绍的查询名字段格式（图14-6）相同。</p>
<p>类型说明RR的类型码。它的值和前面介绍的查询类型值是一样的。类通常为1，指Internet数据。</p>
<p>生存时间字段是客户程序保留该资源记录的秒数。资源记录通常的生存时间值为2天。</p>
<p>资源数据长度说明资源数据的数量。该数据的格式依赖于类型字段的值。对于类型1（A记录）资源数据是4字节的IP地址。</p>
<h2 id="14-4-一个简单的例子"><a href="#14-4-一个简单的例子" class="headerlink" title="14.4 一个简单的例子"></a>14.4 一个简单的例子</h2><p>在sun上执行<code>telnet gemini daytime</code></p>
<p>sun主机上的文件/etc/resolv.conf将告诉名字解析器做什么</p>
<p>第1行给出名字服务器—主机noao.edu的IP地址。最多可说明3个名字服务器行来提供足够的后备以防名字服务器故障或不可达。域名行说明默认域名。如果要查找的域名不是一个完全合格的域名（没有以句点结束），那末默认的域名.tuc.noao.edu将加到待查名后。</p>
<p>图14-10显示了名字解析器与名字服务器之间的分组交换。相应的tcpdump输出中</p>
<ul>
<li>第1行中冒号后的字段（1+）表示标识字段为1，加号“+”表示RD标志（期望递归）为1。默认情况下，名字解析器要求递归查询方式。</li>
<li>下一个字段为A?，表示查询类型为A（我们需要一个IP地址），该问号指明它是一个查询（不是一个响应）。待查名字显示在后面：gemini.tuc.noao.edu.。名字解析器在待查名字后加上句点号指明它是一个绝对字段名。</li>
<li>在UDP数据报中的用户数据长度显示为37字节：12字节为固定长度的报文首部（图14-3）；21字节为查询名字（图14-6），以及用于查询类型和查询类的4个字节。在DNS报文中无需填充数据。</li>
<li>tcpdump程序的第2行显示的是从名字服务器发回的响应。1*是标识字段，星号表示设置AA标志（授权回答）（该服务器是noao.edu域的主域名服务器，其回答在该域内是可相信的。）</li>
<li>输出结果2/0/0表示在响应报文中最后3个变长字段的资源记录数：回答RR数为2，授权RR和附加信息RR数均为0。tcpdump仅显示第一个回答，回答类型为A（IP地址），值为140.252.1.11。 </li>
</ul>
<p>为什么我们的查询会得到两个回答？这是因为gemini是多接口主机，因此得到两个IP地址。事实上，另一个有用的DNS工具是一个称为host的公开程序，它能将查询传递给名字服务器，并显示返回的结果。如果使用这个程序，就能看到这个多地址主机的两个IP地址：</p>
<p>如果在输入Telnet命令后间隔很长时间才显示IP地址，这个时延是由名字解析器和名字服务器在由域名到IP地址的解析所引起的。而显示Trying到显示Connectedto的时延则是由客户与服务器建立TCP连接所引起的，与DNS无关。</p>
<h2 id="14-5-指针查询"><a href="#14-5-指针查询" class="headerlink" title="14.5 指针查询"></a>14.5 指针查询</h2><p>指针查询，即给定一个IP地址，返回与改地址对应的域名。</p>
<p>当一个组织加入Internet，并获得DNS域名空间的授权，如noao.edu，则它们也获得了对应IP地址的in-addr.arpa域名空间的授权。<br>如果DNS树中没有独立出arpa来处理指针查询，将需要数天或数周的时间来从树根开始依次尝试每个顶级域。</p>
<h3 id="14-5-1-举例"><a href="#14-5-1-举例" class="headerlink" title="14.5.1 举例"></a>14.5.1 举例</h3><p>使用host程序完成一个指针查询，并使用tcpdump程序来观察这些分组。例子中的设置和图14-9相同，在sun主机上运行host程序，名字服务器在主机noao.edu上。我们指明svr4主机的IP地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun % host 140.252.13.34</span><br><span class="line">Name: svr4.tuc.noao.edu</span><br><span class="line">Address: 140.252.13.34</span><br></pre></td></tr></table></figure>
<p>既然IP地址是仅有的命令行参数，host程序将自动产生指针查询。相应的tcpdump输出中</p>
<ul>
<li>第1行显示标识符为1，期望递归标志设置为1（加号“+”），查询类型为PTR（应注意：问号“？”表示它是一个查询而不是响应）。44字节的数据包括12字节的DNS报文首部、28字节的域名标识符和4字节的查询类型和查询类。</li>
<li>查询结果包含一个回答RR，且为授权回答比特置1（带星号）。RR的类型是PTR，资源数据中包含该域名。</li>
</ul>
<h3 id="14-5-2-主机名检查"><a href="#14-5-2-主机名检查" class="headerlink" title="14.5.2 主机名检查"></a>14.5.2 主机名检查</h3><p>当一个IP数据报到达一个作为服务器的主机时，无论是UDP数据报还是TCP连接请求，服务器进程所能获得的是客户的IP地址和端口号（UDP或TCP）。某些服务器需要客户的IP地址来获得在DNS中的指针记录。在27.3节会看到这样的例子，从未知的IP地址使用匿名FTP访问服务器。</p>
<p>其他的一些服务器如Rlogin服务器（第26章）不但需要客户的IP地址来获得指针记录，还要向DNS询问该IP地址所对应的域名，并检查返回的地址中是否有地址与收到的数据报中的源IP地址匹配。该检查是因为.rhosts文件（见26.2节）中的条目仅包含主机名，而没有IP地址，因此主机需要证实该主机名是否对应源IP地址。</p>
<p>某些厂商将该项检查自动并入其名字解析器的例程中，特别是函数gethostbyaddr。这使得任何使用名字解析器的程序均可获得这种检查，而无需在应用中人为地进行这项检查。</p>
<p>来看一个使用SunOS 4.13名字解析器库的例子。我们编制了一个简单的程序通过调用函数gethostbyaddr来完成一个指针查询。我们已在文件/etc/resolv.conf中将名字服务器设置为noao.edu，sun主机通过SLIP链路与它相连。图14-13显示了当调用函数gethostbyaddr获取与IP地址140.252.1.29（sun主机）对应的名字时，tcpdump在SLIP链路上收到的内容。</p>
<p>第1行是预期的指针查询，第2行是预期的响应。但第3行显示了该名字解析器函数自动对第2行返回的名字发出一个IP地址查询。既然sun主机有两个IP地址，第4行的响应就包括两个回答记录。如果这两个地址中没有与gethostbyaddr输入参数匹配的地址，函数会向系统的日志发送一条报文，并向应用程序返回差错。</p>
<h2 id="14-6-资源记录"><a href="#14-6-资源记录" class="headerlink" title="14.6 资源记录"></a>14.6 资源记录</h2><p>IP地址查询为A类型，指针查询为类型PTR。此外还有</p>
<ul>
<li>CNAME：规范名字</li>
<li>HINFO：主机信息</li>
<li>MX：邮件交换记录</li>
<li>NS：名字服务器记录<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_x3.png"><br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/images2/52im_net_x4.png"></li>
</ul>
<h2 id="14-7-高速缓存"><a href="#14-7-高速缓存" class="headerlink" title="14.7 高速缓存"></a>14.7 高速缓存</h2><p>所有的名字服务器均使用高速缓存</p>
<p>使用host命令执行下列查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun % host ftp.uu.net</span><br><span class="line">ftp.uu.net    A    192.48.96.9</span><br></pre></td></tr></table></figure>
<p>这次在tcpdump中使用了新的选项。使用-w选项来收集进出UDP或TCP 53号端口的所有数据。将这些原始数据记录在一个文件中供以后处理，同时防止tcpdump试图调用名字解析器来显示与那个IP地址相对应的域名。执行查询后，终止tcpdump并使用-r选项再次运行它。它会读取含有原始数据的文件并产生正式的输出显示（如图1414）。这个过程要花费几秒钟，因为tcpdump调用了它自己的名字解析器。</p>
<p>相应的tcpdump输出中要注意的第一点是标识符(identifier)是小整数（2和3）。这是因为我们关闭这个名字服务器，后又重新启动它来强制清空它的高速缓存。当名字服务器启动时，它将标识符初始化为1。</p>
<p>当键入查询，查找主机ftp.uu.net的IP地址，该名字服务器就同8个根名字服务器中的一个ns.nic.ddn.mil（第1行）取得联系。这是以前见到的正常的A类型查询，但要注意的是它的期望递归表示没有说明（如果该标志被设置，在标识符2的后边会跟着一个加号）。在以前的例子中，经常看到名字解析器设置期望递归标志，但这里的名字服务器在与某个根服务器联系时没有设置这个标志。这是因为不应该向根名字服务器发出期望递归的查询，它们仅用来寻找其他授权名字服务器的地址。</p>
<p>第2行显示返回的响应中没有回答资源记录，而包含5个授权资源记录和5个附加信息资源记录。标识符2后的减号表示期望递归标志（RA）没有被设置。即使我们要求进行递归查询，这个根名字服务器也不会回答期望递归查询。</p>
<p>尽管tcpdump没有显示返回的10个资源记录，我们也能执行host命令来查看高速缓存的内容：</p>
<p>这次采用-v选项查看的不仅仅只是A记录。它显示出对于域uu.net有5个授权名字服务器，而由根名字服务器返回的5个附加信息资源记录中含有这5个名字服务器的IP地址。这避免了在查找其中的某个名字服务器的地址时，无需再次与根名字服务器联系。这是DNS中的另一个实现优化。</p>
<p>host命令指出这个回答不是授权的，这是因为这个回答来自名字服务器的高速缓存，而不是来自授权名字服务器。</p>
<h4 id="例子未理解"><a href="#例子未理解" class="headerlink" title="例子未理解"></a>例子未理解</h4><h2 id="14-8-用UDP还是用TCP"><a href="#14-8-用UDP还是用TCP" class="headerlink" title="14.8 用UDP还是用TCP"></a>14.8 用UDP还是用TCP</h2><p>TCP：主、辅服务器之间执行区域传送时，返回的响应超过512字节时</p>
<p>DNS主要使用UDP，必须自己处理超时和重传。</p>
<p>DNS查询和响应通常经过广域网。端口号都是53。</p>
<h2 id="14-9-另一个例子"><a href="#14-9-另一个例子" class="headerlink" title="14.9 另一个例子"></a>14.9 另一个例子</h2><p>让我们通过另一个例子将已经介绍的许多DNS特性作一个综合性回顾。先启动Rlogin客户程序，然后连接到一个位于其他域的Rlogin服务器。图14-16显示了发生的分组交换过程。下面发生的11个步骤都假定客户和服务器的高速缓存中没有任何信息。<br>1.客户程序启动后，调用它的名字解析器函数将我们键入的主机名转换为一个IP地址。一个A类型的查询请求被送往一个根服务器。<br>2.由根服务器返回的响应中包含为该服务器所在域服务的名字服务器名。<br>3.客户端的名字解析器将向该服务器的名字服务器重发上述A类型查询，这个查询通常是将期望递归标志设置为1。<br>4.返回的应答中包含Rlogin服务器的IP地址。<br>5.Rlogin客户和Rlogin服务器建立一个TCP连接（第18章将提供该步骤的细节）。客户和服务器的TCP模块间将交换3个分组。<br>Rlogin服务器收到来自客户的连接请求后，调用它的名字解析器通过TCP连接请求中的IP地址获得客户主机名。这是一个PTR查询请求，由一个根名字服务器处理。这个根名字服务器可以不同于步骤1中客户使用的根名字服务器。<br>7.这个根名字服务器的响应中含有为客户的in-addr.arpa域的名字服务器。<br>8.服务器上的名字解析器将向客户的名字服务器重传上述PTR查询。<br>9.返回的PTR应答中含有客户主机的FQDN。<br>10.服务器的名字解析器向客户的名字服务器发送一个A类型查询请求，查找前一步返回的名字对应的IP地址。这可能由服务器中的gethostbyaddr函数自动完成，正如我们在14.5节中介绍的那样，否则Rlogin服务器将完成这一步。此外，客户的名字服务器常常就是客户的in-addr.arpa名字服务器，但这不是必需的。<br>11.从客户的名字服务器返回的响应含有客户主机的A记录。Rlogin服务器将客户的TCP连接请求中的IP地址与A记录作比较。<br>高速缓存将减少这个图中交换的分组数目。</p>
<h2 id="14-10-小结"><a href="#14-10-小结" class="headerlink" title="14.10 小结"></a>14.10 小结</h2><p>名字解析器将向一个本地名字服务器发出查询请求，这个名字服务器可能通过某个根名字服务器或其他名字服务器来完成这个查询。</p>
<p>所有的DNS查询和响应都有相同的报文格式。通过许多例子能了解名字解析器的配置文件以及DNS的优化措施。</p>
<h2 id="ch14-习题"><a href="#ch14-习题" class="headerlink" title="ch14 习题"></a>ch14 习题</h2><ol>
<li>14.1讨论一个DNS名字解析器和一个DNS名字服务器作为客户程序、服务器或同时作为客户和服务器的情况。</li>
</ol>
<ul>
<li>答案是：一个解析器总是一个客户，但一个名字服务器既是一个客户又是一个服务器。</li>
</ul>
<ol>
<li>说明图14-12中构成响应的75个字节的含义。</li>
</ol>
<ul>
<li>答案是：问题被返回，它占用了前44个字节。一个回答占用了剩下来的31个字节：2个字节指向域名的指针（即，指向问题中域名的一个指针），10字节固定长度的字段（类型、种类、TTL和资源长度），19字节的资源数据（一个域名）。注意到资源数据中的域名（svr4.tuc.noao.edu.）没有共享问题（34.13.252.140.in-addr.arpa.）中域名的后缀，所以不能使用一个指针。</li>
</ul>
<ol>
<li>在12.3节我们指出，一个既可接受点分十进制形式的IP地址、也可接收主机名的应用程序，应先假定输入的是IP地址，如果失败，再假定是主机名。如果改变这个测试顺序会出现什么情况？</li>
</ol>
<ul>
<li>答案是：将顺序颠倒意味着首先使用DNS，如果使用DNS失败，然后才将参数翻转过来作为一个点分十进制数。这就是说每次说明一个点分十进制数，都要使用DNS，涉及一个名字服务器。这是对资源的一种浪费。</li>
</ul>
<ol>
<li>每个UDP数据报有一个相应的长度。一个接收UDP数据报的进程将被告知这个长度。当名字解析器使用TCP而不是UDP来处理查询请求时，由于TCP是没有任何记录标记的字节流，那么应用程序是如何知道有多少数据返回？注意在DNS的报文首部（图14-3）中没有任何长度字段（提示：查阅 RFC 1035）</li>
</ol>
<ul>
<li>答案是：RFC 1035的4.2.2节说明了在实际的DNS报文之前的两个字节长度的字段。</li>
</ul>
<ol>
<li>我们说一个名字服务器必须知道根名字服务器的IP地址，这一信息可通过匿名FTP获得。不幸的是当根名字服务器表发生变化时，并不是所有的系统管理员都会更新他们的DNS配置文件（根名字服务表的确会发生变化，尽管不是经常的）你认为DNS如何处理这个问题？</li>
</ol>
<ul>
<li>答案是：当一个名字服务器启动时，它一般从一个磁盘文件中读出一个根服务器列表（可能已经过时了）。然后尝试和这些根服务器中的一个联系，请求根域的名字服务器记录（一个NS的查询类型）。这个请求返回了当前最新的根服务器列表。启动磁盘文件中根服务器项中至少需要一个是有效的。</li>
</ul>
<ol>
<li>利用习题1.8指明的文件来确定谁应负责维护根名字服务器。名字服务器更新的频度是怎样的？</li>
</ol>
<ul>
<li>答案是：InterNIC的注册服务每一周更新三次根服务器。</li>
</ul>
<ol>
<li>维护一个名字服务器和一个无状态的名字解析器高速缓存的问题分别是什么？</li>
</ol>
<ul>
<li>答案是：就像应用是不定的一样，解析器也是不定的。如果系统配置成使用多个名字服务器，而且解析器是无状态的，那么解析器就不能记住不同的名字服务器的往返时间。这样定时太短的解析器将会超时，引起不必要的重传。</li>
</ul>
<ol>
<li>在图14-10的讨论中，我们指出名字服务器将对A类型记录进行排序以便在公共网中的地址先出现。谁对A类型记录进行这种排序，是名字服务器还是名字解析器?</li>
</ol>
<ul>
<li>答案是：对A记录的排序应该由解析器来执行，而不是名字服务器，因为解析器一般比服务器了解更多的客户的网络拓扑（更新版本的BIND提供了解析器对A记录排序的功能）。</li>
</ul>
<h1 id="ch15-TFTP：简单文件传送协议"><a href="#ch15-TFTP：简单文件传送协议" class="headerlink" title="ch15 TFTP：简单文件传送协议"></a>ch15 TFTP：简单文件传送协议</h1><h2 id="15-1-引言"><a href="#15-1-引言" class="headerlink" title="15.1 引言"></a>15.1 引言</h2><p>TFTP(Trivial File Transfer Protocol)即简单文件传送协议，最初打算用于引导无盘系统（通常是工作站或X终端）。<br>为了保持简单和短小，TFTP将使用UDP。TFTP的代码（和它所需要的UDP、IP和设备驱动程序）都能适合只读存储器。</p>
<h2 id="15-2-协议"><a href="#15-2-协议" class="headerlink" title="15.2 协议"></a>15.2 协议</h2><p>在开始工作时，TFTP的客户与服务器交换信息，客户发送一个读请求或写请求给服务器。在一个无盘系统进行系统引导的正常情况下，第一个请求是读请求（RRQ）。图15-1显示了5种TFTP报文格式（操作码为1和2的报文使用相同的格式）。</p>
<p>TFTP报文的头两个字节表示操作码。对于读请求和写请求（WRQ），文件名字段说明客户要读或写的位于服务器上的文件。这个文件字段以0字节作为结束（见图15-1）。模式字段是一个ASCII码串netascii或octet（可大小写任意组合），同样以0字节结束。netascii表示数据是以成行的ASCII码字符组成，以两个字节—回车字符后跟换行字符（称为CR/LF）作为行结束符。这两个行结束字符在这种格式和本地主机使用的行定界符之间进行转化。octet则将数据看作8bit一组的字节流而不作任何解释。</p>
<p>每个数据分组包含一个块编号字段，它以后要在确认分组中使用。以读一个文件作为例子，TFTP客户需要发送一个读请求说明要读的文件名和文件模式(mode)。如果这个文件能被这个客户读取，TFTP服务器就返回一个块编号为1的数据分组。TFTP客户又发送一个块编号为1的ACK。TFTP服务器随后发送块编号为2的数据。TFTP客户发回块编号为2的ACK。重复这个过程直到这个文件传送完。除了最后一个数据分组可含有不足512字节的数据，其他每个数据分组均含有512字节的数据。当TFTP客户收到一个不足512字节的数据分组，就知道它收到最后一个数据分组。</p>
<p>在写请求的情况下，TFTP客户发送WRQ指明文件名和模式。如果该文件能被该客户写，TFTP服务器就返回块编号为0的ACK包。该客户就将文件的头512字节以块编号为1发出。服务器则返回块编号为1的ACK。</p>
<p>这种类型的数据传输称为停止等待协议。它只用在一些简单的协议如TFTP中。在20.3节中将看到TCP提供了不同形式的确认，能提供更高的系统吞吐量。TFTP的优点在于实现的简单而不是高的系统吞吐量。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/15/images2/52im_net_1.png" alt="图15-1 5种TFTP报文格式"><br>最后一种TFTP报文类型是差错报文，它的操作码为5。它用于服务器不能处理读请求或写请求的情况。在文件传输过程中的读和写差错也会导致传送这种报文，接着停止传输。差错编号字段给出一个数字的差错码，跟着是一个ASCII表示的差错报文字段，可能包含额外的操作系统说明的信息。</p>
<p>既然TFTP使用不可靠的UDP，TFTP就必须处理分组丢失和分组重复。分组丢失可通过发送方的超时与重传机制解决（注意存在一种称为“魔术新手综合症(sorcerer’s apprentice syndrome)”的潜在问题，如果双方都超时与重传，就可能出现这个问题。12.2节 [Stevens 1990] 介绍了这个问题是如何发生的)。和许多UDP应用程序一样，TFTP报文中没有检验和，它假定任何数据差错都将被UDP的检验和检测到（参见11.3节）。</p>
<h2 id="15-3-一个例子"><a href="#15-3-一个例子" class="headerlink" title="15.3 一个例子"></a>15.3 一个例子</h2><p>让我们通过观察协议的工作情况来了解TFTP。在bsdi主机上运行TFTP客户程序，并从主机svr4读取一个文本文件：<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/15/images2/52im_net_2.png"><br>最先引起我们注意的是在Unix系统下接收的文件长度是914字节，而TFTP则传送了962个字节。使用wc程序我们看到文件共有48行，因此48个Unix的换行符被转化成48个CR/CF对，因为默认情况下TFTP使用netascii模式传送。</p>
<p>图15-2显示了发生的分组交换过程。</p>
<p>由于目的UDP端口是TFTP熟知端口（69），tcpdump将解释TFTP分组，并显示RRQ和文件名。而不是简单地输出<code>udp 字节数</code></p>
<p>TFTP协议需要客户进程向服务器进程的UDP熟知端口（69）发送第一个分组（RRQ或WRQ）。之后服务器进程便向服务器主机申请一个尚未使用的端口</p>
<p>服务器进程端口变化的原因是这个熟知端口要留出来供其他的TFTP客户进程发送它们的请求。</p>
<p>回顾图10-6，当RIP服务器向客户发送的数据超过512字节，两个UDP数据报都使用服务器的熟知端口。在那个例子中，即使服务器进程必须写多个数据报以便将所有数据发回，服务器进程也是先写一个，再写一个，它们都使用它的熟知端口。然而，TFTP协议与它不同，因为客户与服务器间的连接需要持续一个较长的时间（可能是数秒或数分钟）。如果一个服务器进程使用熟知端口来进行文件传输，那么在文件传输期间，它要么拒绝任何来自其他客户的请求，要么一个服务器进程在同一端口（69）同时对多个客户进程进行多个文件传输。</p>
<h2 id="15-4-安全性"><a href="#15-4-安全性" class="headerlink" title="15.4 安全性"></a>15.4 安全性</h2><p>注意在TFTP分组（图15-1）中并不提供用户名和口令。</p>
<h2 id="15-5-小结"><a href="#15-5-小结" class="headerlink" title="15.5 小结"></a>15.5 小结</h2><p>TFTP协议没有提供安全特性。大多数执行指望TFTP服务器的系统管理员来限制客户的访问，只允许它们访问引导所必须的文件。</p>
<h2 id="ch15-习题"><a href="#ch15-习题" class="headerlink" title="ch15 习题"></a>ch15 习题</h2><ol>
<li>阅读Host Requirements RFC，了解如果一个TFTP服务器收到的请求的目的IP地址是一个广播地址，它将做什么。</li>
</ol>
<ul>
<li>答案是：送往广播地址的TFTP请求应该被忽略。正像Host Requirements RFC所描述的，对一个广播请求的响应可能产生一个非常严重的安全漏洞。但是，问题是并不是所有的实现和API都对接收一个UDP数据报的进程提供了该数据报的目的地址（11.12节）。因为这个原因，很多TFTP服务器没有严格遵守这个限制。</li>
</ul>
<ol>
<li>当TFTP块号由65535跳回到0时，你认为会发生什么？RFC 1350提到了如何处理这一问题吗？</li>
</ol>
<ul>
<li>答案是：不幸的是，RFC没有提到这个块数目环绕问题。具体实现时应该能够传输最大为33 553 920（65535×512）字节的文件。但是当文件的长度超过16 776 704（32767×512）时，很多实现都会失败，因为它们将块数目错误地表示为一个有符号的16位整数，而不是一个无符号的整数。</li>
</ul>
<ol>
<li>TFTP发送方采用超时重发来处理分组丢失。当TFTP作为引导进程的一部分时，这种方法对TFTP的使用有何影响？</li>
</ol>
<ul>
<li>答案是：这样简化了编写一个适合于只读内存的TFTP客户的工作，因为服务器是引导文件的发送者，所以服务器必须实现超时和重传机制。</li>
</ul>
<ol>
<li>使用TFTP时，影响传输文件所需时间的限制性因素是什么？</li>
</ol>
<ul>
<li>答案是：利用它的停止等待协议，TFTP可以在每一次客户与服务器的往返过程中最多传输512字节的数据。TFTP的最大吞吐量就是512字节除以客户与服务器之间的往返时间。在以太网上，假设一个往返时间为3ms，那么最大的吞吐量就是大约170 000字节/秒。</li>
</ul>
<h1 id="ch16-BOOTP：引导程序协议"><a href="#ch16-BOOTP：引导程序协议" class="headerlink" title="ch16 BOOTP：引导程序协议"></a>ch16 BOOTP：引导程序协议</h1><h2 id="16-1-引言"><a href="#16-1-引言" class="headerlink" title="16.1 引言"></a>16.1 引言</h2><p>在第5章我们介绍了一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：</p>
<ul>
<li>IP地址是返回的唯一结果；</li>
<li>既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。<br>本章将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。</li>
</ul>
<p>BOOTP使用UDP，且通常需与TFTP（参见第15章）协同工作。</p>
<h2 id="16-2-BOOTP的分组格式"><a href="#16-2-BOOTP的分组格式" class="headerlink" title="16.2 BOOTP的分组格式"></a>16.2 BOOTP的分组格式</h2><p>图16-2显示了长度为300字节的BOOTP请求和应答的格式。</p>
<p>“操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答（图4-3）中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。</p>
<p>“跳数”字段由客户设置为0，但也能被一个代理服务器设置（参见16.5节）。</p>
<p>“事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。</p>
<p>客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。</p>
<p>如果该客户已经知道自身的IP地址，它将写入“客户IP地址”字段。否则，它将该字段设置为0。对于后面这种情况，服务器用该客户的IP地址写入“你的IP地址”字段。“服务器IP地址”字段则由服务器填写。如果使用了某个代理服务器（见16.5节），则该代理服务器就填写“网关IP地址”字段。</p>
<p>客户必须设置它的“客户硬件地址”字段。尽管这个值与以太网数据帧头中的值相同，UDP数据报中也设置这个字段，但任何接收这个数据报的用户进程能很容易地获得它（例如一个BOOTP服务器）。一个进程通过查看UDP数据报来确定以太网帧首部中的该字段通常是很困难的（或者说是不可能的）。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_2.png" alt="图16-2 BOOTP请求和应答的格式"><br>“服务器主机名”字段是一个空值终止串，由服务器填写。服务器还将在“引导文件名字段”填入包括用于系统引导的文件名及其所在位置的路径全名。</p>
<p>“特定厂商区域”字段用于对BOOTP进行不同的扩展。16.6节将介绍这些扩展中的一些。</p>
<p>当一个客户使用BOOTP（操作码为1）进行系统引导时，引导请求通常是采用链路层广播，IP首部中的目的IP地址为255.255.255.255（受限的广播，12.2节）。源IP地址通常是0.0.0.0，因为此时客户还不知道它本身的IP地址。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>BOOTP有两个熟知端口：BOOTP服务器为67，BOOTP客户为68。这意味着BOOTP客户不会选择未用的临时端口，而只用端口68。选择两个端口而不是仅选择一个端口为BOOTP服务器用的原因是：服务器的应答可以进行广播（但通常是不用广播的）。</p>
<p>如果服务器的应答是通过广播传送的，同时客户又选择未用的临时端口，那么这些广播也能被其他的主机中碰巧使用相同临时端口的应用进程接收到。因此，采用随机端口（即临时端口）对广播来说是一个不好的选择。</p>
<p>如果客户也使用服务器的知名端口（67）作为它的端口，那么网络内的所有服务器会被唤醒来查看每个广播应答（如果所有的服务器都被唤醒，它们将检查操作码，如果是一个应答而不是请求，就不作处理）。因此可以让所有的客户使用与服务器知名端口不同的同一知名端口。</p>
<p>如果多个客户同时进行系统引导，并且服务器广播所有应答，这样每个客户都会收到其他客户的应答。客户可以通过BOOTP首部中的事务标识字段来确认应答是否与请求匹配，或者可以通过检查返回的客户硬件地址加以区分。</p>
<h2 id="16-3-一个例子"><a href="#16-3-一个例子" class="headerlink" title="16.3 一个例子"></a>16.3 一个例子</h2><p>让我们看一个用BOOTP引导一个X终端的例子。图16-3显示了tcpdump的输出结果（例中客户名为proteus，服务器名为mercury。这个tcpdump的输出是在不同的网络上获得的，这个应用程序是其他例子中一直使用的）。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_3.png" alt="图16-3 用BOOTP引导一个X终端的例子"><br>在第1行中，我们看到客户请求来自0.0.0.0.68，发送目的站是255.255.255.255.67。该客户已经填写的字段是秒数和自身的以太网地址。我们看到客户通常将秒数设置为1 0 0。tcpdump没有显示跳数和事务标识，因为它们均为0(事务标识为0表示该客户忽略这个字段，因为如果打算对返回响应进行验证，它将把这个字段设置为一个随机数值)。</p>
<p>第2行是服务器返回的应答。由服务器填写的字段是该客户的IP地址（tcpdump显示为名字proteus）、服务器的IP地址（显示为名字mercury）、网关的IP地址（显示为名字mercury）和引导文件名。</p>
<p>在收到BOOTP应答后，该客户立即发送一个ARP请求来了解网络中其他主机是否有IP地址。跟在who-has后的名字proteus对应目的IP地址（图4-3），发送者的IP地址被设置为0.0.0.0。它在0.5秒后再发一个相同的ARP请求，之后再过0.5秒又发一个。在第3个ARP请求（第5行）中，它将发送者的IP地址改变为它自己的IP地址。这是一个没有意义的ARP请求（见4.7节）。</p>
<p>第6行显示该客户在等待另一个0.5秒后，广播另一个BOOTP请求。这个请求与第1行的唯一不同是此时客户将它的IP地址写入IP首部中。它收到来自同一个服务器的相同应答（第7行）。该客户在等待2秒后，又广播一个BOOTP请求（第8行），同样收到来自同一服务器的相同应答。</p>
<p>该客户等待2秒后，向它的服务器mercury发送一个ARP请求（第10行）。收到这个ARP应答后，它立即发送一个TFTP读请求，请求读取它的引导文件（第12行）。文件传送过程包括2464个TFTP数据分组和确认，传送的数据量为512×2463+224=1261 280字节。这将操作系统调入X终端。我们已在图16-3中删除了大多数TFTP行。</p>
<p>当和图15-2比较TFTP的数据交换过程时，要注意的是这儿的客户在整个传输过程中使用TFTP的知名端口（69）。既然通信双方中的一方使用了端口69，tcpdump就知道这些分组是TFTP报文，因此它能用TFTP协议来解释每个分组。这就是为什么图16-3能指明哪些包含有数据，哪些包含有确认，以及每个分组的块编号。在图15-2中我们并不能获得这些额外的信息，因为通信双方均没有使用TFTP的知名端口进行数据传送。由于TFTP服务器作为一个多用户系统，且使用TFTP的知名端口，因此通常TFTP客户不能使用那个端口。但这里的系统处于正被引导的过程中，无法提供一个TFTP服务器，因此允许该客户在传输期间使用TFTP的知名端口。这也暗示在mercury上的TFTP服务器并不关心客户的端口号是什么—它只将数据传送到客户的端口上，而不管发生了什么。</p>
<p>从图16-3可以看出在9秒内共传送了1261 280字节。<strong>数据速率大约为140 000 bps。这比大多数以FTP文件传送形式访问一个以太网要慢，但对于一个简单的停止等待协议如TFTP来说已经很好了。</strong></p>
<p>X终端系统引导后，还需使用TFTP传送终端的字体文件、某些DNS名字服务器查询，然后进行X协议的初始化。图16-3中的所有步骤大概需要15秒钟，其余的步骤需要6秒钟，这样无盘X终端系统引导的总时间是21秒。</p>
<h2 id="16-4-BOOTP服务器的设计"><a href="#16-4-BOOTP服务器的设计" class="headerlink" title="16.4 BOOTP服务器的设计"></a>16.4 BOOTP服务器的设计</h2><p>BOOTP客户通常固化在无盘系统只读存储器中，因此了解BOOTP服务器的实现将更有意义。</p>
<p>首先，BOOTP服务器将从它的熟知端口（67）读取UDP数据报。这没有特别的地方。它不同于RARP服务器（5.4节），它必须读取类型字段为“RARP请求”的以太网帧。BOOTP协议通过将客户的硬件地址放入BOOTP分组中，使得服务器很容易获取客户的硬件地址(图16-2)。</p>
<p>TFTP服务器如何能将一个响应直接送回BOOTP客户？有两种解决办法：</p>
<ul>
<li>为该客户在ARP高速缓存中设置一个条目</li>
<li>服务器广播这个BOOTP应答而不直接将应答发回该客户。</li>
</ul>
<h2 id="16-5-BOOTP穿越路由器"><a href="#16-5-BOOTP穿越路由器" class="headerlink" title="16.5 BOOTP穿越路由器"></a>16.5 BOOTP穿越路由器</h2><p>我们在5.4节中提到RARP的一个缺点就是它使用链路层广播，这种广播通常不会由路由器转发。这就需要在每个物理网络内设置一个RARP服务器。如果路由器支持BOOTP协议，那么BOOTP能够由路由器转发（绝大多数路由器厂商的产品都支持这个功能）。</p>
<p>这个功能主要用于无盘路由器，因为如果在磁盘的多用户系统被用作路由器，它就能够自己运行BOOTP服务器。此外，常用的Unix BOOTP服务器（附录F）支持这种中继模式（relay mode）。但如果在这个物理网络内运行一个BOOTP服务器，通常没有必要将BOOTP请求转发到在另外网络中的另一个服务器。</p>
<h2 id="16-6-特定厂商信息"><a href="#16-6-特定厂商信息" class="headerlink" title="16.6 特定厂商信息"></a>16.6 特定厂商信息</h2><p>在图16-2中我们看到了64字节的“特定厂商区域”。RFC 1533 [Alexander and Droms 1993]定义了这个区域的格式。这个区域含有服务器返回客户的可选信息。</p>
<p>如果有信息要提供，这个区域的前4个字节被设置为IP地址99.130.83.99。这可称作魔术甜饼(magic cookie)，表示该区域内包含信息。</p>
<p>这个区域的其余部分是一个条目表。每个条目的开始是1字节标志字段。其中的两个条目仅有标志字段：标志为0的条目作为填充字节（为使后面的条目有更好的字节边界），标志为255的条目表示结尾条目。第一个结尾条目后剩余的字节都应设置为这个数值（255）。</p>
<p>除了这两个1字节的条目，其他的条目还包含一个单字节的长度字段，后面是相应的信息。图16-4显示了厂商说明区域中一些条目的格式。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/16/images2/52im_net_4.png" alt="图16-4 厂商说明区域中一些条目的格式"><br>子网掩码条目和时间值条目都是定长条目，因为它们的值总是占4个字节。时间偏移值是从1900年1月1日0时以来的秒数（UTC）。</p>
<p>网关条目是变长条目。长度通常是4的倍数，这个值是一个或多个供客户使用的网关（路由器）的IP地址。返回的第一个必须是首选的网关。</p>
<p>RFC 1533还定义了其他14个条目。其中最重要的可能是DNS名字服务器的IP地址条目，条目的志为6。其他的条目包括打印服务器、时间服务器等的IP地址。详细情况可参考RFC文档。</p>
<p>回到在图16-3中的例子，我们从未看到客户广播一个ICMP地址掩码请求（6.3节）来获取它的子网掩码。尽管tcpdump不能显示出来，但我们可认为客户所在网络的子网掩码在返回的BOOTP应答的厂商说明区域内。</p>
<p>Host Requirements RFC文档推荐一个系统使用BOOTP来获悉它的子网掩码，而不是采用ICMP。</p>
<p>厂商说明区域的大小被限制为64字节。这对某些应用是个约束。一个新的称为动态主机配置协议DHCP（Dynamic Host Configuration Protocol）已经出现，但它不是替代BOOTP的。DHCP将这个区域的长度扩展到312字节，它在RFC 1541 [Droms 1993] 中定义。</p>
<h2 id="16-7-小结"><a href="#16-7-小结" class="headerlink" title="16.7 小结"></a>16.7 小结</h2><p>BOOTP使用UDP，它为引导无盘系统获得它的IP地址提供了除RARP外的另外一种选择。BOOTP还能返回其他的信息，如路由器的IP地址、客户的子网掩码和名字服务器的IP地址。</p>
<p>既然BOOTP用于系统引导过程，一个无盘系统需要下列协议才能在只读存储器中完成：BOOTP、TFTP、UDP、IP和一个局域网的驱动程序。</p>
<p>BOOTP服务器比RARP服务器更易于实现，因为BOOTP请求和应答是在UDP数据报中，而不是特殊的数据链路层帧。一个路由器还能作为真正BOOTP服务器的代理，向位于不同网络的真正BOOTP服务器转发客户的BOOTP请求。</p>
<h2 id="ch16-习题"><a href="#ch16-习题" class="headerlink" title="ch16 习题"></a>ch16 习题</h2><ol>
<li>我们说BOOTP优于RARP的一个方面是BOOTP能穿越路由器，而RARP由于使用链路层广播则不能。在16.5节为使BOOTP穿越路由器，我们必须定义特殊的方式。如果在路由器中增加允许转发RARP请求的功能会发生什么？</li>
</ol>
<ul>
<li>答案是：16.1一个路由器可以转发一个RARP请求到路由器连接的其他网络上的任何一台主机上。但是发送应答就成问题了，路由器还必须转发RARP应答。</li>
<li>BOOTP没有这个应答问题，因为应答的地址是路由器知道如何转发的一般IP地址。问题是RARP只使用了链路层地址，路由器一般不知道在其他的、没有连接在路由器的网络上主机的链路层地址。</li>
</ul>
<ol>
<li>我们说过，当有多个客户程序同时向一个服务器发出引导请求时，因为服务器要广播多个BOOTP应答，BOOTP客户就必须使用事务标识来使响应与请求相匹配。但在图16-3中，事务标识为0，表示这个客户不考虑事务标识。你认为这个客户将如何将这些响应与其请求匹配。</li>
</ol>
<ul>
<li>答案是：它可能使用了自己的硬件地址。该地址应该是唯一的，在请求报文中设置，在应答中返回。</li>
</ul>
<h1 id="ch17-TCP：传输控制协议"><a href="#ch17-TCP：传输控制协议" class="headerlink" title="ch17 TCP：传输控制协议"></a>ch17 TCP：传输控制协议</h1><h2 id="17-1-引言"><a href="#17-1-引言" class="headerlink" title="17.1 引言"></a>17.1 引言</h2><p>第18章描述如可建立和终止一个TCP连接，第19和第20章将了解正常的数据传输过程，包括交互使用（远程登录）和成块数据传送（文件传输）。第21张提供TCP超时及重传的技术细节，第22和第23张将介绍两种其他的定时器。最后，第24章概述TCP新的特性以及TCP的性能。</p>
<h2 id="17-2-TCP的服务"><a href="#17-2-TCP的服务" class="headerlink" title="17.2 TCP的服务"></a>17.2 TCP的服务</h2><p>TCP连接中仅有两方，不能广播和多播</p>
<p>除了可靠性，TCP还能提供流量控制</p>
<p>TCP对字节流的内容不作任何解释</p>
<h2 id="17-3-TCP的首部"><a href="#17-3-TCP的首部" class="headerlink" title="17.3 TCP的首部"></a>17.3 TCP的首部</h2><p>不计任选字段，TCP首部通常是20个字节，最多60字节。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/images2/52im_net_2.png" alt="图17-2 TCP包首部"><br>一个IP地址和一个端口号也称为一个 socket</p>
<p>源端和目的端的 socket 唯一地标识了一个TCP连接</p>
<p>序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个<strong>报文段</strong>中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达2^32－1后又从0开始。</p>
<p>当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号（将在下章详细介绍如何建立和终止连接，届时我们将看到FIN标志也要占用一个序号）。</p>
<p>既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志（下面介绍）为1时确认序号字段才有效。</p>
<p>发送ACK无需任何代价，因为32 bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置，ACK标志也总是被设置为1。</p>
<p>TCP为应用层提供全双工服务。数据能在两个方向上独立地进行传输。连接的每一段必须保持每个方向上的传输数据序号。</p>
<p>当前还无法对数据流中选定的部分进行确认或否认</p>
<p>6个标志比特在随后的章节有更详细的介绍<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/images2/52im_net_x1.png"><br>流量控制由每一端通过声明的窗口大小来提供。窗口大小起始于确认序号字段指明的值。</p>
<p>检验和覆盖了TCP首部和TCP数据，是一个强制性的字段。</p>
<p>最常见的可选字段是最长报文大小，又称为MSS</p>
<h2 id="17-4-小结"><a href="#17-4-小结" class="headerlink" title="17.4 小结"></a>17.4 小结</h2><p>TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。</p>
<h2 id="ch17-习题"><a href="#ch17-习题" class="headerlink" title="ch17 习题"></a>ch17 习题</h2><ol>
<li>我们已经介绍了以下几种分组格式：IP、ICMP、IGMP、UDP和TCP。每一种格式的首部中均包含一个检验和。对每种分组，说明检验和包括IP数据报中的哪些部分，以及该检验和是强制的还是可选的。</li>
</ol>
<ul>
<li>答案是：除了UDP的检验和，其他都是必需的。IP检验和只覆盖了IP首部，而其他字段都紧接着IP首部开始。</li>
</ul>
<ol>
<li>为什么我们已经讨论的所有Internet协议（IP,ICMP,IGMP,UDP,TCP）收到有检验和错的分组都仅作丢弃处理？</li>
</ol>
<ul>
<li>答案是：源IP地址、源端口号或者协议字段可能被破坏了。</li>
</ul>
<ol>
<li>TCP提供了一种字节流服务，而收发双方都不保持记录的边界。应用程序如何提供它们自己的记录标识？</li>
</ol>
<ul>
<li>答案是：很多Internet应用使用一个回车和换行来标记每个应用记录的结束。这是NVT ASCII采用的编码（26.4节）。另外一种技术是在每个记录之前加上一个记录的字节计数，DNS（习题14.4）和Sun RPC（29.2节）采用了这种技术。</li>
</ul>
<ol>
<li>为什么在TCP首部的开始便是源和目的的端口号？</li>
</ol>
<ul>
<li>答案是：就像我们在6.5节所看到的，一个ICMP差错报文必须至少返回引起差错的IP数据报中除了IP首部的前8个字节。当TCP收到一个ICMP差错报文时，它需要检查两个端口号以决定差错对应于哪个连接。因此，端口号必须包含在TCP首部的前8个字节里。</li>
</ul>
<ol>
<li>为什么TCP首部有一个首部长度字段而UDP首部（图11-2）中却没有？</li>
</ol>
<ul>
<li>答：UDP首部的长度是固定的。答案是：TCP首部的最后有一些选项，但UDP首部中没有选项。</li>
</ul>
<h1 id="ch18-TCP连接的建立与终止"><a href="#ch18-TCP连接的建立与终止" class="headerlink" title="ch18 TCP连接的建立与终止"></a>ch18 TCP连接的建立与终止</h1><h2 id="18-1-引言"><a href="#18-1-引言" class="headerlink" title="18.1 引言"></a>18.1 引言</h2><p>本章将详细讨论一个TCP连接是如何建立的以及通信结束后是如何终止的。</p>
<h2 id="18-2-连接的建立与终止"><a href="#18-2-连接的建立与终止" class="headerlink" title="18.2 连接的建立与终止"></a>18.2 连接的建立与终止</h2><p><code>telnet bsdi discard</code>与主机bsdi中的9端口建立discard服务</p>
<h3 id="18-2-1-tcpdump的输出"><a href="#18-2-1-tcpdump的输出" class="headerlink" title="18.2.1 tcpdump的输出"></a>18.2.1 tcpdump的输出</h3><p>TCP报文段在tcpdump上的输出格式为<code>源 &gt; 目的: 标志</code><br>这里的标志代表TCP首部中的6个标志比特中的4个。ACK和URG将作特殊显示</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">3字符缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">SYN</td>
<td>同步序号</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">FIN</td>
<td>发送方完成数据发送</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">RST</td>
<td>复位连接</td>
</tr>
<tr>
<td align="center">P</td>
<td align="center">PSH</td>
<td>尽快将数据送往接收进程</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center"></td>
<td>以上四个标志比特均置0</td>
</tr>
</tbody></table>
<p>上述4个标志比特中的多个可能同时出现在一个报文段中，但通常一次只能见到一个。</p>
<p>相应的tcpdump输出中</p>
<ul>
<li>win 4096    表示<strong>默认</strong>窗口大小</li>
<li>&lt;mss 1024&gt;    表示最大报文段长度</li>
<li>ack 1        表示确认序号与初始序号的相对偏移值为1</li>
<li>1415531521:1415531521(0)    表示分组序号和数据字节数</li>
<li>[tos 0x10]    这是IP数据报内的服务类型（TOS）字段（参见图3-2）。BSD/386中的Telnet客户进程将这个字段设置为最小时延。</li>
</ul>
<h3 id="18-2-2-时间系列"><a href="#18-2-2-时间系列" class="headerlink" title="18.2.2 时间系列"></a>18.2.2 时间系列</h3><h3 id="18-2-3-三次握手"><a href="#18-2-3-三次握手" class="headerlink" title="18.2.3 三次握手"></a>18.2.3 三次握手</h3><ol>
<li>客户发送SYN段指明打算连接到的端口、初始序号（ISN）</li>
<li>服务器发回包含服务器的ISN的SYN报文段作为应答。同时，将确认序号设置为客户的ISN+1以对客户的SYN报文段进行确认</li>
<li>客户必须将确认序号设置为服务器的ISN+1以对服务器的SYN报文段进行确认</li>
</ol>
<p>ISN可看作是一个32比特的计数器，每4ms加1。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它作错误的解释。</p>
<h3 id="18-2-4-四次挥手"><a href="#18-2-4-四次挥手" class="headerlink" title="18.2.4 四次挥手"></a>18.2.4 四次挥手</h3><p>正常关闭：当服务器收到FIN，它发回ACK，同时TCP服务器还向应用程序传送一个文件结束符。接着这个服务器程序就关闭它的连接，导致他的TCP段发送一个FIN，客户必须发回一个确认。</p>
<p>连接通常是由客户端发起的，一般由客户端决定何时终止连接。</p>
<h3 id="18-2-5-正常的tcpdump输出"><a href="#18-2-5-正常的tcpdump输出" class="headerlink" title="18.2.5 正常的tcpdump输出"></a>18.2.5 正常的tcpdump输出</h3><p>默认情况下tcpdump只在显示SYN报文段时显示完整的序号，而对其后的序号则显示它们与初始序号的相对偏移值</p>
<h2 id="18-3-连接建立的超时"><a href="#18-3-连接建立的超时" class="headerlink" title="18.3 连接建立的超时"></a>18.3 连接建立的超时</h2><p>首次超时间隔约6秒，第二次超时间隔非常接近24秒</p>
<p>这是因为BSD版的TCP软件采用一种500 ms的定时器。</p>
<h2 id="18-4-最大报文段长度"><a href="#18-4-最大报文段长度" class="headerlink" title="18.4 最大报文段长度"></a>18.4 最大报文段长度</h2><p>在有些书中，将它看作可“协商”选项。它并不是任何条件下都可协商。当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（MSS选项只能出现在SYN报文段中）。如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报)。</p>
<h4 id="例子已理解-10"><a href="#例子已理解-10" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>由于slip知道它外出接口的MTU长度为296，即使sun已经通告它的MSS为1460，但为避免将数据分段，它不会发送超过256字节数据的报文段。系统允许发送的数据长度小于另一端的MSS值。</p>
<h2 id="18-5-TCP的半关闭"><a href="#18-5-TCP的半关闭" class="headerlink" title="18.5 TCP的半关闭"></a>18.5 TCP的半关闭</h2><p>半关闭：一个TCP连接在收到一个FIN后仍能发送数据，但在实际应用中只有很少的TCP应用程序这样做。</p>
<h4 id="例子已理解-11"><a href="#例子已理解-11" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>sort程序只有读取到所有输入数据后才能产生输出。所有的原始数据通过TCP连接从rsh客户端传送到sort服务器进行排序。当输入（datafile）到达文件尾时，rsh客户端执行这个TCP连接的半关闭。</p>
<h2 id="18-6-TCP的状态变迁图"><a href="#18-6-TCP的状态变迁图" class="headerlink" title="18.6 TCP的状态变迁图"></a>18.6 TCP的状态变迁图</h2><p><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_14.png" alt="图18-12 TCP的状态变迁图"><br>在这个图中要注意的第一点是一个状态变迁的子集是“典型的”。我们用粗的实线箭头表示正常的客户端状态变迁，用粗的虚线箭头表示正常的服务器状态变迁。</p>
<h3 id="18-6-1-2MSL等待状态"><a href="#18-6-1-2MSL等待状态" class="headerlink" title="18.6.1 2MSL等待状态"></a>18.6.1 2MSL等待状态</h3><p>TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。它是任何报文段被丢弃前在网络内的最长时间。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>大多数TCP实现在2MSL等待期间不能使用本地端口，任何迟到的报文段将被丢弃</p>
<p>客户执行主动关闭并进入TIME_WAIT是正常的。服务器通常执行被动关闭，不会进入TIME_WAIT状态。如果终止一个已经建立连接的服务器程序，并立即重新启动这个服务器程序，将不能把它的这个熟知端口赋值给它的端点，要等1~4分钟。</p>
<p>可以通过sock程序看到这一切。我们启动服务器程序，从一个客户程序进行连接，然后停止这个服务器程序。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_17.png"><br>当重新启动服务器程序时，程序报告一个差错信息说明不能绑定它的熟知端口，因为该端口已被使用（即它处于2MSL等待）。</p>
<p>运行netstat程序来查看连接的状态，以证实它的确处于2MSL等待状态。</p>
<p>尽管许多具体的实现中允许一个进程重新使用仍处于2MSL等待的端口（通常是设置选项SO_REUSEADDR），但TCP不能允许一个新的连接建立在相同的插口对上。可通过下面的试验来看到这一点：</p>
<h4 id="例子已理解-12"><a href="#例子已理解-12" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>大多数伯克利半实现允许一个新的连接请求到达仍处于TIME_WAIT状态的连接，只要新的序号大于该链接前一个替身的最后序号。这违反了TCP规范</p>
<h3 id="18-6-2-平静时间的概念"><a href="#18-6-2-平静时间的概念" class="headerlink" title="18.6.2 平静时间的概念"></a>18.6.2 平静时间的概念</h3><p>对于来自某个连接的较早替身的迟到报文段，2MSL等待可防止将它解释成使用相同插口对的新连接的一部分。但这只有在处于2MSL等待连接中的主机处于正常工作状态时才有效。</p>
<p>如果使用处于2MSL等待端口的主机出现故障，它会在MSL秒内重新启动，并立即使用故障前仍处于2MSL的插口对来建立一个新的连接吗？如果是这样，在故障前从这个连接发出而迟到的报文段会被错误地当作属于重启后新连接的报文段。无论如何选择重启后新连接的初始序号，都会发生这种情况。</p>
<p>为了防止这种情况，RFC 793指出TCP在重启动后的MSL秒内不能建立任何连接。这就称为平静时间(quiet time)。</p>
<p>只有极少的实现版遵守这一原则，因为大多数主机重启动的时间都比MSL秒要长。</p>
<h3 id="18-6-3-FIN-WAIT-2状态"><a href="#18-6-3-FIN-WAIT-2状态" class="headerlink" title="18.6.3 FIN_WAIT_2状态"></a>18.6.3 FIN_WAIT_2状态</h3><p>在FIN_WAIT_2状态我们已经发出了FIN，并且另一端也已对它进行确认。除非我们在实行半关闭，否则将等待另一端的应用层意识到它已收到一个文件结束符说明，并向我们发一个FIN来关闭另一方向的连接。只有当另一端的进程完成这个关闭，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。</p>
<p>这意味着我们这端可能永远保持这个状态。另一端也将处于CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭。</p>
<h2 id="18-7-复位报文段（RTS）"><a href="#18-7-复位报文段（RTS）" class="headerlink" title="18.7 复位报文段（RTS）"></a>18.7 复位报文段（RTS）</h2><p>发往基准的连接出现错误就会发出复位报文段</p>
<h3 id="18-7-1-到不存在的端口的连接请求"><a href="#18-7-1-到不存在的端口的连接请求" class="headerlink" title="18.7.1 到不存在的端口的连接请求"></a>18.7.1 到不存在的端口的连接请求</h3><p>产生复位的一种常见情况是目的端口没有进程正在听。对于UDP，将产生ICMP端口不可达的信息；而TCP则使用复位。</p>
<h4 id="例子已理解-13"><a href="#例子已理解-13" class="headerlink" title="例子已理解"></a>例子已理解</h4><h3 id="18-7-2-异常终止一个连接"><a href="#18-7-2-异常终止一个连接" class="headerlink" title="18.7.2 异常终止一个连接"></a>18.7.2 异常终止一个连接</h3><p>异常释放：不用FIN来释放连接，而是发送复位报文段。</p>
<p>RTS报文段不会导致另一端产生任何响应，不进行确认，直接通知应用层连接复位</p>
<p>异常终止一个连接对应用程序来说有两个优点：（1）丢弃任何待发数据并立即发送复位报文段；（2）RST的接收方会区分另一端执行的是异常关闭还是正常关闭。应用程序使用的API必须提供产生异常关闭而不是正常关闭的手段。</p>
<h4 id="例子已理解-14"><a href="#例子已理解-14" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>使用sock程序能够观察这种异常关闭的过程。Socket API通过“linger on close”选项（SO_LINGER）提供了这种异常关闭的能力。我们加上-L选项并将停留时间设为0。这将导致连接关闭时进行复位而不是正常的FIN。</p>
<h3 id="18-7-3-检测半打开连接"><a href="#18-7-3-检测半打开连接" class="headerlink" title="18.7.3 检测半打开连接"></a>18.7.3 检测半打开连接</h3><p>半打开连接：一方已经关闭或异常终止连接而另一方却还不知道。注意<strong>区分半打开连接与半关闭连接</strong></p>
<p>PC断电时，服务器将永远不知道客户程序已经消失了。</p>
<h4 id="例子已理解-15"><a href="#例子已理解-15" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="18-8-同时打开"><a href="#18-8-同时打开" class="headerlink" title="18.8 同时打开"></a>18.8 同时打开</h2><p>两个应用程序同事彼此执行主动打开的情况是可能的，尽管发生的可能性极小。每一方必须发送一个SYN，且这些SYN必须传递给对方。这需要每一方使用一个对方熟知的端口作为本地端口。这又称为同时打开（simultaneous open）。</p>
<p>这与下面的情况不同：主机A中的Telnet客户程序和主机B中Telnet的服务器程序建立连接，与此同时，主机B中的Telnet客户程序与主机A的Telnet服务器程序也建立连接。在这个Telnet例子中，两个Telnet服务器都执行被动打开，而不是主动打开，并且Telnet客户选择的本地端口不是另一端Te lnet服务器进程所熟悉的端口。</p>
<p>TCP对于同时打开，仅建立一条连接而不是两条连接</p>
<p>图18-17显示了这些状态变迁过程。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>尽管很难，但仍有可能产生一个同时打开的连接。两端必须几乎在同时启动，以便收到彼此的SYN。只要两端有较长的往返时间就能保证这一点。</p>
<p>带-v标志的sock程序来验证连接两端的IP地址和端口号。这个选项也显示每一端的MSS值。</p>
<h4 id="例子已理解-16"><a href="#例子已理解-16" class="headerlink" title="例子已理解"></a>例子已理解</h4><h2 id="18-9-同时关闭"><a href="#18-9-同时关闭" class="headerlink" title="18.9 同时关闭"></a>18.9 同时关闭</h2><p>图18-19总结了这些状态的变化。</p>
<p>同时关闭与正常关闭使用的段交换数目相同</p>
<h2 id="18-10-TCP选项"><a href="#18-10-TCP选项" class="headerlink" title="18.10 TCP选项"></a>18.10 TCP选项</h2><p>TCP首部可以包含选项部分。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_32.png" alt="图18-20 TCP选项"><br>每个选项的开始是1字节kind字段，说明选项的类型。kind字段为0和1的选项仅占1个字节。其他的选项在kind字节后还有len字节。它说明的长度是指总长度，包括kind字节和len字节。</p>
<p>设置无操作选项的原因在于允许发方填充字段为4字节的倍数。如果我们使用4.4BSD系统进行初始化TCP连接，tcpdump将在初始的SYN上显示下面TCP选项：<code>&lt;mss 512, nop, wscale 0, nop, nop, timestamp 146647 0&gt;</code></p>
<p>MSS选项设置为512，后面是NOP，接着是窗口扩大选项。第一个NOP用来将窗口扩大选项填充为4字节的边界。同样，10字节的时间戳选项放在两个NOP后，占12字节，同时使两个4字节的时间戳满足4字节边界。</p>
<p>其他kind值为4、5、6和7的四个选项称为选择ACK及回显选项。由于回显选项已被时间戳选项取代，而目前定义的选择ACK选项仍未定论，并未包括在RFC 1323中，因此图18-20没有将它们列出。另外，作为TCP事务（第24.7节）的T/TCP建议也指明kind为11,12和13的三个选项。</p>
<h2 id="TCP服务器的设计"><a href="#TCP服务器的设计" class="headerlink" title="TCP服务器的设计"></a>TCP服务器的设计</h2><p>大多数TCP服务器进程是并发的。</p>
<p>问题：如何处理端口？多个请求同时到达会怎样？</p>
<h3 id="18-11-1-TCP服务器端口号"><a href="#18-11-1-TCP服务器端口号" class="headerlink" title="18.11.1 TCP服务器端口号"></a>18.11.1 TCP服务器端口号</h3><p>使用netstat命令来观察Telnet服务器<br>-a标志将显示网络中的所有主机端，而不仅仅是处于ESTABLISHED的主机端。-n标志将以点分十进制的形式显示IP地址，而不是通过DNS将地址转化为主机名，同时还要求显示端口号（例如为23）而不是服务名称（如Te lnet）。-f inet选项则仅要求显示使用TCP或UDP的主机。</p>
<p>显示的本地地址为*.23，星号通常又称为通配符。这表示传入的连接请求（即SYN）将被任何一个本地接口所接收。如果该主机是多接口主机，我们将制定其中的一个IP地址为本地IP地址，并且只接收来自这个接口的连接</p>
<p>远端地址显示为*.*，表示还不知道远端IP地址和端口号，因为该端还处于LISTEN状态，正等待连接请求的到达。</p>
<p>现在我们在主机slip（140.252.13.65）启动一个Telnet客户程序来连接这个Telnet服务器。以下是netstat程序的输出行：<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_34.png"><br>端口为23的第1行表示处于ESTABLISHED状态的连接。另外还显示了这个连接的本地IP地址、本地端口号、远端IP地址和远端端口号。本地IP地址为该连接请求到达的接口（以太网接口，140.252.13.33）。</p>
<p>处于LISTEN状态的服务器进程仍然存在。这个服务器进程是当前Te lnet服务器用于接收其他的连接请求。当传入的连接请求到达并被接收时，系统内核中的TCP模块就创建一个处于ESTABLISHED状态的进程。另外，注意处于ESTABLISHED状态的连接的端口不会变化：也是23，与处于LISTEN状态的进程相同。<br>这个例子再次重申TCP使用由本地地址和远端地址组成的4元组：目的IP地址、目的端口号、源IP地址和源端口号来处理传入的多个连接请求。TCP仅通过目的端口号无法确定那个进程接收了一个连接请求。另外，在三个使用端口23的进程中，只有处于LISTEN的进程能够接收新的连接请求。处于ESTABLISHED的进程将不能接收SYN报文段，而处于LISTEN的进程将不能接收数据报文段。</p>
<h3 id="18-11-2-限定的本地IP地址"><a href="#18-11-2-限定的本地IP地址" class="headerlink" title="18.11.2 限定的本地IP地址"></a>18.11.2 限定的本地IP地址</h3><p>我们来看看当服务器不能任选其本地IP地址而必须使用特定的IP地址时的情况。如果我们为sock程序指明一个IP地址（或主机名），并将它作为服务器，那么该IP地址就成为处于LISTEN服务器的本地IP地址。例如<code>sun % sock -s 140.252.1.29 8888</code></p>
<p>使这个服务器程序的连接仅局限于来自SLIP接口（140.252.1.29）。</p>
<p>如果我们试图从以太网（140.252.13）中的主机与这个服务器进行连接，连接请求将被TCP模块拒绝。如果使用tcpdump来观察这一切，对连接请求SYN的响应是一个如图18-21所示的RST。</p>
<h3 id="18-11-3-限定的远端IP地址"><a href="#18-11-3-限定的远端IP地址" class="headerlink" title="18.11.3 限定的远端IP地址"></a>18.11.3 限定的远端IP地址</h3><p>在11.12节，我们知道UDP服务器通常在指定IP本地地址和本地端口外，还能指定远端IP地址和远端端口。RFC 793中显示的接口函数允许一个服务器在执行被动打开时，可指明远端插口（等待一个特定的客户执行主动打开），也可不指明远端插口（等待任何客户）。</p>
<p>遗憾的是，大多数API都不支持这么做。服务器必须不指明远端插口，而等待连接请求的到来，然后检查客户端的IP地址和端口号。</p>
<p>图18-22总结了TCP服务器进行连接时三种类型的地址绑定。在三种情况中，lport是服务器的熟知端口，而localIP必须是一个本地接口的IP地址。表中行的顺序正是TCP模块在收到一个连接请求时确定本地地址的顺序。最常使用的绑定（第1行，如果支持的话）将最先尝试，最不常用的（最后一行两端的IP地址都没有制定）将最后尝试。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_40.png" alt="图18-22 TCP服务器本地和远端IP地址及端口号的规范"></p>
<h3 id="18-11-4-呼入连接请求队列"><a href="#18-11-4-呼入连接请求队列" class="headerlink" title="18.11.4 呼入连接请求队列"></a>18.11.4 呼入连接请求队列</h3><ul>
<li>该队列中的连接已通过三次握手，但还没有被应用层所接受</li>
<li>大多数应用程序都把该队列的最大长度（积压值）说明为5</li>
<li>积压值说明的是TCP监听的端点已被TCP接受而等待应用层接受的最大连接数。这个积压值对系统所允许的最大连接数，或者并发服务器所能并发处理的客户数，并无影响。</li>
<li>如果对于新的连接请求，该TCP监听的端点的连接队列中还有空间（基于图18-23），TCP模块将对SYN进行确认并完成连接的建立。但应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接</li>
<li>如果对于新的连接请求，连接队列中已没有空间，TCP将不理会收到的SYN。也不发回任何报文段（即不发回RST）。如果应用层不能及时接受已被TCP接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。</li>
</ul>
<p>通过sock程序能了解这种情况。我们调用它，并使用新的选项（-O）。让它在创建一个新的服务器进程后而没有接受任何连接请求之前暂停下来。如果在它暂停期间又调用了多个客户进程，它将导致接受连接队列被填满，通过tcpdump能够看到这一切。<code>bsdi % sock -s -v -q1 -O30 5555</code></p>
<h4 id="例子已理解-17"><a href="#例子已理解-17" class="headerlink" title="例子已理解"></a>例子已理解</h4><p>-q1选项将服务器端的积压值置1。</p>
<h2 id="18-12-小结"><a href="#18-12-小结" class="headerlink" title="18.12 小结"></a>18.12 小结</h2><p>无论何时关闭一个连接，一端必须保持这个连接，我们看到TIME_WAIT状态将处理这个问题。处理的原则是执行主动打开的一端在进入这个状态时要保持的时间为TCP实现中规定的MSL值的两倍。</p>
<h2 id="ch18-习题"><a href="#ch18-习题" class="headerlink" title="ch18 习题"></a>ch18 习题</h2><p>在18.2节我们说初始序号（ISN）正常情况下由1开始，并且每0.5秒增加64000，每次执行一个主动打开。这意味着ISN的最低三位通常总是001。但在图18-3中，两个方向上ISN中的最低三位都是521。究竟是怎么回事?<br>在图18-15中，我们键入12个字符，看到TCP发送了13个字节。在图18-16中我们键入8个字符，但TCP发送了10个字符。为什么在第1种情况下增加1个字节，而在第2种情况下增加2个字节？<br>半打开连接和半关闭连接的区别是什么？<br>如果启动sock程序作为一个服务器程序，然后终止它（还没有客户进程与它相连接），我们能立即重新启动这个服务器程序。这意味着它没有经历2MSL等待状态。用状态变迁来解释这一切。<br>在18.6节我们知道一个客户进程不能重新使用同一个本地端口，如果该端口是仍处于2MSL等待连接的一部分。但如果sock程序作为客户程序连续运行两次，并且连接到daytime服务器上，我们就能重新使用同一本地端口。另外，对一个仍处于2MSL等待的连接，也能为它创建一个替身。这将如何做？<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_43.png"><br>在18.6节的最后，我们介绍了FIN_WAIT_2状态，提到如果应用程序仅过11分钟后实行完全关闭（不是半关闭），许多具体的实现都将一个连接由这个状态转移到CLOSED状态。如果另一端（处于CLOSE_WAIT状态）在宣布关闭（即发送FIN）之前等待了12分钟，这一端的TCP将如何响应这个FIN？<br>对于一个电话交谈，哪一方是主动打开，哪一方是被动打开？是否允许同时打开？是否允许同时关闭？<br>在图18-6中，我们没有见到一个ARP请求或一个ARP应答。显然主机svr4的硬件地址一定在bsdi的ARP高速缓存中。如果这个ARP高速缓存不存在，这个图会有什么变化？<br>解释如下的tcpdump输出，并和图18-13进行比较。<br><img src="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/images2/52im_net_44.png"><br>为什么图18-4中的服务器不将对客户FIN的ACK与自己的FIN合并，从而将报文段数减少为3个？<br>在图18-16中，RST的序号为什么是26368002？<br>TCP向链路层查询MTU是否违反分层的规则？<br>假定在图14.16中，每个DNS使用TCP而不是UDP进行查询，试问需要交换多少个报文段？<br>假定MSL为120秒，试问系统能够初始化一个新连接然后进行主动关闭的最大速率是多少？<br>阅读RFC 793，分析处于TIME_WAIT状态的主机收到使其进入此状态的重复的FIN时所发生的情况。<br>阅读RFC793，分析处于TIME_WAIT状态的主机收到一个RST时所发生的情况。<br>阅读Host Requirements RFC并找出半双工TCP关闭的定义。<br>在图1-8中，我们曾提到到来的TCP报文段可根据其目的端口号进行分用，请问这种说法是否正确？</p>
<h1 id="ch19-TCP的交互数据流"><a href="#ch19-TCP的交互数据流" class="headerlink" title="ch19 TCP的交互数据流"></a>ch19 TCP的交互数据流</h1><h2 id="19-1-引言"><a href="#19-1-引言" class="headerlink" title="19.1 引言"></a>19.1 引言</h2><ul>
<li>成块数据：如FTP、电子邮件和Usenet新闻</li>
<li>交互数据：如Telnet和Rlogin，它们俩的分组中约90%的分组数据小于10字节</li>
</ul>
<h2 id="19-2-交互式输入"><a href="#19-2-交互式输入" class="headerlink" title="19.2 交互式输入"></a>19.2 交互式输入</h2><p>在Rlogin上键入交互命令时，通常每个按键都会产生一个数据分组，而不是每行。</p>
<p>4个报文段（我们一般可以将2和3合并）</p>
<ol>
<li>来自客户的交换件</li>
<li>来自服务器的按键确认</li>
<li>来自服务器的按键回显</li>
<li>来自客户的按键回显确认</li>
</ol>
<p>Telnet有一个选项允许客户发送一行到服务器</p>
<h2 id="19-3-经受时延的确认"><a href="#19-3-经受时延的确认" class="headerlink" title="19.3 经受时延的确认"></a>19.3 经受时延的确认</h2><p>数据捎带ACK：通常TCP在接收到数据时并不立即发送ACK，以便将ACK与需要沿该方向发送的数据一起发送。绝大多数实现采用的时延为200ms</p>
<h2 id="19-4-Nagle算法"><a href="#19-4-Nagle算法" class="headerlink" title="19.4 Nagle算法"></a>19.4 Nagle算法</h2><p>在广域网上，小分组会增加拥塞出现的可能</p>
<p>Nagle算法要求一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。</p>
<p>在以太网上一个字节被发送、确认和回显的平均往返时间约为16ms。为了产生比这个速度更快的数据，我们每秒键入的字符必须多于60个。这表明局域网下很少使用这个算法。</p>
<h3 id="19-4-1-关闭Nagle算法"><a href="#19-4-1-关闭Nagle算法" class="headerlink" title="19.4.1 关闭Nagle算法"></a>19.4.1 关闭Nagle算法</h3><p>X窗口系统服务器中的鼠标移动必须无时延地发送。<br>插口API用户可以使用TCP_NODELAY选项来关闭Nagle算法</p>
<h2 id="19-5-窗口大小通告"><a href="#19-5-窗口大小通告" class="headerlink" title="19.5 窗口大小通告"></a>19.5 窗口大小通告</h2><h1 id="ch20-TCP的成块数据流"><a href="#ch20-TCP的成块数据流" class="headerlink" title="ch20 TCP的成块数据流"></a>ch20 TCP的成块数据流</h1><h2 id="20-1-引言"><a href="#20-1-引言" class="headerlink" title="20.1 引言"></a>20.1 引言</h2><p>滑动窗口协议：允许发送方在停止并等待确认前可以连续发送多个分组。<br>本章还介绍PUSH标志、慢启动和吞吐量</p>
<h2 id="20-2-正常数据流"><a href="#20-2-正常数据流" class="headerlink" title="20.2 正常数据流"></a>20.2 正常数据流</h2><h2 id="20-3-滑动窗口"><a href="#20-3-滑动窗口" class="headerlink" title="20.3 滑动窗口"></a>20.3 滑动窗口</h2><p>图20-4用可视化的方法显示了我们<strong>在前一节</strong>观察到的滑动窗口协议</p>
<h2 id="20-4-窗口大小"><a href="#20-4-窗口大小" class="headerlink" title="20.4 窗口大小"></a>20.4 窗口大小</h2><p>下面我们可以看到更多的滑动窗口协议动态变化的例子</p>
<h2 id="20-5-PUSH标志"><a href="#20-5-PUSH标志" class="headerlink" title="20.5 PUSH标志"></a>20.5 PUSH标志</h2><p>发送方使用PUSH标志通知接收方将所收到的数据全部提交给接收进程。</p>
<p>目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法。的确，许多实现程序认为PUSH标志已经过时，一个好的TCP实现能够自行决定何时设置这个标志。</p>
<h2 id="20-6-慢启动"><a href="#20-6-慢启动" class="headerlink" title="20.6 慢启动"></a>20.6 慢启动</h2><p>慢启动算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。</p>
<p>慢启动为发送方的TCP增加了另一个窗口：拥塞窗口，记为cwnd。当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（<strong>即另一端通告的报文段大小</strong>）。每收到一个ACK，拥塞窗口就增加一个报文段。发送方取拥塞窗口与通告窗口中的最小值作为发送上限。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</p>
<p>拥塞避免<a href="#21-6-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95">CF:21.6节</a></p>
<h2 id="20-7-成块数据吞吐量"><a href="#20-7-成块数据吞吐量" class="headerlink" title="20.7 成块数据吞吐量"></a>20.7 成块数据吞吐量</h2><h3 id="20-7-2-拥塞"><a href="#20-7-2-拥塞" class="headerlink" title="20.7.2 拥塞"></a>20.7.2 拥塞</h3><p>当数据到达一个大的管道并向一个较小的管道发送时便会发生拥塞。</p>
<h2 id="20-8-紧急方式"><a href="#20-8-紧急方式" class="headerlink" title="20.8 紧急方式"></a>20.8 紧急方式</h2><p>通知紧急数据：把TCP首部中的URG比特置1，并把16bit的紧急指针置为一个正的偏移量。</p>
<p>紧急方式有什么用呢？两个最常见的例子是Telnet和Rlogin中当交互用户键入中断键时；另一个例子是FTP用户放弃一个文件的传输时。</p>
<p>如果在接收方处理第一个紧急指针之前，发送方多次进入紧急方式会发生什么情况？接收方只有一个紧急指针，每当对方有新的值到达时它将被覆盖。</p>
<h2 id="20-9-小结"><a href="#20-9-小结" class="headerlink" title="20.9 小结"></a>20.9 小结</h2><p>应用程序使用的有关紧急数据部分的编程接口常常都不是最佳的，从而导致更多的混乱。</p>
<h1 id="ch21-TCP的超时与重传"><a href="#ch21-TCP的超时与重传" class="headerlink" title="ch21 TCP的超时与重传"></a>ch21 TCP的超时与重传</h1><h2 id="21-1-引言"><a href="#21-1-引言" class="headerlink" title="21.1 引言"></a>21.1 引言</h2><p>对每个连接，TCP管理4个不同的定时器</p>
<ol>
<li>重传定时器</li>
<li>坚持定时器</li>
<li>保活定时器</li>
<li>2MSL定时器</li>
</ol>
<h2 id="21-2-超时与重传的简单例子"><a href="#21-2-超时与重传的简单例子" class="headerlink" title="21.2 超时与重传的简单例子"></a>21.2 超时与重传的简单例子</h2><p>拔掉电缆后检查连续重传之间不同的时间差，它们取整后分别为1、3、6、12、24、48和多个64秒。设置的超时时间实际上为1.5秒，此后该时间在每次重传时增加一倍并直至64秒。</p>
<p>这个倍乘关系被称为“指数退避(exponential backoff)”。而6.5节中的TFTP的重传间隔总是5秒。</p>
<p>首次分组传输与复位信号传输之间的时间差约为9分钟，该时间在目前的TCP实现中是不可变的。</p>
<h2 id="21-3-往返时间测量"><a href="#21-3-往返时间测量" class="headerlink" title="21.3 往返时间测量"></a>21.3 往返时间测量</h2><p>TCP超时与重传中最重要的部分就是对一个给定连接的往返时间(RTT)的测量。由于路由器和网络流量均会变化，RTT可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。</p>
<p>首先TCP必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT。<br>每次进行新测量的时候，被平滑的RTT估计器将得到更新。</p>
<h3 id="Karn算法"><a href="#Karn算法" class="headerlink" title="Karn算法"></a>Karn算法</h3><p>重传多义性问题：重传后才收到的ACK是针对哪个分组的呢？</p>
<p>Karn规定，当一个超时和重传发生时，不能更新RTT估计器，因为我们并不知道ACK对应哪次传输</p>
<h2 id="21-4-往返时间RTT的例子"><a href="#21-4-往返时间RTT的例子" class="headerlink" title="21.4 往返时间RTT的例子"></a>21.4 往返时间RTT的例子</h2><h2 id="21-5-拥塞举例"><a href="#21-5-拥塞举例" class="headerlink" title="21.5 拥塞举例"></a>21.5 拥塞举例</h2><h2 id="21-6-拥塞避免算法"><a href="#21-6-拥塞避免算法" class="headerlink" title="21.6 拥塞避免算法"></a>21.6 拥塞避免算法</h2><p>该算法假定由于分组受到损坏引起的丢失是非常少的（远小于1%），因此分组丢失就意味着在源主机和目的主机之间的某处网络发生了拥塞。有两种分组丢失的指示：</p>
<ol>
<li>发生超时</li>
<li>接收到重复的确认</li>
</ol>
<p>拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来做到这一点。在实际中这两个算法通常一起实现。</p>
<p>算法需要对每个连接维持两个变量</p>
<ul>
<li>cwnd：拥塞窗口</li>
<li>ssthresh：慢启动门限</li>
</ul>
<p>算法实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cwnd &lt;- 1</span><br><span class="line">ssthresh &lt;- 65535</span><br><span class="line"></span><br><span class="line">TCP输出例程的输出不能超过min(cwnd, 接收方win)</span><br><span class="line"></span><br><span class="line">if(拥塞发生)</span><br><span class="line">	ssthresh &lt;- max( 2 , half( min(cwnd, 接收方win) ) )</span><br><span class="line">	if(是超时引起了拥塞)</span><br><span class="line">		cwnd &lt;- 1	&#x2F;&#x2F;慢启动</span><br><span class="line"></span><br><span class="line">when(新的数据被对方确认)	&#x2F;&#x2F;增加cwnd</span><br><span class="line">	if( cwnd &lt;&#x3D; ssthresh )</span><br><span class="line">		cwnd +&#x3D; 1个报文段大小	&#x2F;&#x2F;指数增加</span><br><span class="line">	else</span><br><span class="line">		cwnd +&#x3D; 1&#x2F;cwnd	&#x2F;&#x2F;加性增长；</span><br></pre></td></tr></table></figure>
<p><a href="#21-8-%E6%8B%A5%E5%A1%9E%E4%B8%BE%E4%BE%8B%EF%BC%88%E7%BB%AD%EF%BC%89">CF：21.8节</a></p>
<h2 id="21-7-快速重传与快速恢复算法"><a href="#21-7-快速重传与快速恢复算法" class="headerlink" title="21.7 快速重传与快速恢复算法"></a>21.7 快速重传与快速恢复算法</h2><p>当收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）。这个重复的ACK不应该被迟延。</p>
<p>由于我们不知道一个重复的ACK是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来。</p>
<ol>
<li>重新排序：只可能产生1~2个重复的ACK</li>
<li>如果一连串收到3个或3个以上的重复ACK，就非常可能是一个<strong>报文段丢失</strong>了</li>
</ol>
<ul>
<li>快速重传算法：无需等待超时定时器一处，直接重传丢失的数据报文段</li>
<li>快速恢复算法：接下来执行的不是慢启动算法而是拥塞避免算法<br>算法实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">when(收到第3个重复的ACK）</span><br><span class="line">	ssthresh &#x3D; half(cwnd)</span><br><span class="line">	cwnd &#x3D; 3*ssthresh</span><br><span class="line">when(收到另一个重复的ACK)</span><br><span class="line">	cwnd +&#x3D; 1个报文段大小</span><br><span class="line">	发送一个分组()</span><br><span class="line">when(下一个确认新数据的ACK到达)</span><br><span class="line">	cwnd &lt;- ssthresh</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="21-8-拥塞举例（续）"><a href="#21-8-拥塞举例（续）" class="headerlink" title="21.8 拥塞举例（续）"></a>21.8 拥塞举例（续）</h2><p>假定不会发生拥塞，则最终拥塞窗口将超过接收方的通告窗口，意味着通告窗口将对数据流进行控制。</p>
<p>cwnd实际上以字节而非以报文段来维护，因此前面提到的<code>cwnd+=1/cwnd</code>实际上是<br><code>cwnd += segsize*segsize/cwnd + segsize/8</code></p>
<h2 id="21-9-按每条路由进行度量"><a href="#21-9-按每条路由进行度量" class="headerlink" title="21.9 按每条路由进行度量"></a>21.9 按每条路由进行度量</h2><p>较新的TCP实现在<strong>路由表项</strong>中维持许多我们在本章已经介绍过的指标。当一个TCP连接关闭时，如果已经发送了16个窗口的数据，且目的节点的路由表项不是一个默认的表项，那么下列信息就保存在路由表项中以备下次使用：</p>
<ul>
<li>被平滑的RTT</li>
<li>被平滑的均值偏差</li>
<li>慢启动门限</li>
</ul>
<h2 id="21-10-ICMP的差错"><a href="#21-10-ICMP的差错" class="headerlink" title="21.10 ICMP的差错"></a>21.10 ICMP的差错</h2><p>TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达。<br>当前基于伯克利的实现对这些错误的处理是</p>
<ul>
<li>源站抑制：cwnd置1，ssthresh不变</li>
<li>主机不可达和网络不可达都被忽略，因为这两个差错都被认为是短暂现象</li>
</ul>
<h2 id="21-11-重新分组"><a href="#21-11-重新分组" class="headerlink" title="21.11 重新分组"></a>21.11 重新分组</h2><p>当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能。在协议中这是允许的，因为TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。</p>
<h1 id="ch22-TCP的坚持定时器"><a href="#ch22-TCP的坚持定时器" class="headerlink" title="ch22 TCP的坚持定时器"></a>ch22 TCP的坚持定时器</h1><h2 id="22-1-引言"><a href="#22-1-引言" class="headerlink" title="22.1 引言"></a>22.1 引言</h2><p>窗口大小为0将有效地组织发送方传送数据，直到窗口变为非0为止。</p>
<p>如果报文段8关闭了窗口，TCP必须能够处理报文段9丢失的情况。因为ACK的传输并不可靠。</p>
<p>窗口探查：为防止这种死锁情况的发生，发送方使用一个坚持定时器来周期性地向接收方查询，以便发现窗口是否已增大。</p>
<h2 id="22-2-一个例子"><a href="#22-2-一个例子" class="headerlink" title="22.2 一个例子"></a>22.2 一个例子</h2><p>窗口探查包含一个字节的数据。TCP总是允许发送已关闭窗口之后一个字节的数据。</p>
<p>坚持状态与重传超时之前的一个不同的特点就是TCP从不放弃发送窗口探查。这个过程建持续到窗口被打开或者应用进程使用的连接被终止。</p>
<h2 id="22-3-糊涂窗口综合症"><a href="#22-3-糊涂窗口综合症" class="headerlink" title="22.3 糊涂窗口综合症"></a>22.3 糊涂窗口综合症</h2><p>基于窗口的流量控制方案会导致糊涂窗口综合症SWS</p>
<p>该现象可发生在两端中的任何一端</p>
<ul>
<li>接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告）</li>
<li>发送方也可以发送少量的数据（而不是等待其他的数据一并发送一个大的报文段）</li>
</ul>
<p>可以在任何一端采取措施避免出现糊涂窗口综合症</p>
<ol>
<li>接收方不通告小窗口。通常的算法是</li>
</ol>
<ul>
<li>仅在窗口可以增加1个MSS时才通告</li>
<li>增加接收方缓存空间的一半，不论实际有多少</li>
</ul>
<ol start="2">
<li>发送方只在以下条件之一满足时才发送数据</li>
</ol>
<ul>
<li>可以发送一个满长度的报文段</li>
<li>可以发送至少是接收方通告窗口大小一半的报文段</li>
<li>能够发送手头的所有数据并且不希望接收ACK或者该连接禁止了Nagle算法（<a href="#19-4-Nagle%E7%AE%97%E6%B3%95">CF：19.4节</a>）</li>
</ul>
<h1 id="ch23-TCP的保活定时器"><a href="#ch23-TCP的保活定时器" class="headerlink" title="ch23 TCP的保活定时器"></a>ch23 TCP的保活定时器</h1><h2 id="23-1-引言"><a href="#23-1-引言" class="headerlink" title="23.1 引言"></a>23.1 引言</h2><p>可以没有任何数据流通过一个空闲的TCP连接。</p>
<p>然而，许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力。</p>
<p>保活并不是TCP规范中的一部分。Host Requirements RFC提供了3个不使用保活定时器的理由。然而，许多实现提供了保活定时器。</p>
<p>在连接两个端系统的网络出现临时故障的时候，保活选项会引起一个实际上很好的连接终止。</p>
<p>保活功能主要是为服务器应用程序提供的。服务器应用程序可能会代表客户绑定一些资源，因此希望知道客户主机是否崩溃。</p>
<h2 id="23-2-描述"><a href="#23-2-描述" class="headerlink" title="23.2 描述"></a>23.2 描述</h2><p>如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段。客户主机必然处于以下4个状态之一</p>
<ol>
<li>正常运行并从服务器可达：正常响应，定时器复位。</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动：无响应，每隔75秒探查一次，总共10次无响应就终止连接。</li>
<li>客户主机正常运行，但是从服务器不可达：与状态2相同，都是无响应。</li>
<li>客户主机已经崩溃并重新启动：响应是一个复位，使得服务器终止这个连接。<br>服务器不用关注客户主机被操作员关闭和重新启动的情况。正常关机会使客户的TCP在连接上发出一个FIN。</li>
</ol>
<h1 id="ch24-TCP的未来和性能"><a href="#ch24-TCP的未来和性能" class="headerlink" title="ch24 TCP的未来和性能"></a>ch24 TCP的未来和性能</h1><h2 id="24-1-引言"><a href="#24-1-引言" class="headerlink" title="24.1 引言"></a>24.1 引言</h2><p>本章讨论TCP的一些修改建议，这些建议可以使TCP在高速率环境中获得最大的吞吐量。</p>
<h2 id="24-2-路径MTU发现"><a href="#24-2-路径MTU发现" class="headerlink" title="24.2 路径MTU发现"></a>24.2 路径MTU发现</h2><p>在2.9节我们描述了路径MTU的概念。在11.8节我们看到UDP是怎样处理路径MTU发现的。在本节我们将讨论这个机制是如何按照RFC1191中规定的那样在TCP中进行使用的。</p>
<p>选定起始的报文段大小：min( 对端声明的MSS（默认为536）, 输出接口的MSS )</p>
<p>一旦选定了起始的报文段大小，在该连接上的所有被TCP发送的IP数据报都将被设置DF比特。如果某个中间路由器需要对一个设置了DF标志比特的数据报进行分片，他就丢弃这个数据报，并产生一个我们在11.6节介绍的ICMP的“不能分片”差错。</p>
<p>如果收到这个ICMP差错，TCP就减少段大小并进行重传。具体做法取决于新旧</p>
<h3 id="24-2-1-一个例子"><a href="#24-2-1-一个例子" class="headerlink" title="24.2.1 一个例子"></a>24.2.1 一个例子</h3><h3 id="24-2-2-大分组还是小分组"><a href="#24-2-2-大分组还是小分组" class="headerlink" title="24.2.2 大分组还是小分组"></a>24.2.2 大分组还是小分组</h3><h2 id="24-3-长肥管道"><a href="#24-3-长肥管道" class="headerlink" title="24.3 长肥管道"></a>24.3 长肥管道</h2><p>一个连接的容量被称为带宽时延乘积，也可称它为两端的管道大小。</p>
<p>具有大的带宽时延乘积的网络被称为长肥网络（LFN）。使用长肥网络会遇到多种问题</p>
<ol>
<li>窗口被限制在65535个字节内。在<a href="#24-4-%E7%AA%97%E5%8F%A3%E6%89%A9%E5%A4%A7%E9%80%89%E9%A1%B9">24.4节</a>介绍的窗口扩大选项可以解决这个问题</li>
<li>在一个长肥网络LFN内的分组丢失会使吞吐量急剧减少。</li>
<li>我们在第21.4节看到许多TCP实现对每个窗口的RTT仅进行一次测量。在一个长肥网络LFN上需要更好的RTT测量机制。我们将在<a href="#24-5-%E6%97%B6%E9%97%B4%E6%88%B3%E9%80%89%E9%A1%B9">24.5节</a>介绍时间戳选项，它允许更多的报文段被计时，包括重传。</li>
<li>TCP序号空间有限。在一个千兆比网络只要34秒就会发生序号的回绕。在<a href="#24-6-PAWS%EF%BC%9A%E9%98%B2%E6%AD%A2%E5%9B%9E%E7%BB%95%E7%9A%84%E5%BA%8F%E5%8F%B7">24.6节</a>我们将介绍一种对付这种情况的办法：使用TCP时间戳选项的PAWS算法（保护回绕的序号）</li>
</ol>
<p>4.4BSD包含了我们将要在下面介绍的所有选项和算法。许多供应商也正在开始支持这些选项。</p>
<h3 id="千兆比网络"><a href="#千兆比网络" class="headerlink" title="千兆比网络"></a>千兆比网络</h3><p>时延和带宽的差别</p>
<p>考虑通过美国发送一个100万字节的文件的情况，假定时延都为30ms。图24-6显示了两种情况，当30ms以后数据的第1个比特都已到达对端时</p>
<ul>
<li>使用1.544Mb/s电话线：发送方仍然有994210个字节等待发送</li>
<li>使用1Gb/s网络：整个文件仅使用了25%左右的带宽，此时文件的最后一个比特已经到达第1个字节后8ms处。</li>
</ul>
<p>在千兆比速率下，时延限制占据了主要地位，而带宽不再成为限制。当我们考虑到分组需要建立和终止一个连接时，这个固定时延起的作用就更糟糕了。千兆比网络会引起一些需要不同看待的观点。</p>
<h2 id="24-4-窗口扩大选项"><a href="#24-4-窗口扩大选项" class="headerlink" title="24.4 窗口扩大选项"></a>24.4 窗口扩大选项</h2><p>通过定义一个选项实现对16bit的窗口定义扩大为32bit</p>
<p>这个选项只能够出现在一个SYN报文段中。<br>主动建立连接的一方在其SYN中发送这个选项，但是被动建立连接的一方只能够在收到带有这个选项的SYN之后才可以发送这个选项。每个方向上的扩大因子可以不同。</p>
<p>如果主动连接的一方发送一个非零的扩大因子，但是没有从另一端收到一个窗口扩大选项，它就将发送和接收的移位计数器置为0。这就允许较新的系统能与较旧、不理解新选项的系统进行互操作。</p>
<h2 id="24-5-时间戳选项"><a href="#24-5-时间戳选项" class="headerlink" title="24.5 时间戳选项"></a>24.5 时间戳选项</h2><p>时间戳选项使发送方在每个报文段中放置一个时间戳值。接收方在确认中返回这个数值，从而允许发送方为每一个收到的ACK计算RTT。<br>较大的窗口需要进行更好的RTT计算。</p>
<p>如果接收方发送一个确认了两个报文段的ACK，那么哪一个收到的时间戳应当放回显应答字段中来发回去呢？<br>为了减少任一端所维持的状态数量，对于每个连接只保持一个时间戳的数值。</p>
<ol>
<li>如果ACK被接收方迟延，则作为回显值的时间戳值应该对应于最早被确认的报文段。</li>
<li>如果一个收到的报文段虽然在窗口范围内但同时又是失序，这就表明前面的报文段已经丢失。当那个丢失的报文段到达时，它的时间戳将被回显。</li>
</ol>
<p>尽管时间戳选项能够更好地计算RTT，它还为发送方提供了一种方法，以避免接收到旧的报文段，并认为它们是现在的数据的一部分。下一节将对此进行描述。</p>
<h2 id="24-6-PAWS：防止回绕的序号"><a href="#24-6-PAWS：防止回绕的序号" class="headerlink" title="24.6 PAWS：防止回绕的序号"></a>24.6 PAWS：防止回绕的序号</h2><p>接收方将时间戳视为序列号的一个32bit的扩展。比最近有效的时间戳要小的报文段会被PAWS算法丢弃。</p>
<h2 id="24-7-T-TCP：为事务用的TCP扩展"><a href="#24-7-T-TCP：为事务用的TCP扩展" class="headerlink" title="24.7 T/TCP：为事务用的TCP扩展"></a>24.7 T/TCP：为事务用的TCP扩展</h2><p>TCP提供的是一种虚电路方式的运输服务。<br>这种虚电路服务非常适合诸如远程注册和文件传输之类的应用。</p>
<p>事务服务符合以下特征</p>
<ol>
<li>避免连接建立和连接终止的开销</li>
<li>等待时间应当减少到 RTT + SPT</li>
<li>服务器应当能够检测出重复的请求</li>
</ol>
<p>如今一个应用程序设计人员面对的一种选择是使用TCP还是UDP。TCP提供了过多的事务特征，而UDP提供的则不够。通常应用程序使用UDP来构造（避免TCP连接的开销），而许多需要的特征（如动态超时和重传、拥塞避免等）被放置在应用层，一遍又一遍的重新设计和实现。</p>
<p>一个较好的解决办法是提供一个能够提供足够多的事务处理功能的运输层。称为T/TCP。</p>
<p>T/TCP的特征中吸引人的地方在于它对现有协议进行了最小的修改，同时又兼容了现有的实现。它还利用了TCP中现有的工程特征，而不是迫使应用进程来处理这些问题。</p>
<p>一个可作为替换的事务协议是通用报文事务协议VMTP。<br>VMTP是使用IP的一个完整的运输层。</p>
<h2 id="24-8-TCP的性能"><a href="#24-8-TCP的性能" class="headerlink" title="24.8 TCP的性能"></a>24.8 TCP的性能</h2><p>在10Mb/s的以太网上的理论上的最大吞吐量是1.18MB/s</p>
<p>实际限制：</p>
<ol>
<li>不能比最慢的链路运行得更快。</li>
<li>不能比最慢的及其的内存运行得更快。这假定实现是只使用一遍数据，如果不是这样，那么将运行地更慢。</li>
<li>不能比由接收方提供的窗口大小除以往返时间所得结果运行得更快。</li>
</ol>
<p>TCP的理论性能仅受最大的1千兆字节窗口和光速的限制。许多协议性能问题在于实现中的缺陷而不是协议所固有的一些限制。</p>
<h2 id="24-9-小结"><a href="#24-9-小结" class="headerlink" title="24.9 小结"></a>24.9 小结</h2><p>路径MTU发现在MTU较大时，对于非本地连接，允许TCP使用比默认的536大的窗口。</p>
<p>窗口扩大选项使最大的TCP窗口从65535增加到1千兆字节以上。<br>时间戳选项允许多个报文段被精确计时，并允许接收方提供序号回绕保护（PAWS）。</p>
<p>为事务用的TCP扩展允许一个请求-应答序列在通常的情况下只使用三个报文段来完成。它避免使用三次握手，并缩短了TIME_WAIT状态，其方法是为每个主机高速缓存少量的信息，这些信息曾用来建立过一个连接。它还在包含数据报文段中使用SYN和FIN标志。</p>
<p>除了在一个ICMP报文中为路径MTU发现增加了一个额外字段之外，这些新的选项只需要在那些需要使用它们的端系统中进行实现。</p>
<h1 id="ch25-SNMP：简单网络管理协议"><a href="#ch25-SNMP：简单网络管理协议" class="headerlink" title="ch25 SNMP：简单网络管理协议"></a>ch25 SNMP：简单网络管理协议</h1><h2 id="25-1-引言"><a href="#25-1-引言" class="headerlink" title="25.1 引言"></a>25.1 引言</h2><p>基于TCP/IP的网络管理包含两个部分：</p>
<ul>
<li>网络管理站（也叫管理进程，manager）</li>
<li>被管的网络单元（也叫被管设备），例如：路由器、X终端、终端服务器和打印机等</li>
</ul>
<p>被管设备端和管理相关的软件叫做代理程序或代理进程。<br>管理站一般都是带有彩色监视器的工作站，可以显示所有被管设备的状态。</p>
<p>管理进程和代理进程之间的通信</p>
<ul>
<li>询问和要求改变一个具体的参数值</li>
<li>报告有某些重要的事情发生</li>
</ul>
<p>基于TCP/IP的网络管理包含3个组成部分</p>
<ol>
<li>管理信息库MIB：包含所有代理进程的所有可被查询和修改的参数。</li>
<li>管理信息结构SMI：关于MIB的一套公用的结构和表示符号</li>
<li>简单网络管理协议SNMP：管理进程和代理进程之间的通信协议，用的最多的是UDP</li>
</ol>
<h2 id="25-2-协议"><a href="#25-2-协议" class="headerlink" title="25.2 协议"></a>25.2 协议</h2><p>关于交互信息，SNMP定义了5种报文</p>
<ol>
<li>get-request</li>
<li>get-next-request</li>
<li>set-request</li>
<li>get-response：代理进程返回一个或多个参数值</li>
<li>trap：代理进程主动通知管理进程有某些事情发生</li>
</ol>
<p>前3种操作采用UDP的161窗口，代理进程发出的Trap操作采用UDP的162端口。一个系统可以同时为管理进程和代理进程。</p>
<h2 id="25-3-管理信息结构"><a href="#25-3-管理信息结构" class="headerlink" title="25.3 管理信息结构"></a>25.3 管理信息结构</h2><p>本节讨论数据类型</p>
<h2 id="25-4-对象标识符"><a href="#25-4-对象标识符" class="headerlink" title="25.4 对象标识符"></a>25.4 对象标识符</h2><p>对象标识是一个整数序列，以点分隔。</p>
<p>所有的MIB变量都从1.3.6.1.2.1这个标识符开始。</p>
<p>树上的每个结点同时还有一个文字名，方便阅读</p>
<p>1.3.6.1.4.1是给厂家自定义而预留的</p>
<h2 id="25-5-管理信息库介绍"><a href="#25-5-管理信息库介绍" class="headerlink" title="25.5 管理信息库介绍"></a>25.5 管理信息库介绍</h2><p>MIB就是所有代理进程包含的、并且能够被管理进程进行查询和设置的信息的集合。</p>
<h2 id="25-6-实例标识"><a href="#25-6-实例标识" class="headerlink" title="25.6 实例标识"></a>25.6 实例标识</h2><p>只有叶子节点是可操作的。SNMP没法处理表格的一整行或一整列</p>
<h3 id="25-6-1-简单变量"><a href="#25-6-1-简单变量" class="headerlink" title="25.6.1 简单变量"></a>25.6.1 简单变量</h3><p>在其对象标识后面添加<code>.0</code><br>例如1.3.6.1.2.1.7.1.0，通常可以缩写为udpInDatagrams.0</p>
<h3 id="25-6-2-表格"><a href="#25-6-2-表格" class="headerlink" title="25.6.2 表格"></a>25.6.2 表格</h3><p>对于UDP监听表来说，MIB定义了包含两个变量的联合索引：udpLocalAddress、udpLocalPort。</p>
<h3 id="25-6-3-字典式排序"><a href="#25-6-3-字典式排序" class="headerlink" title="25.6.3 字典式排序"></a>25.6.3 字典式排序</h3><p>是MIB按照对象标识进行排序的隐含规则。</p>
<h2 id="25-7-一些简单的例子"><a href="#25-7-一些简单的例子" class="headerlink" title="25.7 一些简单的例子"></a>25.7 一些简单的例子</h2><p><code>snmpi -a gateway -c secret</code><br>其中-a选项代表要和之通信的代理进程名称，-c选项标识SNMP的共同体名。<br>代理进程允许客户进程用只读共同体名对变量进行读操作，用读写共同体名对变量进行读和写操作。</p>
<h2 id="25-7-1-简单变量"><a href="#25-7-1-简单变量" class="headerlink" title="25.7.1 简单变量"></a>25.7.1 简单变量</h2><p><code>get udpInDatagrams.0 udpLocalPorts.0</code></p>
<h2 id="25-7-2-get-next操作"><a href="#25-7-2-get-next操作" class="headerlink" title="25.7.2 get-next操作"></a>25.7.2 get-next操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next udp</span><br><span class="line">next udpInDatagrams.0</span><br><span class="line">next udpNoPorts.0</span><br></pre></td></tr></table></figure>
<h3 id="25-7-3-表格的访问"><a href="#25-7-3-表格的访问" class="headerlink" title="25.7.3 表格的访问"></a>25.7.3 表格的访问</h3><p>udpTable不是叶子对象，但是get-next操作依然能够返回表格中的下一个对象。</p>
<p>当返回结果超出表格之外的下一个变量时，管理进程就可以发现变量的名称发生了较大的变化。</p>
<h2 id="25-8-管理信息库（续）"><a href="#25-8-管理信息库（续）" class="headerlink" title="25.8 管理信息库（续）"></a>25.8 管理信息库（续）</h2><p>本节介绍下列MIB组：system（系统标识）、if（接口）、at（地址转换）、ip、icmp和tcp。</p>
<h2 id="25-9-其他一些例子"><a href="#25-9-其他一些例子" class="headerlink" title="25.9 其他一些例子"></a>25.9 其他一些例子</h2><p>本节回答了11.6节和14.4节中没有回答的问题</p>
<h2 id="图25-30-trap的类型"><a href="#图25-30-trap的类型" class="headerlink" title="图25-30 trap的类型"></a>图25-30 trap的类型</h2><h2 id="25-11-ASN-1和BER"><a href="#25-11-ASN-1和BER" class="headerlink" title="25.11 ASN.1和BER"></a>25.11 ASN.1和BER</h2><p>SNMP采用ASN.1语法和BER编码</p>
<p>ASN.1和BER这两个繁琐的概念仅仅在实现SNMP的时候才重要</p>
<h2 id="25-12-SNMPv2"><a href="#25-12-SNMPv2" class="headerlink" title="25.12 SNMPv2"></a>25.12 SNMPv2</h2><p>第二版区别</p>
<ol>
<li>新的分组类型get-bulk-request，它高效率地从代理进程读取大块数据。</li>
<li>新的分组类型inform-request，它使一个进程可以向另一个进程发送信息。</li>
<li>定义了两个新的MIB</li>
<li>安全性大有提高，提供鉴别和加密</li>
</ol>
<h1 id="ch26-Telnet和Rlogin：远程登录"><a href="#ch26-Telnet和Rlogin：远程登录" class="headerlink" title="ch26 Telnet和Rlogin：远程登录"></a>ch26 Telnet和Rlogin：远程登录</h1><h2 id="26-1-引言"><a href="#26-1-引言" class="headerlink" title="26.1 引言"></a>26.1 引言</h2><p>我们可以先登录到一台主机然后再通过网络远程登录到任何其他一台网络主机上去。</p>
<ul>
<li>Telnet是标准的提供远程登录功能的应用</li>
<li>Rlogin比较简单，首先介绍</li>
</ul>
<h2 id="26-2-Rlogin协议"><a href="#26-2-Rlogin协议" class="headerlink" title="26.2 Rlogin协议"></a>26.2 Rlogin协议</h2><h3 id="26-2-1-应用进程的启动"><a href="#26-2-1-应用进程的启动" class="headerlink" title="26.2.1 应用进程的启动"></a>26.2.1 应用进程的启动</h3><p>用ZeroByte表示一个字节的0。当TCP连接建立完毕</p>
<ol>
<li>客户发送4个字符串：</li>
</ol>
<ul>
<li>ZeroByte</li>
<li>用户登录进客户进程主机的登录名，以ZeroByte结束</li>
<li>登录服务器进程端主机的登录名，以ZeroByte结束</li>
<li>用户终端类型名，紧跟一个<code>/</code>，然后是终端速率，以ZeroByte结束</li>
</ul>
<ol>
<li>服务器返回ZeroByte</li>
<li>服务器进程可以选择是否要求用户输入口令</li>
<li>服务器进程通常要给客户进程发送请求，询问终端的窗口大小</li>
</ol>
<h3 id="26-2-2-流量控制"><a href="#26-2-2-流量控制" class="headerlink" title="26.2.2 流量控制"></a>26.2.2 流量控制</h3><p>客户进程能够识别用户键入的Control_S和Control_Q，并且终止或启动终端的输出。</p>
<p>emacs把Control_S和Control_Q作为自己的命令。解决这个问题的办法就是由服务器告诉客户是否要进行流量控制。</p>
<h3 id="26-2-3-客户的中断键"><a href="#26-2-3-客户的中断键" class="headerlink" title="26.2.3 客户的中断键"></a>26.2.3 客户的中断键</h3><p>当我们为中断服务器正在运行的进程而键入一个中断字符时，会发生和流量控制相同的问题。</p>
<p>从客户输出到服务器的特殊输入字符不需要采用TCP的紧急方式。</p>
<h3 id="26-2-4-窗口大小的改变"><a href="#26-2-4-窗口大小的改变" class="headerlink" title="26.2.4 窗口大小的改变"></a>26.2.4 窗口大小的改变</h3><p>Rlogin的客户需要采用某些方法来通知服务器窗口大小变化的情况以及新窗口的大小。</p>
<h3 id="26-2-5-服务器到客户的命令"><a href="#26-2-5-服务器到客户的命令" class="headerlink" title="26.2.5 服务器到客户的命令"></a>26.2.5 服务器到客户的命令</h3><p>当服务器要给客户发送命令时，服务器就进入紧急方式，并且把命令放在紧急数据的最后一个字节中。</p>
<p>采用TCP紧急方式发送这些命令的一个原因是“清仓输出”命令需要立即发送给客户，即使服务器到客户的数据流被窗口流量控制所终止。其他的3个命令实时性并不特别强，但为了简单起见，也采用了和“清仓输出”相同的技术。</p>
<ul>
<li>服务器到客户的输出被流量控制所终止的情况是经常发生的，这是因为运行在服务器的进程的输出速率通常大于客户终端的显示速率。</li>
<li>客户到服务器的数据流很少被流量控制所终止，因为这个方向的数据流仅仅包含用户所键入的字符。</li>
</ul>
<h3 id="26-2-6-客户到服务器的命令"><a href="#26-2-6-客户到服务器的命令" class="headerlink" title="26.2.6 客户到服务器的命令"></a>26.2.6 客户到服务器的命令</h3><p>客户可以发送窗口大小命令将当前窗口大小发送给服务器</p>
<p>发送方法是在两个字节的0xff后面紧跟着两个<code>s</code>，之后是4个16bit长的数据，分别是：行数，每列的字符数，X方向的像素数量，Y方向的像素数量。通常情况下，后两个16bit是0。</p>
<ul>
<li>带内信令：命令字节和其他的普通数据一起传输</li>
<li>带外信令：客户进程不需要检查收到的每个字节。即使在紧急方式下，客户进程也仅仅需要留意紧急指针所指向的字节。</li>
</ul>
<p>由于从客户到服务器的数据流量和相反方向的数据流量之比为1:20，这就暗示带内信令适合数据量小的情况，而带外信令适合数据量比较大的情况。</p>
<h3 id="26-2-7-客户的转义符"><a href="#26-2-7-客户的转义符" class="headerlink" title="26.2.7 客户的转义符"></a>26.2.7 客户的转义符</h3><p>和Rlogin<strong>客户</strong>进程直接通信的方法是在一行的开头键入<code>~</code>，紧跟着是下列4个字符之一</p>
<ul>
<li>以句号结束客户进程</li>
<li>以Control_D结束客户进程</li>
<li>以Control_Z挂起客户进程</li>
<li>以Control_Y来挂起仅仅是客户进程的输入。适合运行长时间程序。</li>
</ul>
<h2 id="26-3-Rlogin的例子"><a href="#26-3-Rlogin的例子" class="headerlink" title="26.3 Rlogin的例子"></a>26.3 Rlogin的例子</h2><h2 id="26-4-Telnet协议"><a href="#26-4-Telnet协议" class="headerlink" title="26.4 Telnet协议"></a>26.4 Telnet协议</h2><p>NVT是带有键盘和打印机的字符设备</p>
<h3 id="26-4-1-NVT-ASCII"><a href="#26-4-1-NVT-ASCII" class="headerlink" title="26.4.1 NVT ASCII"></a>26.4.1 NVT ASCII</h3><p>术语NVT ASCII代表7比特的ASCII字符集，在字节中最高位比特为0。</p>
<p>行结束符以\r\n来表示，而\r\0则被认为是回车命令</p>
<p>网间网协议族都使用NVT ASCII，例如FTP,SMTP,Finger和Whois。</p>
<h3 id="26-4-2-Telnet命令"><a href="#26-4-2-Telnet命令" class="headerlink" title="26.4.2 Telnet命令"></a>26.4.2 Telnet命令</h3><p>Telnet通信的两个方向都采用带内信令方式。字节0xff叫做IAC，该字节后面的一个字节才是命令字节。</p>
<h3 id="26-4-3-选项协商"><a href="#26-4-3-选项协商" class="headerlink" title="26.4.3 选项协商"></a>26.4.3 选项协商</h3><p>虽然我们可以认为Telnet连接的双方都是NVT，但是实际上Telnet连接双方首先进行交互的信息是选项协商数据。</p>
<p>对于任何给定的选项，连接的任何一方都可以发送下面4中请求</p>
<ol>
<li>WILL</li>
<li>DO</li>
<li>WONT</li>
<li>DON’T</li>
</ol>
<p>Telnet规定，对于激活选项请求（如1和2），有权同意或者不同意；而对于使选项失效请求（如3和4），必须同意。</p>
<p>选项协商需要3个字节：一个IAC字节，接着一个字节是上述4个请求之一，最后一个ID字节指明激活或禁止选项。</p>
<h3 id="26-4-4-子选项协商"><a href="#26-4-4-子选项协商" class="headerlink" title="26.4.4 子选项协商"></a>26.4.4 子选项协商</h3><p>SB是子选项协商的起始命令标志</p>
<h3 id="26-4-5-半双工、一次一字符、一次一行或行方式"><a href="#26-4-5-半双工、一次一字符、一次一行或行方式" class="headerlink" title="26.4.5 半双工、一次一字符、一次一行或行方式"></a>26.4.5 半双工、一次一字符、一次一行或行方式</h3><h3 id="26-4-6-同步信号"><a href="#26-4-6-同步信号" class="headerlink" title="26.4.6 同步信号"></a>26.4.6 同步信号</h3><p>以DM作为同步信号，该同步信号是以TCP紧急数据形式发送的。</p>
<h3 id="26-4-7-客户的转义符"><a href="#26-4-7-客户的转义符" class="headerlink" title="26.4.7 客户的转义符"></a>26.4.7 客户的转义符</h3><p>Control_]</p>
<h2 id="26-5-Telnet举例"><a href="#26-5-Telnet举例" class="headerlink" title="26.5 Telnet举例"></a>26.5 Telnet举例</h2><p>Telnet有3种数据传输方式。现在的趋势是只要有可能，就尽量工作在准行方式下</p>
<p>Rlogin和Telnet的服务器通常都将设置TCP的保活选项以检测客户主机是否崩溃</p>
<h1 id="ch27-FTP：文件传送协议"><a href="#ch27-FTP：文件传送协议" class="headerlink" title="ch27 FTP：文件传送协议"></a>ch27 FTP：文件传送协议</h1><h2 id="27-1-引言"><a href="#27-1-引言" class="headerlink" title="27.1 引言"></a>27.1 引言</h2><ul>
<li><p>文件传送：FTP提供，将一个完整的文件从一个系统复制到另一个系统中</p>
</li>
<li><p>文件存取：NFS提供</p>
</li>
<li><p>Telnet获得异构性是强制两端采用NVT</p>
</li>
<li><p>FTP支持有限数量的文件类型和文件结构</p>
</li>
</ul>
<h2 id="27-2-FTP协议"><a href="#27-2-FTP协议" class="headerlink" title="27.2 FTP协议"></a>27.2 FTP协议</h2><ul>
<li>IP对控制连接的服务类型：最大限度地减小迟延</li>
<li>IP对数据连接的服务特点：最大限度提高吞吐量</li>
</ul>
<h3 id="27-2-1-数据表示"><a href="#27-2-1-数据表示" class="headerlink" title="27.2.1 数据表示"></a>27.2.1 数据表示</h3><p>FTP提供了控制文件传送与存储的四个方面的选择</p>
<ol>
<li>文件类型</li>
</ol>
<ul>
<li>ASCII码文件类型</li>
<li>EBCDIC文件类型</li>
<li>图像文件类型</li>
<li>本地文件类型</li>
</ul>
<ol>
<li>格式控制（只对ASCII和EBCDIC文件类型有效）</li>
</ol>
<ul>
<li>非打印</li>
<li>远程登录格式控制</li>
<li>Fortran回车控制</li>
</ul>
<ol>
<li>结构</li>
</ol>
<ul>
<li>文件结构</li>
<li>记录结构</li>
<li>页结构</li>
</ul>
<ol>
<li>传输方式</li>
</ol>
<ul>
<li>流方式</li>
<li>块方式</li>
<li>压缩方式</li>
</ul>
<p>通常由Unix实现的FTP客户和服务器把我们的选择限制如下</p>
<ul>
<li>类型：ASCII或图像</li>
<li>格式控制：只允许非打印</li>
<li>结构：只允许文件结构</li>
<li>传输方式：只允许流方式</li>
</ul>
<h3 id="27-2-2-FTP命令"><a href="#27-2-2-FTP命令" class="headerlink" title="27.2.2 FTP命令"></a>27.2.2 FTP命令</h3><h3 id="27-2-3-FTP应答"><a href="#27-2-3-FTP应答" class="headerlink" title="27.2.3 FTP应答"></a>27.2.3 FTP应答</h3><p>典型应答</p>
<ul>
<li>125 数据连接已打开；传输开始</li>
<li>200 就绪命令</li>
<li>214 帮助报文（面向用户）</li>
<li>331 用户名就绪，要求输入口令</li>
<li>425 不能打开数据连接</li>
<li>452 错写文件</li>
<li>500 语法错误（未认可的命令）</li>
<li>501 语法错误（无效参数）</li>
<li>502 未实现的MODE（方式命令）类型</li>
</ul>
<h3 id="27-2-4-连接管理"><a href="#27-2-4-连接管理" class="headerlink" title="27.2.4 连接管理"></a>27.2.4 连接管理</h3><p>传输的一般过程</p>
<ul>
<li>客户主动打开连接到服务器的21端口</li>
<li>客户通常在客户端主机上选择临时端口号，客户从该端口发布一个被动的打开</li>
<li>客户使用PORT命令从控制连接上把端口号发向服务器</li>
<li>服务器接收口号，并向客户端主机上的端口发布一个主动的打开。服务器的数据连接端一直使用端口20</li>
</ul>
<h2 id="27-3-FTP的例子"><a href="#27-3-FTP的例子" class="headerlink" title="27.3 FTP的例子"></a>27.3 FTP的例子</h2><p>跳过</p>
<h1 id="ch28-SMTP：简单邮件传送协议"><a href="#ch28-SMTP：简单邮件传送协议" class="headerlink" title="ch28 SMTP：简单邮件传送协议"></a>ch28 SMTP：简单邮件传送协议</h1><h2 id="28-1-引言"><a href="#28-1-引言" class="headerlink" title="28.1 引言"></a>28.1 引言</h2><p>本章研究在两个MTA之间如何用TCP交换邮件</p>
<h2 id="28-2-SMTP协议"><a href="#28-2-SMTP协议" class="headerlink" title="28.2 SMTP协议"></a>28.2 SMTP协议</h2><h3 id="28-2-1-简单例子"><a href="#28-2-1-简单例子" class="headerlink" title="28.2.1 简单例子"></a>28.2.1 简单例子</h3><p>只有5个SMTP命令用于发送邮件：HELO，MAIL，RCTP，DATA和QUIT</p>
<p>客户主动打开TCP端口25。返回时，客户等待从服务器来的问候报文（应答代码为220）</p>
<h3 id="28-2-2-SMTP命令"><a href="#28-2-2-SMTP命令" class="headerlink" title="28.2.2 SMTP命令"></a>28.2.2 SMTP命令</h3><p>最小SMTP实现支持8中命令，除了前面的例子中的5个，还有附加和可选命令</p>
<ul>
<li>RSET命令异常终止当前的邮件事务并使两端复位。</li>
<li>VRFY命令使客户能够询问发送方以验证接收方地址</li>
<li>NOOP命令仅强迫服务器响应一个OK应答码</li>
</ul>
<h3 id="28-2-3-信封、首部和正文"><a href="#28-2-3-信封、首部和正文" class="headerlink" title="28.2.3 信封、首部和正文"></a>28.2.3 信封、首部和正文</h3><p>电子邮件由三部分组成</p>
<ol>
<li>信封由两个SMTP命令指明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAIL From: &lt;rstevens@sun.tuc.noao.edu&gt;</span><br><span class="line">RCPT To: &lt;estevens@noao.edu&gt;</span><br></pre></td></tr></table></figure></li>
<li>首部由用户代理使用</li>
<li>正文是发送用户发给接收用户报文的内容。当用DATA命令发送时，先发送首部，紧跟一个空行，然后是正文。</li>
</ol>
<h3 id="28-2-4-中继代理"><a href="#28-2-4-中继代理" class="headerlink" title="28.2.4 中继代理"></a>28.2.4 中继代理</h3><p>本地MTA的信息输出中的 Connectiing to mailhost via ether 表示系统已被配置成把所有非本地的向外的邮件发送到一台中继机上进行转发</p>
<h3 id="28-2-5-扩充多媒体邮件只需对用户代理作一些改变"><a href="#28-2-5-扩充多媒体邮件只需对用户代理作一些改变" class="headerlink" title="28.2.5 扩充多媒体邮件只需对用户代理作一些改变"></a>28.2.5 扩充多媒体邮件只需对用户代理作一些改变</h3><h3 id="28-2-6-重试间隔"><a href="#28-2-6-重试间隔" class="headerlink" title="28.2.6 重试间隔"></a>28.2.6 重试间隔</h3><p>推荐初始时间间隔至少为30分钟。发送方至少4~5天内不能放弃</p>
<h2 id="28-3-SMTP的例子"><a href="#28-3-SMTP的例子" class="headerlink" title="28.3 SMTP的例子"></a>28.3 SMTP的例子</h2><h2 id="28-4-SMTP的未来"><a href="#28-4-SMTP的未来" class="headerlink" title="28.4 SMTP的未来"></a>28.4 SMTP的未来</h2><p>新加入的SMTP命令影响了信封，首部中可以使用非ASCII字母，正文（MINE）中也加入了结构。</p>
<h3 id="28-4-1-信封的变化：扩充的SMTP"><a href="#28-4-1-信封的变化：扩充的SMTP" class="headerlink" title="28.4.1 信封的变化：扩充的SMTP"></a>28.4.1 信封的变化：扩充的SMTP</h3><p>这些变化以向后兼容的方式被加入，所以不影响已有的实现</p>
<p>如果客户想使用新的特性，首先通过发布一个EHLO而不是HELO命令启动一个服务器的回话。相兼容的服务器用250应答码响应。</p>
<ul>
<li>250-SIZE让客户在MAIL FROM命令行中以字节的多少指定报文的大小。</li>
<li>250-8BITMIME允许客户把关键字BODY加到MAIL FROM命令中，指定正文中是否包含NVT ASCII字符（默认的）或8 bit数据</li>
<li>250-XADR等等。任何以X开头的关键字都指的是本地SMTP扩充</li>
</ul>
<h3 id="28-4-2-首部变化：非ASCII字符"><a href="#28-4-2-首部变化：非ASCII字符" class="headerlink" title="28.4.2 首部变化：非ASCII字符"></a>28.4.2 首部变化：非ASCII字符</h3><p>首部字段中可以包含编码字，格式：<code>=?charset?encoding?encoded-text?=</code></p>
<h3 id="28-4-3-正文变化：通用Internet邮件扩充"><a href="#28-4-3-正文变化：通用Internet邮件扩充" class="headerlink" title="28.4.3 正文变化：通用Internet邮件扩充"></a>28.4.3 正文变化：通用Internet邮件扩充</h3><p>MINE定义5个标题字段、7个内容类型5种不同的编码格式</p>
<p>尽管内容类型和编码是独立的，RFC1521推荐有非ASCII数据的text使用quoted-printable，其他使用base64。</p>
<h1 id="ch29-网络文件系统"><a href="#ch29-网络文件系统" class="headerlink" title="ch29 网络文件系统"></a>ch29 网络文件系统</h1><h2 id="29-1-引言"><a href="#29-1-引言" class="headerlink" title="29.1 引言"></a>29.1 引言</h2><p>NFS的基础是Sun RPC：远程过程调用。</p>
<h2 id="29-2-Sun远程过程调用"><a href="#29-2-Sun远程过程调用" class="headerlink" title="29.2 Sun远程过程调用"></a>29.2 Sun远程过程调用</h2><p>一般来说，客户发送命令给服务器，服务器向客户发送应答。目前为止，我们讨论过的所有应用程序都是采用这种方式实现的。</p>
<p>远程过程调用RPC是一种不同的网络程序设计方法。调用服务器提供的函数时发生了下面一些动作</p>
<ul>
<li>它实际上只是调用了一个位于本机上的、由RPC程序包生成的函数。这个函数被称为客户残桩（stub）。客户残桩将过程的参数封装成一个网络报文，并且将这个报文发送给服务器程序。</li>
<li>服务器残桩接收报文，从中提取参数，然后调用服务器过程</li>
<li>当服务器函数返回时，它返回到服务器残桩。封装成网络报文然后发送给客户残桩</li>
<li>客户残桩从报文中取出返回值，将其返回给客户程序</li>
</ul>
<p>图29-1显示的是使用UDP时，一个RPC过程调用报文的格式。</p>
<p>图29-2显示了一个RPC应答报文的格式</p>
<h2 id="29-3-XDR：外部数据表示"><a href="#29-3-XDR：外部数据表示" class="headerlink" title="29.3 XDR：外部数据表示"></a>29.3 XDR：外部数据表示</h2><p>外部数据表示用来对RPC调用报文和应答报文中的值进行编码</p>
<h2 id="29-4-端口映射器"><a href="#29-4-端口映射器" class="headerlink" title="29.4 端口映射器"></a>29.4 端口映射器</h2><p>RPC服务器不使用指明窗口，需要注册程序来跟踪RPC程序使用了哪一个临时端口。这个注册程序被称为端口映射器。</p>
<p>端口映射器本身必须有一个知名端口：111。端口映射器提供四个服务过程</p>
<ul>
<li>PMAPPROC_SET</li>
<li>PMAPPROC_UNSET</li>
<li>PMAPPROC_GETPORT</li>
<li>PMAPPROC_DUMP</li>
</ul>
<p>从RPC服务器程序启动到被调用的过程：</p>
<ul>
<li>系统引导时，端口映射器启动。它创建TCP和UDP端点</li>
<li>当RPC服务器应用程序启动时，它为它所支持的程序的每一个版本创建TCP和UDP端点。两个端点各自绑定一个临时端口。服务器通过PMAPPROC_SET过程注册每一个程序、版本、协议和端口号。</li>
<li>当RPC应用程序启动时，它调用端口映射器的PMAPPROC_GETPORT过程来获得一个指定程序、版本和协议的临时端口号。</li>
<li>客户发送一个RPC调用报文给第3步返回的端口号。</li>
</ul>
<h2 id="29-5-NFS协议"><a href="#29-5-NFS协议" class="headerlink" title="29.5 NFS协议"></a>29.5 NFS协议</h2><p>FTP会产生文件一个完整的副本；NFS只访问一个进程引用文件的那一部分。<br>任何能够访问一个本地文件的客户程序不需要做任何修改，就应该能够访问一个NFS文件。</p>
<p>NFS是一个使用Sun RPC构造的客户服务器应用程序。尽管这一工作可以使用一般的用户进程来实现，但是在内核与用户进程之间进行切换的代价太大。</p>
<p>大多数的NFS服务器都是多线程的。既然大多数的Unix内核不是多线程的，一个共同的技术就是启动一个用户进程（常被称为nfsd）的多个实例。这个实例执行一个系统调用，使自己作为一个内核进程保留在操作系统的内核中。</p>
<h3 id="29-5-1-文件句柄"><a href="#29-5-1-文件句柄" class="headerlink" title="29.5.1 文件句柄"></a>29.5.1 文件句柄</h3><p>文件句柄的内容只对服务器有意义</p>
<h3 id="29-5-2-安装协议"><a href="#29-5-2-安装协议" class="headerlink" title="29.5.2 安装协议"></a>29.5.2 安装协议</h3><p>客户必须在访问服务器上一个文件系统中的文件之前，使用安装协议安装那个文件系统。</p>
<h3 id="29-5-3-NFS过程"><a href="#29-5-3-NFS过程" class="headerlink" title="29.5.3 NFS过程"></a>29.5.3 NFS过程</h3><p>NFS服务器提供15个过程</p>
<h3 id="29-5-4-UDP还是TCP"><a href="#29-5-4-UDP还是TCP" class="headerlink" title="29.5.4 UDP还是TCP"></a>29.5.4 UDP还是TCP</h3><p>NFS最初是用UDP写的，TCP支持主要用于广域网</p>
<h3 id="29-5-5-TCP上的NFS"><a href="#29-5-5-TCP上的NFS" class="headerlink" title="29.5.5 TCP上的NFS"></a>29.5.5 TCP上的NFS</h3><h2 id="29-6-NFS实例"><a href="#29-6-NFS实例" class="headerlink" title="29.6 NFS实例"></a>29.6 NFS实例</h2><h3 id="29-6-3-无状态"><a href="#29-6-3-无状态" class="headerlink" title="29.6.3 无状态"></a>29.6.3 无状态</h3><p>服务器并不记录哪个客户正在访问哪个文件，没有open和close操作。</p>
<p>无状态设计的理由是为了在服务器崩溃并且重启动时，简化服务器的崩溃恢复操作。</p>
<h3 id="29-6-5-等幂过程"><a href="#29-6-5-等幂过程" class="headerlink" title="29.6.5 等幂过程"></a>29.6.5 等幂过程</h3><p>客户维护着状态（每个文件当前的偏移位置），而不是服务器</p>
<p>并非所有的文件操作都是等幂的</p>
<p>NFS服务器需要一种方法来处理非等幂的操作。大多数的服务器实现了一个最近应答的高速缓存，用于存放非等幂操作最近的应答。收到同样的请求就返回以前的应答而不再调用相应的NFS过程。</p>
<p>等幂服务器过程的概念可以应用于任何基于UDP的应用程序</p>
<h2 id="29-7-第3版的NFS"><a href="#29-7-第3版的NFS" class="headerlink" title="29.7 第3版的NFS"></a>29.7 第3版的NFS</h2><h1 id="ch30-其他的TCP-IP应用程序"><a href="#ch30-其他的TCP-IP应用程序" class="headerlink" title="ch30 其他的TCP/IP应用程序"></a>ch30 其他的TCP/IP应用程序</h1><h2 id="30-1-引言"><a href="#30-1-引言" class="headerlink" title="30.1 引言"></a>30.1 引言</h2><p>我们提供一些Internet上资源发现工具的概述。</p>
<h2 id="30-2-Finger协议"><a href="#30-2-Finger协议" class="headerlink" title="30.2 Finger协议"></a>30.2 Finger协议</h2><p>Finger协议返回一个指定主机上一个或多个用户的信息。</p>
<h2 id="30-3-Whois协议"><a href="#30-3-Whois协议" class="headerlink" title="30.3 Whois协议"></a>30.3 Whois协议</h2><p>Whois协议是另一种信息服务。维护者所有的DNS域和很多连接在Internet上的系统的系统管理员的信息</p>
<h4 id="白页"><a href="#白页" class="headerlink" title="白页"></a>白页</h4><h2 id="30-4-Archie、WAIS、Gopher、Veronica和WWW"><a href="#30-4-Archie、WAIS、Gopher、Veronica和WWW" class="headerlink" title="30.4 Archie、WAIS、Gopher、Veronica和WWW"></a>30.4 Archie、WAIS、Gopher、Veronica和WWW</h2><p>Finger、Whois和白页服务使用来查找人的信息的。还有一些工具是用来定位文件和文档的。</p>
<h3 id="Archie用于从几千个FTP中搜索那些名字中包含了一个指定的常规表达式的文件"><a href="#Archie用于从几千个FTP中搜索那些名字中包含了一个指定的常规表达式的文件" class="headerlink" title="Archie用于从几千个FTP中搜索那些名字中包含了一个指定的常规表达式的文件"></a>Archie用于从几千个FTP中搜索那些<strong>名字中</strong>包含了一个指定的常规表达式的文件</h3><h3 id="WAIS帮助我们查找一个内容中包含一个关键字的文件或数据库"><a href="#WAIS帮助我们查找一个内容中包含一个关键字的文件或数据库" class="headerlink" title="WAIS帮助我们查找一个内容中包含一个关键字的文件或数据库"></a>WAIS帮助我们查找一个<strong>内容中</strong>包含一个关键字的文件或数据库</h3><h3 id="Gopher是其他Internet资源服务的一个菜单驱动的前端程序"><a href="#Gopher是其他Internet资源服务的一个菜单驱动的前端程序" class="headerlink" title="Gopher是其他Internet资源服务的一个菜单驱动的前端程序"></a>Gopher是其他Internet资源服务的一个菜单驱动的前端程序</h3><h3 id="Veronica是一个Gopher标题的索引"><a href="#Veronica是一个Gopher标题的索引" class="headerlink" title="Veronica是一个Gopher标题的索引"></a>Veronica是一个Gopher标题的索引</h3><h3 id="万维网使得我们可以浏览一个大的-全球范围的服务和文档。"><a href="#万维网使得我们可以浏览一个大的-全球范围的服务和文档。" class="headerlink" title="万维网使得我们可以浏览一个大的/全球范围的服务和文档。"></a>万维网使得我们可以浏览一个大的/全球范围的服务和文档。</h3><h2 id="30-5-X窗口系统"><a href="#30-5-X窗口系统" class="headerlink" title="30.5 X窗口系统"></a>30.5 X窗口系统</h2><p>X窗口系统可以使得多个客户（应用）使用由一个服务器管理的位映射显示器</p>
<h1 id="附录A-tcpdump程序"><a href="#附录A-tcpdump程序" class="headerlink" title="附录A tcpdump程序"></a>附录A tcpdump程序</h1><p>tcpdump通过将网络接口卡设置为混杂模式来截获经过网络接口的每一个分组。<br>本书中使用的是2.2.1版。</p>
<p>程序snoop和iptrace也提供了类似的功能。</p>
<h2 id="A-1-BSD分组过滤器"><a href="#A-1-BSD分组过滤器" class="headerlink" title="A.1 BSD分组过滤器"></a>A.1 BSD分组过滤器</h2><h2 id="A-2-SunOS的网络接口分接头"><a href="#A-2-SunOS的网络接口分接头" class="headerlink" title="A.2 SunOS的网络接口分接头"></a>A.2 SunOS的网络接口分接头</h2><h2 id="A-3-SVR4数据链路提供者接口"><a href="#A-3-SVR4数据链路提供者接口" class="headerlink" title="A.3 SVR4数据链路提供者接口"></a>A.3 SVR4数据链路提供者接口</h2><h2 id="A-4-tcpdump的输出"><a href="#A-4-tcpdump的输出" class="headerlink" title="A.4 tcpdump的输出"></a>A.4 tcpdump的输出</h2><p>本书对tcpdump的原始输出进行了修改以便阅读</p>
<ol>
<li>删去了网络接口名字</li>
<li>把时间戳的HH:MM:SS格式改为：与开始监听的相对时间以及与下面分组的时间差</li>
<li>经常把<code>发送主机名字 &gt; 目的主机名字</code>画成时间线</li>
<li>在太长行的适当地方进行了换行</li>
<li>没有显示中断键</li>
<li>没有显示接收到的和漏掉的分组的个数（漏掉的分组是那些到达得太快，tcpdump来不及处理的分组。因为本文中的例子经常运行在另外一个空闲的网络上，所以漏掉的分组个数总是0）</li>
</ol>
<h2 id="A-5-安全性考虑"><a href="#A-5-安全性考虑" class="headerlink" title="A.5 安全性考虑"></a>A.5 安全性考虑</h2><p>截获网络数据流使我们可以看到Telnet和FTP口令的明文表示。<br>然而，很多时候一个网络管理员需要使用一个类似于tcpdump的工具来分析网络中出现的问题。</p>
<p>对tcpdump等等工具的访问权限依赖于具体系统。<br>一般来说，只有超级用户才能读写这些设备。对于系统管理组用户是可读的。</p>
<h2 id="A-6-插口排错选项"><a href="#A-6-插口排错选项" class="headerlink" title="A.6 插口排错选项"></a>A.6 插口排错选项</h2><p>查看一个TCP连接上发生的事情的另一种方法是使能插口排错选项。</p>
<p><a href="#%E9%99%84%E5%BD%95C-sock%E7%A8%8B%E5%BA%8F">sock程序</a>的-D选项支持这个特征，但是输出的信息难解析和理解</p>
<h1 id="附录B-计算机时钟"><a href="#附录B-计算机时钟" class="headerlink" title="附录B 计算机时钟"></a>附录B 计算机时钟</h1><p>大多数Unix系统所采用的记录时间的方法。<br>硬件按照一定的频率产生一个时钟中断。</p>
<p>一个0.01%的误差就会产生一个每天8.64秒的差错。</p>
<p>如果内核丢失了一个中断，时钟将失去10ms。</p>
<p>tcpdump可以通过NIT驱动程序调用gettimeofday访问微秒级定时器。</p>
<h1 id="附录C-sock程序"><a href="#附录C-sock程序" class="headerlink" title="附录C sock程序"></a>附录C sock程序</h1><p>sock程序运行在以下四种模式之一</p>
<ul>
<li>交互式客户，默认模式，例如<code>sock bsdi echo</code></li>
<li>交互式服务器，例如<code>sock -s [本地接口IP地址] 端口号</code></li>
<li>源客户：指明-i选项。在默认情况下，将一个1024字节的缓存写到网络中，写1024次。-n和-w选项可以改变默认值。</li>
<li>接收器服务器：指明-i和-s选项。从网络中读数据然后扔掉。<br>这些例子都使用了TCP，-u选项指明使用udp</li>
</ul>
<p>sock的其它选项一览表 CF：原书P379</p>
<h1 id="附录D-部分习题的解答"><a href="#附录D-部分习题的解答" class="headerlink" title="附录D 部分习题的解答"></a>附录D 部分习题的解答</h1><h1 id="附录E-配置选项"><a href="#附录E-配置选项" class="headerlink" title="附录E 配置选项"></a>附录E 配置选项</h1><p>共6节，每节对应一个操作系统</p>
<h1 id="附录F-可以免费获得的源代码"><a href="#附录F-可以免费获得的源代码" class="headerlink" title="附录F 可以免费获得的源代码"></a>附录F 可以免费获得的源代码</h1><p>公开资料一览表 CF：原书P406</p>
<p>作者编写的软件在主机 ftp.uu.net 的文件 published/books/stevens.tcpipiv1.tar.z 中提供</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><h1 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/09/tcp-ip-xiang-jie/" data-id="cl310rf45001ggctkd73fgf1d" data-title="《TCP/IP详解》读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-web-scraping-with-python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/05/web-scraping-with-python/" class="article-date">
  <time class="dt-published" datetime="2021-05-05T09:27:47.000Z" itemprop="datePublished">2021-05-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/05/web-scraping-with-python/">《python网络爬虫权威指南》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a href="#%E5%89%8D%E8%A8%80">前言</a><br><a href="#ch01-%E5%88%9D%E8%A7%81%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB">ch01 初见网络爬虫</a><br><a href="#ch06-%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE">ch06 存储数据</a><br><a href="#ch0">ch0 </a><br><a href="#ch11-%E6%8A%93%E5%8F%96-JavaScript">ch11 抓取-JavaScript</a><br><a href="#15-3-Selenium-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">15.3 Selenium 单元测试</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="建议所有读者学习第一部分，并根据自己的实际需求深入探索第二部分"><a href="#建议所有读者学习第一部分，并根据自己的实际需求深入探索第二部分" class="headerlink" title="建议所有读者学习第一部分，并根据自己的实际需求深入探索第二部分"></a>建议所有读者学习第一部分，并根据自己的实际需求深入探索第二部分</h2><p>按初、中级Python编程水平来编写书中的概念和代码示例</p>
<h2 id="大体上，你遇到的90-的网页爬取项目使用的都是前6章介绍的技术"><a href="#大体上，你遇到的90-的网页爬取项目使用的都是前6章介绍的技术" class="headerlink" title="大体上，你遇到的90%的网页爬取项目使用的都是前6章介绍的技术"></a>大体上，你遇到的90%的网页爬取项目使用的都是前6章介绍的技术</h2><h1 id="ch01-初见网络爬虫"><a href="#ch01-初见网络爬虫" class="headerlink" title="ch01 初见网络爬虫"></a>ch01 初见网络爬虫</h1><h2 id="本章将首先向网络服务器发送GET请求。只有三行代码的scrapetest-py即可实现。"><a href="#本章将首先向网络服务器发送GET请求。只有三行代码的scrapetest-py即可实现。" class="headerlink" title="本章将首先向网络服务器发送GET请求。只有三行代码的scrapetest.py即可实现。"></a>本章将首先向网络服务器发送GET请求。只有三行代码的scrapetest.py即可实现。</h2><h3 id="1-1-网络连接"><a href="#1-1-网络连接" class="headerlink" title="1.1 网络连接"></a>1.1 网络连接</h3><p>当Web浏览器遇到一个标签时，比如<code>&lt;img src=&quot;cuteKitten.jpg&gt;</code>，会向服务器发起另一个请求以获取图片文件。你的Python程序没有请求多个文件的逻辑，它只能读取你直接请求的单个HTML文件。</p>
<h3 id="1-2-BeautifulSoup简介"><a href="#1-2-BeautifulSoup简介" class="headerlink" title="1.2 BeautifulSoup简介"></a>1.2 BeautifulSoup简介</h3><h4 id="1-2-1-安装BeautifulSoup"><a href="#1-2-1-安装BeautifulSoup" class="headerlink" title="1.2.1 安装BeautifulSoup"></a>1.2.1 安装BeautifulSoup</h4><h4 id="1-2-2-运行BeautifulSoup"><a href="#1-2-2-运行BeautifulSoup" class="headerlink" title="1.2.2 运行BeautifulSoup"></a>1.2.2 运行BeautifulSoup</h4><p><code>bs = BeautifulSoup(html.read(), &#39;html.parser&#39;) </code>第二个参数指定了解析器，在大多数情况下，你选择任何一个解析器都差别不大。</p>
<p><code>print(bs.h1)</code>仅仅显示了页面上的<strong>第一个</strong> h1 标签。</p>
<h4 id="1-2-3-可靠的网络连接以及异常的处理"><a href="#1-2-3-可靠的网络连接以及异常的处理" class="headerlink" title="1.2.3 可靠的网络连接以及异常的处理"></a>1.2.3 可靠的网络连接以及异常的处理</h4><p>函数urlopen主要会发生两种异常</p>
<ul>
<li>网页在服务器上不存在（或者获取页面的时候出现错误）：会抛出HTTPError异常</li>
<li>服务器不存在：会抛出URLError异常</li>
</ul>
<p>即使从服务器成功获取网页，网页上的内容可能并非完全是我们期望的那样。</p>
<ul>
<li>如果你想要调用的标签不存在，BeautifulSoup就会返回None对象。</li>
<li>如果再调用这个None对象下面的子标签，就会发生AttributeError错误</li>
</ul>
<h1 id="ch06-存储数据"><a href="#ch06-存储数据" class="headerlink" title="ch06 存储数据"></a>ch06 存储数据</h1><p>3种数据管理方法：写入数据库、存到硬盘、发邮件</p>
<h2 id="这一章的内容其实是实现第二部分许多示例的基础"><a href="#这一章的内容其实是实现第二部分许多示例的基础" class="headerlink" title="这一章的内容其实是实现第二部分许多示例的基础"></a>这一章的内容其实是实现第二部分许多示例的基础</h2><h3 id="6-1-媒体文件"><a href="#6-1-媒体文件" class="headerlink" title="6.1 媒体文件"></a>6.1 媒体文件</h3><p>用<code>urllib.request.urlretrieve</code>下载图片</p>
<h3 id="6-2-把数据存储到CSV"><a href="#6-2-把数据存储到CSV" class="headerlink" title="6.2 把数据存储到CSV"></a>6.2 把数据存储到CSV</h3><p>Python的CSV库可以非常简单地修改CSV文件</p>
<h2 id="本章剩余内容跳过"><a href="#本章剩余内容跳过" class="headerlink" title="本章剩余内容跳过"></a>本章剩余内容跳过</h2><h1 id="ch11-抓取-JavaScript"><a href="#ch11-抓取-JavaScript" class="headerlink" title="ch11 抓取 JavaScript"></a>ch11 抓取 JavaScript</h1><p>两种客户端脚本语言</p>
<ul>
<li>ActionScript：开发Flash应用的语言，需求并不多</li>
<li>JavaScript：它可以手机用户跟踪数据，不需要重载页面直接提交表单，在页面中嵌入多媒体文件，甚至运行在线游戏。你可以在网页源代码的<code>&lt;script&gt;</code>标签之间看到它们。</li>
</ul>
<h3 id="11-1-JavaScript简介"><a href="#11-1-JavaScript简介" class="headerlink" title="11.1 JavaScript简介"></a>11.1 JavaScript简介</h3><h4 id="了解语法"><a href="#了解语法" class="headerlink" title="了解语法"></a>了解语法</h4><h4 id="常用JavaScript库"><a href="#常用JavaScript库" class="headerlink" title="常用JavaScript库"></a>常用JavaScript库</h4><ol>
<li>jQuery</li>
<li>Google Analytics</li>
<li>Google Map</li>
</ol>
<h3 id="11-2-Ajax和动态HTML"><a href="#11-2-Ajax和动态HTML" class="headerlink" title="11.2 Ajax和动态HTML"></a>11.2 Ajax和动态HTML</h3><p>如果提交表单之后，网站的页面不需要重新加载，那么你访问的网站很可能使用了Ajax技术。</p>
<p>两种途径：</p>
<ul>
<li>直接从JavaScript代码里抓取内容</li>
<li>用Python的第三方库执行JavaScript，直接抓取你在浏览器里看到的页面</li>
</ul>
<h4 id="11-2-1-Selenium"><a href="#11-2-1-Selenium" class="headerlink" title="11.2.1 Selenium"></a>11.2.1 Selenium</h4><p>页面的加载时间时不确定的。高效的方法是，让Selenium不断地检查某个元素是否存在，以次确定页面是否已经完全加载。</p>
<p>Selenium的选择器<code>find_element_by_css_selector(&#39;#content&#39;)</code>也可以用复数<code>find_elements_by_css_selector(&#39;#content&#39;)</code>来返回一个Python列表</p>
<p>想用BeautifulSoup来解析网页内容，可以用driver.page_source返回页面的源代码字符串</p>
<p>隐式等待时等DOM中某个状态发生后再继续运行代码。可捕获TimeoutException</p>
<p>触发的期望条件有4种。大多数期望条件在使用前都需要你先指定等待的目标元素。元素用定位器指定。定位器与选择器是不一样的。定位器是一种抽象的查询语言，用By对象表示，可以用于不同的场合，包括创建选择器。By的策略包括：</p>
<ul>
<li>IF</li>
<li>CLASS_NAME</li>
<li>CSS_SELECTOR</li>
<li>LINK_TEXT：通过链接文字查找<code>&lt;a&gt;</code>标签</li>
<li>PARTIAL_LINK_TEXT：只通过部分链接文字查找</li>
<li>NAME</li>
<li>TAG_NAME</li>
<li>XPATH</li>
</ul>
<h4 id="11-2-2-webdriver-Firefox"><a href="#11-2-2-webdriver-Firefox" class="headerlink" title="11.2.2 webdriver.Firefox"></a>11.2.2 webdriver.Firefox</h4><h3 id="11-3-处理重定向"><a href="#11-3-处理重定向" class="headerlink" title="11.3 处理重定向"></a>11.3 处理重定向</h3><ul>
<li>服务器端重定向可以轻松地通过urllib库解决</li>
<li>客户端重定向的主要问题是什么时候停止页面执行。</li>
</ul>
<p>检测客户端重定向是否已完成的智能方法：从页面开始加载时就监视DOM中的一个元素，然后重复调用这个元素，直到抛出StaleElementReferenceException异常。</p>
<p>等待元素的出现和消失是Selenium中一个常见的任务</p>
<h3 id="11-4-如果你仍然难以应对某种复杂的JavaScript情形，可以到第15章查找关于Selenium以及直接与动态网站交互的信息。"><a href="#11-4-如果你仍然难以应对某种复杂的JavaScript情形，可以到第15章查找关于Selenium以及直接与动态网站交互的信息。" class="headerlink" title="11.4 如果你仍然难以应对某种复杂的JavaScript情形，可以到第15章查找关于Selenium以及直接与动态网站交互的信息。"></a>11.4 如果你仍然难以应对某种复杂的JavaScript情形，可以到第15章查找关于Selenium以及直接与动态网站交互的信息。</h3><h1 id="ch14-避开抓取陷阱"><a href="#ch14-避开抓取陷阱" class="headerlink" title="ch14 避开抓取陷阱"></a>ch14 避开抓取陷阱</h1><h3 id="14-2-让网络机器人看着像人类用户"><a href="#14-2-让网络机器人看着像人类用户" class="headerlink" title="14.2 让网络机器人看着像人类用户"></a>14.2 让网络机器人看着像人类用户</h3><h4 id="14-2-1-修改请求头"><a href="#14-2-1-修改请求头" class="headerlink" title="14.2.1 修改请求头"></a>14.2.1 修改请求头</h4><p>参考ch10</p>
<p>经典的Python爬虫在使用urllib时，都会发送如下的请求头<code>User-Agent=Python-urllib/3.4</code></p>
<h4 id="14-2-2-用JavaScript处理cookie"><a href="#14-2-2-用JavaScript处理cookie" class="headerlink" title="14.2.2 用JavaScript处理cookie"></a>14.2.2 用JavaScript处理cookie</h4><h4 id="14-2-3-时间就是一切"><a href="#14-2-3-时间就是一切" class="headerlink" title="14.2.3 时间就是一切"></a>14.2.3 时间就是一切</h4><h3 id="14-3-常见表单安全措施"><a href="#14-3-常见表单安全措施" class="headerlink" title="14.3 常见表单安全措施"></a>14.3 常见表单安全措施</h3><h3 id="14-4-问题检查表"><a href="#14-4-问题检查表" class="headerlink" title="14.4 问题检查表"></a>14.4 问题检查表</h3><ul>
<li>如果收到的页面是空白的或与浏览器上看到的不一样，有可能是因为JavaScript执行有问题。</li>
<li>POST请求要检查字段和格式是否正确</li>
<li>无法保持登录状态，请检查你的cookie</li>
<li>遇到HTTP错误，尤其是403禁止访问错误，这可能说明网站已经把你的IP地址当做机器人了。你要么等待，要么换个IP地址（可以去星巴克上网，或者看看第17章的内容）。为了确保不会再次被封杀，请做到以下几点：<ul>
<li>给爬虫增加延迟，让它们在夜深人静的时候运行</li>
<li>修改请求头</li>
<li>确认你没有点击或访问任何人类用户通常不能点击或访问的信息</li>
<li>联系网管</li>
</ul>
</li>
</ul>
<h3 id="15-3-Selenium-单元测试"><a href="#15-3-Selenium-单元测试" class="headerlink" title="15.3 Selenium 单元测试"></a>15.3 Selenium 单元测试</h3><p>Selenium可以对任何给定元素执行很多操作：click,click_and_hold,release,double_click,send_keys_to_element</p>
<p>除了一次性完成一个元素的多个操作，还可以将一组操作组合成一个动作链</p>
<h4 id="拖放与截屏"><a href="#拖放与截屏" class="headerlink" title="拖放与截屏"></a>拖放与截屏</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/05/web-scraping-with-python/" data-id="cl310rf3v0014gctk1kpl02tk" data-title="《python网络爬虫权威指南》读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-jing-tong-git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/29/jing-tong-git/" class="article-date">
  <time class="dt-published" datetime="2021-04-29T13:33:37.000Z" itemprop="datePublished">2021-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/book-note/">book-note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/29/jing-tong-git/">《精通git》读书笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="3-5-远程分支"><a href="#3-5-远程分支" class="headerlink" title="3.5 远程分支"></a>3.5 远程分支</h2><p>远程分支是指针，存在于本地且<strong>无法被移动</strong>。当你与服务器进行网络通信时，它们会自动更新。远程分支有点像书签，它们会提示你上一次连接服务器时远程仓库中每个分支的位置。</p>
<p>git fetch会更新远程分支指针</p>
<h3 id="3-5-1-推送"><a href="#3-5-1-推送" class="headerlink" title="3.5.1 推送"></a>3.5.1 推送</h3><p><code>git push origin serverfix</code>实际上是<code>git push origin refs/heads/serverfix:refs/heads/serverfix</code></p>
<p>如果不想每次推送时都键入密码，可以设置一个凭据缓存（credential cache）。请参阅<a href="#7-14-%E5%87%AD%E6%8D%AE%E5%AD%98%E5%82%A8">7.14节</a></p>
<p>上游分支的简单写法：如果你已经设置好了上游分支，就可以通过@{u}来使用。例如在master上用<code>git merge @&#123;u&#125;</code>来代替<code>git merge origin/master</code></p>
<p><code>git branch -vv</code>列出每个分支的名字及其跟踪的远程分支信息，以及领先或落后的信息。要注意的是，这条命令和<code>git status</code>都不会与服务器通信以获取最新信息。</p>
<h3 id="3-5-4-删除远程分支：git-push-origin-delete-serverfix"><a href="#3-5-4-删除远程分支：git-push-origin-delete-serverfix" class="headerlink" title="3.5.4 删除远程分支：git push origin --delete serverfix"></a>3.5.4 删除远程分支：<code>git push origin --delete serverfix</code></h3><h2 id="3-6-变基"><a href="#3-6-变基" class="headerlink" title="3.6 变基"></a>3.6 变基</h2><h3 id="3-6-1-变基的工作原理"><a href="#3-6-1-变基的工作原理" class="headerlink" title="3.6.1 变基的工作原理"></a>3.6.1 变基的工作原理</h3><ol>
<li>找到共同祖先</li>
<li>取得每次提交引入的更改（diff）</li>
<li>依次引入更改  </li>
</ol>
<h1 id="ch04"><a href="#ch04" class="headerlink" title="ch04"></a>ch04</h1><p>如果你对自己运行Git服务器不感兴趣，可以跳过本章的前面几节，直接阅读4.9节。</p>
<h2 id="4-1-协议"><a href="#4-1-协议" class="headerlink" title="4.1 协议"></a>4.1 协议</h2><h3 id="4-1-1-本地协议"><a href="#4-1-1-本地协议" class="headerlink" title="4.1.1 本地协议"></a>4.1.1 本地协议</h3><p>使用file://前缀的主要原因是希望取出仓库中的外部引用或多余对象。</p>
<h3 id="4-1-2-HTTP协议"><a href="#4-1-2-HTTP协议" class="headerlink" title="4.1.2 HTTP协议"></a>4.1.2 HTTP协议</h3><p>智能HTTP协议最普遍。既支持匿名访问，也支持用户验证。</p>
<h3 id="4-1-3-SSH协议"><a href="#4-1-3-SSH协议" class="headerlink" title="4.1.3 SSH协议"></a>4.1.3 SSH协议</h3><p>SSH不能实现匿名访问</p>
<h3 id="4-1-4-Git协议"><a href="#4-1-4-Git协议" class="headerlink" title="4.1.4 Git协议"></a>4.1.4 Git协议</h3><p>Git协议不提供任何身份验证方式</p>
<h1 id="ch05"><a href="#ch05" class="headerlink" title="ch05"></a>ch05</h1><h2 id="5-1-分布式工作流"><a href="#5-1-分布式工作流" class="headerlink" title="5.1 分布式工作流"></a>5.1 分布式工作流</h2><h3 id="5-1-1-集中式工作流"><a href="#5-1-1-集中式工作流" class="headerlink" title="5.1.1 集中式工作流"></a>5.1.1 集中式工作流</h3><p>中枢接受代码，所有人以此同步各自的工作</p>
<h3 id="5-1-2-集成管理者工作流"><a href="#5-1-2-集成管理者工作流" class="headerlink" title="5.1.2 集成管理者工作流"></a>5.1.2 集成管理者工作流</h3><p>开发人员fork，继承管理者处理pull request</p>
<h3 id="5-1-3-司令官与副官工作流"><a href="#5-1-3-司令官与副官工作流" class="headerlink" title="5.1.3 司令官与副官工作流"></a>5.1.3 司令官与副官工作流</h3><p>用于Linux内核等等超大型项目或高度层次化环境。</p>
<h2 id="5-2-为项目做贡献"><a href="#5-2-为项目做贡献" class="headerlink" title="5.2 为项目做贡献"></a>5.2 为项目做贡献</h2><h3 id="5-2-1-提交准则"><a href="#5-2-1-提交准则" class="headerlink" title="5.2.1 提交准则"></a>5.2.1 提交准则</h3><p>提交之前执行<code>git diff --check</code>列出可能存在的空白字符错误</p>
<p>提交消息的第一行不应该超过50个字符</p>
<h3 id="5-2-4-用rebase-i将工作内容压缩成单个提交可能会方便维护人员评审补丁。7-6节会对交互式变基做更详尽的介绍。"><a href="#5-2-4-用rebase-i将工作内容压缩成单个提交可能会方便维护人员评审补丁。7-6节会对交互式变基做更详尽的介绍。" class="headerlink" title="5.2.4 用rebase -i将工作内容压缩成单个提交可能会方便维护人员评审补丁。7.6节会对交互式变基做更详尽的介绍。"></a>5.2.4 用<code>rebase -i</code>将工作内容压缩成单个提交可能会方便维护人员评审补丁。7.6节会对交互式变基做更详尽的介绍。</h3><h3 id="5-2-5-用git-format-patch来生成要通过电子邮件发送的mbox格式的文件"><a href="#5-2-5-用git-format-patch来生成要通过电子邮件发送的mbox格式的文件" class="headerlink" title="5.2.5 用git format-patch来生成要通过电子邮件发送的mbox格式的文件"></a>5.2.5 用<code>git format-patch</code>来生成要通过电子邮件发送的mbox格式的文件</h3><p>用<code>git send-email</code>之前需要配置</p>
<h3 id="5-3-4-确定引入内容"><a href="#5-3-4-确定引入内容" class="headerlink" title="5.3.4 确定引入内容"></a>5.3.4 确定引入内容</h3><p><a href="#7-1-%E9%80%89%E6%8B%A9%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC">CF:7.1 选择修订版本</a><br>双点语法：<code>git log master..contrib</code>显示在contrib中但不在master中的提交<br>三点语法：<code>git diff master...contrib</code>显示contrib与master分岔后的diff</p>
<h3 id="5-3-5-大型合并工作流"><a href="#5-3-5-大型合并工作流" class="headerlink" title="5.3.5 大型合并工作流"></a>5.3.5 大型合并工作流</h3><p>将主题分支合并到next并推送共享，如果主题分支仍需改进则合并到pu分支，稳定下来后重新和并入master。这意味着master始终快近，next偶尔变基，pu频繁变基。maint用于提供向后移植补丁。</p>
<h3 id="5-3-9-汇总自上次v1-1-1之后所有提交：git-shortlog-no-merges-master-not-v1-1-1"><a href="#5-3-9-汇总自上次v1-1-1之后所有提交：git-shortlog-no-merges-master-not-v1-1-1" class="headerlink" title="5.3.9 汇总自上次v1.1.1之后所有提交：git shortlog --no-merges master --not v1.1.1"></a>5.3.9 汇总自上次v1.1.1之后所有提交：<code>git shortlog --no-merges master --not v1.1.1</code></h3><h1 id="ch06"><a href="#ch06" class="headerlink" title="ch06"></a>ch06</h1><h3 id="6-3-2-添加协作人员：Collaborators"><a href="#6-3-2-添加协作人员：Collaborators" class="headerlink" title="6.3.2 添加协作人员：Collaborators"></a>6.3.2 添加协作人员：Collaborators</h3><h2 id="6-5-GitHub脚本化"><a href="#6-5-GitHub脚本化" class="headerlink" title="6.5 GitHub脚本化"></a>6.5 GitHub脚本化</h2><h3 id="6-5-1-钩子系统"><a href="#6-5-1-钩子系统" class="headerlink" title="6.5.1 钩子系统"></a>6.5.1 钩子系统</h3><h3 id="6-5-2-GitHub-API"><a href="#6-5-2-GitHub-API" class="headerlink" title="6.5.2 GitHub API"></a>6.5.2 GitHub API</h3><h1 id="ch07"><a href="#ch07" class="headerlink" title="ch07"></a>ch07</h1><h2 id="7-1-选择修订版本"><a href="#7-1-选择修订版本" class="headerlink" title="7.1 选择修订版本"></a>7.1 选择修订版本</h2><h3 id="git-log-left-right-master-experiment可以显示出提交属于哪一侧的分支。CF-5-3-4-确定引入内容"><a href="#git-log-left-right-master-experiment可以显示出提交属于哪一侧的分支。CF-5-3-4-确定引入内容" class="headerlink" title="git log --left-right master...experiment可以显示出提交属于哪一侧的分支。CF:5.3.4 确定引入内容"></a><code>git log --left-right master...experiment</code>可以显示出提交属于哪一侧的分支。<a href="#5-3-4-%E7%A1%AE%E5%AE%9A%E5%BC%95%E5%85%A5%E5%86%85%E5%AE%B9">CF:5.3.4 确定引入内容</a></h3><h2 id="7-3-储藏"><a href="#7-3-储藏" class="headerlink" title="7.3 储藏"></a>7.3 储藏</h2><h3 id="7-3-3-从储藏中创建分支：git-stash-branch-新分支名"><a href="#7-3-3-从储藏中创建分支：git-stash-branch-新分支名" class="headerlink" title="7.3.3 从储藏中创建分支：git stash branch 新分支名"></a>7.3.3 从储藏中创建分支：<code>git stash branch 新分支名</code></h3><h3 id="清理工作目录"><a href="#清理工作目录" class="headerlink" title="清理工作目录"></a>清理工作目录</h3><p><code>git stash -all</code>以储藏形式保存全部内容<br><code>git clean -n</code>做一次删除的演习<br><code>git clean -f</code>进行实际删除</p>
<h2 id="7-5-搜索"><a href="#7-5-搜索" class="headerlink" title="7.5 搜索"></a>7.5 搜索</h2><h3 id="7-5-1-工作目录搜索"><a href="#7-5-1-工作目录搜索" class="headerlink" title="7.5.1 工作目录搜索"></a>7.5.1 工作目录搜索</h3><p><code>git grep 模式</code>默认只查找工作目录下的文件</p>
<p><code>git grep --count 模式</code>输出总结信息：每个匹配的文件中有多少处匹配</p>
<p><code>git grep -p 模式</code>显示所查找到的匹配属于哪个方法或函数</p>
<p>还可以使用–and选项来查找复杂的字符串组合</p>
<h3 id="7-5-2-日志搜索"><a href="#7-5-2-日志搜索" class="headerlink" title="7.5.2 日志搜索"></a>7.5.2 日志搜索</h3><p><code>git log -S 字符串</code>显示出添加过或删除过该字符串的那些提交</p>
<p><code>git log -G 模式</code>等同于-S但使用正则表达式进行模式匹配</p>
<p><code>git log -L 模式:文件</code>显示所有匹配的改动记录</p>
<h2 id="7-6-重写历史"><a href="#7-6-重写历史" class="headerlink" title="7.6 重写历史"></a>7.6 重写历史</h2><h3 id="7-6-3-重排提交：在交互式变基中改变行的顺序"><a href="#7-6-3-重排提交：在交互式变基中改变行的顺序" class="headerlink" title="7.6.3 重排提交：在交互式变基中改变行的顺序"></a>7.6.3 重排提交：在交互式变基中改变行的顺序</h3><h3 id="7-6-4-压缩提交：在交互式变基中用squash"><a href="#7-6-4-压缩提交：在交互式变基中用squash" class="headerlink" title="7.6.4 压缩提交：在交互式变基中用squash"></a>7.6.4 压缩提交：在交互式变基中用squash</h3><h3 id="7-6-5-拆分提交：在交互式变基中用edit"><a href="#7-6-5-拆分提交：在交互式变基中用edit" class="headerlink" title="7.6.5 拆分提交：在交互式变基中用edit"></a>7.6.5 拆分提交：在交互式变基中用edit</h3><h3 id="7-6-6-超强命令：filter-branch"><a href="#7-6-6-超强命令：filter-branch" class="headerlink" title="7.6.6 超强命令：filter-branch"></a>7.6.6 超强命令：filter-branch</h3><ol>
<li>从所有提交中删除某个文件：<code>git filter-branch --tree-filter &#39;rm -f 文件&#39; HEAD</code>。要想在所有分支上执行filter-branch，可以传入–all选项</li>
<li>将子目录设置为新的根目录：<code>git filter-branch --subdirectory-filter 目录 HEAD</code></li>
<li>全面修改邮件地址：利用shell中的if语句配合GIT_AUTHOR环境变量</li>
</ol>
<h2 id="7-7-重置揭秘：reset和checkout"><a href="#7-7-重置揭秘：reset和checkout" class="headerlink" title="7.7 重置揭秘：reset和checkout"></a>7.7 重置揭秘：reset和checkout</h2><h3 id="7-7-5-要压缩最新的几个提交，只需git-reset-soft-旧提交然后commit"><a href="#7-7-5-要压缩最新的几个提交，只需git-reset-soft-旧提交然后commit" class="headerlink" title="7.7.5 要压缩最新的几个提交，只需git reset --soft 旧提交然后commit"></a>7.7.5 要压缩最新的几个提交，只需<code>git reset --soft 旧提交</code>然后commit</h3><h3 id="7-7-7-文件级别与提交级别"><a href="#7-7-7-文件级别与提交级别" class="headerlink" title="7.7.7 文件级别与提交级别"></a>7.7.7 文件级别与提交级别</h3><p>|            |索引|工作目录|覆盖是否安全|<br>|提交级别||||<br>|reset –soft COMMIT    ||||<br>|reset –mixed COMMIT<br>|reset –hard COMMIT<br>|checkout COMMIT<br>|文件级别||||<br>|reset COMMIT FILE<br>|checkout COMMIT FILE    </p>
<h3 id="7-8-1-合并冲突"><a href="#7-8-1-合并冲突" class="headerlink" title="7.8.1 合并冲突"></a>7.8.1 合并冲突</h3><p><code>git mrege -Xignore-all-space</code>忽略空白字符的变更</p>
<p><code>git checkout --conflict=diff3 冲突文件名</code>在冲突标记中提供内嵌的base版本</p>
<p><code>git checkout</code>还可以接受–ours和–theirs作为选项，这是一种只选择其中一侧的快速方法。</p>
<h3 id="7-8-2-还原提交"><a href="#7-8-2-还原提交" class="headerlink" title="7.8.2 还原提交"></a>7.8.2 还原提交</h3><p>对合并提交执行<code>git revert</code>需要用-m选项指明要还原哪个父节点引入的扁钢</p>
<p>如果使用<code>git revert -m 1 HEAD</code>来抵消合并，会影响这两个分支以后的合并基础</p>
<h3 id="7-8-3-Xours与-s-ours"><a href="#7-8-3-Xours与-s-ours" class="headerlink" title="7.8.3 -Xours与-s ours"></a>7.8.3 <code>-Xours</code>与<code>-s ours</code></h3><p>给merge传入-Xours或-Xtheirs选项就不再添加冲突标记。任何能够合并的差异，Git会选择合并。任何有冲突的差异，Git会简单地选择你所指定的那一侧。</p>
<p>更严格的策略是<code>-s ours</code>。这个方法基本上做的是一次假合并。它会记录一个</p>
<h4 id="读完ch10回来看子树合并"><a href="#读完ch10回来看子树合并" class="headerlink" title="读完ch10回来看子树合并"></a>读完ch10回来看子树合并</h4><h2 id="7-9-rerere"><a href="#7-9-rerere" class="headerlink" title="7.9 rerere"></a>7.9 rerere</h2><p>在有些情况下，重用冲突解决方案相当方便。例如：</p>
<ul>
<li>想确保一个长期的topic分支能够干净地合并，但又不想要一堆用于<strong>中间阶段</strong>的合并提交。你可以启动rerere功能，偶尔进行合并、解决冲突、<strong>然后退出合并</strong>。如果你一直这么做，那么最终的合并应该会很容易。变基也同理</li>
<li>选用一个已合并的分支，修复了一堆冲突后决定对其进行变基操作，这样你可能就不必再去解决同样的冲突了。</li>
<li>偶尔将多个尚在改进的topic分支合并到一个可测试的头部。如果测试失败，你可以返回合并之前，不使用导致失败的topic分支，然后再次合并，无需再次重新解决冲突。</li>
</ul>
<h2 id="7-10-使用Git调试"><a href="#7-10-使用Git调试" class="headerlink" title="7.10 使用Git调试"></a>7.10 使用Git调试</h2><h3 id="7-10-1-文件标注"><a href="#7-10-1-文件标注" class="headerlink" title="7.10.1  文件标注"></a>7.10.1  文件标注</h3><p><code>git blame -L 起始行,结束行 文件</code>查看每一行的最后一次修改者和修改时间</p>
<p>加入-C参数要求Git找出代码移动的原始出处</p>
<h3 id="7-10-2-git-bisect帮助尽快确定问题是由那、哪一次提交引发的"><a href="#7-10-2-git-bisect帮助尽快确定问题是由那、哪一次提交引发的" class="headerlink" title="7.10.2 git bisect帮助尽快确定问题是由那、哪一次提交引发的"></a>7.10.2 <code>git bisect</code>帮助尽快确定问题是由那、哪一次提交引发的</h3><h2 id="7-11-子模块"><a href="#7-11-子模块" class="headerlink" title="7.11 子模块"></a>7.11 子模块</h2><h2 id="7-12-打包bundle"><a href="#7-12-打包bundle" class="headerlink" title="7.12 打包bundle"></a>7.12 打包bundle</h2><h2 id="7-13-替换：历史记录拆分后可用replace重新嫁接"><a href="#7-13-替换：历史记录拆分后可用replace重新嫁接" class="headerlink" title="7.13 替换：历史记录拆分后可用replace重新嫁接"></a>7.13 替换：历史记录拆分后可用replace重新嫁接</h2><h2 id="7-14-凭据存储"><a href="#7-14-凭据存储" class="headerlink" title="7.14 凭据存储"></a>7.14 凭据存储</h2><p><code>git config --global credential.helper cache --timeout 900</code>设置将凭据保存在内存中15分钟</p>
<p><code>git config --global credential.helper store --file 路径</code>设置将凭据保存在硬盘</p>
<h1 id="ch08-自定义Git"><a href="#ch08-自定义Git" class="headerlink" title="ch08 自定义Git"></a>ch08 自定义Git</h1><h2 id="8-1-配置Git"><a href="#8-1-配置Git" class="headerlink" title="8.1 配置Git"></a>8.1 配置Git</h2><h3 id="8-1-1-基本配置"><a href="#8-1-1-基本配置" class="headerlink" title="8.1.1 基本配置"></a>8.1.1 基本配置</h3><p><code>git config --global commit.template ~/.gitmessage.txt</code>设置默认的提交消息占位符</p>
<h3 id="8-1-3-外部的合并与diff工具"><a href="#8-1-3-外部的合并与diff工具" class="headerlink" title="8.1.3 外部的合并与diff工具"></a>8.1.3 外部的合并与diff工具</h3><p><code>git config --global merge.tool kdiff3</code></p>
<h3 id="8-1-4-格式化与空白字符"><a href="#8-1-4-格式化与空白字符" class="headerlink" title="8.1.4 格式化与空白字符"></a>8.1.4 格式化与空白字符</h3><ol>
<li>core.autocrlf 处理行终止符。win适合把它置为true，unix适合把它置为input。</li>
<li>core.whitespace 用于检测、修正与空白字符相关的问题</li>
</ol>
<ul>
<li>（默认）blank-at-eol 会查找行尾的空格</li>
<li>（默认）blank-at-eof 会查看文件末尾的空行</li>
<li>（默认）space-before-tab 会查找行首制表符之前的空格</li>
</ul>
<ol start="3">
<li>如果提交了存在空白字符问题的文件，可以执行<code>git rebase --whitespace=fix</code>自动修复</li>
</ol>
<h2 id="8-2-Git属性"><a href="#8-2-Git属性" class="headerlink" title="8.2 Git属性"></a>8.2 Git属性</h2><p>针对路径的配置被称为Git属性</p>
<h3 id="8-2-1-二进制文件"><a href="#8-2-1-二进制文件" class="headerlink" title="8.2.1 二进制文件"></a>8.2.1 二进制文件</h3><ol>
<li><code>*.pbxproj binary</code>告诉Git把<code>*.pbxproj</code>当做二进制文件来处理</li>
<li>比较二进制文件</li>
</ol>
<ul>
<li><code>*.docx diff=word</code>配合<code>git config diff.word.textconv docx2txt</code>可比较word文件的文字改动</li>
</ul>
<ol>
<li><code>*.png diff=exif</code>配合<code>git config diff.exif.textconv exiftool</code>可比较图像的元信息<h3 id="8-2-2-关键字扩展"><a href="#8-2-2-关键字扩展" class="headerlink" title="8.2.2 关键字扩展"></a>8.2.2 关键字扩展</h3></li>
<li><code>*.txt ident</code>让Git在检出时将blob对象的SHA-1写入$Id$字段。用途有限</li>
<li>编写自己的smudge和clean</li>
</ol>
<p><a href="#%E8%AF%BB%E5%AE%8Cch10%E5%9B%9E%E6%9D%A5%E7%9C%8B%E5%AD%90%E6%A0%91%E5%90%88%E5%B9%B6">读完ch10回来看子树合并</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/29/jing-tong-git/" data-id="cl310rf3j000pgctkfu7cbb4w" data-title="《精通git》读书笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-xuan-ze-yi-sheng" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/xuan-ze-yi-sheng/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T08:28:22.000Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/health/">health</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/xuan-ze-yi-sheng/">就医：怎么选医生</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>来自：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32003134/answer/54207863">如何做一个聪明的病人高效率地看病</a><br>是不是都要看最贵最老的专家？<br>答：错。 如果你只是一些普通的常见病，其实主治医师水平完全绰绰有余了，如果是疑难杂症，那一定要看老专家和老教授，如果你不知道什么情况，在能尽快就医的前提下，选择最快能见到医生的那种（排队最少）最合适。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59191241">去医院看病劳心又劳力，是因为你不知道这些常识</a></p>
<p>普通号，专家号，专科门诊，如何选择？</p>
<p>初诊不需要挂专家号</p>
<p>其实挂号要把握以下三个原则！</p>
<p>初次就诊——普通号</p>
<p>多数情况下，西医是不会只凭主诉和症状就开始治疗的，基本都会参照生化指标和影像资料。</p>
<p>主任和主治开的化验单没什么区别；做检查，正规医院的实验室结果互相承认。所以，你可以先挂个好挂的号，做完检查后，再决定是不是要到上级医院找专家。</p>
<p>因此，此时即便挂到知名专家的号，知名专家能做的与一名主治医师（看普通号的医生）做的是一样的——为患者开具一系列化验检查申请单，嘱咐患者等检查结果出来以后再来复诊。</p>
<p>看疑难杂症——专家号</p>
<p>一些患者的病确属疑难杂症，在多家医院就诊后仍然不能确诊。这些患者往往辗转很多地方的多家医院，化验单、检查单、病历都是厚厚一叠，但疾病仍没有定性。这时，患者才需要找主任医师级别，甚至知名专家看病，以便尽快确诊（初次就诊还是要看普通门诊）。</p>
<p>有慢性病——专业门诊</p>
<p>对于一些常见病、慢性病可以考虑看专业门诊。现在很多医院都开设了专病专业门诊，例如脂肪肝专病门诊、腹膜透析专病门诊、糖尿病门诊、盆底疾病门诊、高血压门诊等。患者可以根据自己确诊的疾病名称，对号入座来挂号。</p>
<p>来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59191241">去医院看病劳心又劳力，是因为你不知道这些常识</a></p>
<p>是否需要找同一个医生来看？</p>
<p>同一个医生对你的病情更加了解，在治疗方案的制定上会有延续性，这是很好的。所以一般推荐能固定找一个医生就诊，记住他的出诊时间。一般是不会变化的，每次都可以找他复查。</p>
<p>但是，对于初次就诊的病人，就没有必要那么纠结。比如第一次就诊医生让拍片，拍完片子结果出来，已经是第二天了。如果再等之前的医生，可能需要下周。其实西医的优势就在于标准化，除非疑难杂症，一般的检查结果不同医生都会给出标准化的方案，所以不用担心。</p>
<h2 id="以上为经过整理的主题笔记"><a href="#以上为经过整理的主题笔记" class="headerlink" title="以上为经过整理的主题笔记"></a>以上为经过整理的主题笔记</h2><p>以下为概念笔记</p>
<h2 id="来自：在中国，如何找到靠谱的医生？"><a href="#来自：在中国，如何找到靠谱的医生？" class="headerlink" title="来自：在中国，如何找到靠谱的医生？"></a>来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33767386">在中国，如何找到靠谱的医生？</a></h2><ol>
<li>你想去挂某医院的号，又恰好有关系密切的亲戚或朋友在该院上班的话，直接咨询他们；</li>
<li>没有1的关系的话，建议优先考虑医学院的附属医院；</li>
<li>不要盲从大牛，在没有其他限定条件的情况下，我个人比较推荐40岁左右的女医生，她们相对来说会给你更多的沟通时间，对于临床指南的遵循也会更严格。</li>
</ol>
<h2 id="来自：去医院看病是挂普通医生还是副主任的号？哪个更好些呢？"><a href="#来自：去医院看病是挂普通医生还是副主任的号？哪个更好些呢？" class="headerlink" title="来自：去医院看病是挂普通医生还是副主任的号？哪个更好些呢？"></a>来自：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/316091718/answer/1196379761">去医院看病是挂普通医生还是副主任的号？哪个更好些呢？</a></h2><p>如果是“感冒”，那么找我，或者找一名主治医师，或者找一名规培医生，甚至没找医生看，差别都不是太大。</p>
<p>有人会说，“感冒”也可能出现其他变化，成为重症，甚至危及生命的。</p>
<p>是的，你说得对，不过，正常情况下，在疾病早期，医生一般也预计不到。因为我们是医生，不是算命的，更不是神。</p>
<p>当然，做了这么多年医生，还是有点经验，对于某些领域，也有那么一点点研究，对于某些问题，和其他医生比较起来，或许是有那么点差别，这也足够让我们沾沾自喜了。</p>
<p>不过，作为患者，你知道我的优势在哪里吗？</p>
<p>或许，医院也会有点介绍，有点宣传，不过，他们介绍、宣传的领域往往是我论文写得多、写得好的领域，与我会不会看病，不一定有多大关系。</p>
<p>个人认为，年龄40岁左右，三级医院，临床上呆得久、摸爬滚打过的，不是一直在做实验写论文的医生，看病多半是靠谱的，但我也不敢绝对说，毕竟自己对别人也不了解。</p>
<p>因为，太年轻的，经验欠缺一点，太年长的，在接受新知识上，和年轻人比，稍落后一些。</p>
<p>还有一个办法就是看他在医院内部的口碑，如果医院内部的医护或家属都找他看，那这个医生多半是靠谱的。不过这是内部机密，外面的人一般了解不到。</p>
<h2 id="来自：预约挂号有哪些技巧"><a href="#来自：预约挂号有哪些技巧" class="headerlink" title="来自：预约挂号有哪些技巧"></a>来自：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24120162/answer/30973665">预约挂号有哪些技巧</a></h2><p>第一，如果只是感觉到不舒服，没有做任何检查直接去看门诊，不用挂专家号。在 绝大多数情况下，西医是不会只凭主诉和症状就诊断、开药的，基本都会参照生化和影像的资料。所以，首次挂号后医生听完你的症状，一般是会开单子让你做检 查，检查结果出来后再挂号让医生诊断治疗的。开检查单，专家和主治没什么区别，所以你大可以先随便挂个好挂的号，做完检查后拿到检查结果，再决定是不是要 看专家，把精力和金钱用在最关键的地方。</p>
<p>第二， 要选择对的专家。很多人的做法是，打听好自己要看的科室在哪家医院最好，然后挂该科室主任、副主任或者院士的号。这么做是非常错误的。首先，现在医学方向 分得很细，像我们肝胆科都已经是普外的分支了，但科里每个医生也有主攻方向，有主攻肝癌的，有主攻以胰腺炎的，有主攻胆囊切除的，再大的专家，在自己的非 主攻方向也谈不上权威。另外，主任和院士肯定是在学术上很有造诣的，但有了这些行政和学术职务，意味着他会投入更多精力在管理、开会、带学生、发文章这些 事情上，留给门诊的精力不一定比那些年富力强的年轻教授多。所以挂号前还是要多做些功课，找符合自己方向的、四五十岁的、患者口碑好的专家挂。</p>
<p>第三，挂号这件事本身确实没有技巧，拼的是体力和人品。网上预约挂号和自助机挂号，都是提前7天起挂，所以算好时间跑去挂就好了。人肉排队一般是提前一天或当天挂，有体力的可以去排队跟黄牛拼一下。提醒一点大家可能会忽略的，多数专家都会出两种门诊，普通门诊和特需门诊，普通门诊就是14块的那种，特需门诊挂号费高一些（一两百），也不能走医保，或许会排除掉一些人去抢，所以如果不介意价格，挂普通号的时候不妨同时尝试一下特需。</p>
<p>第四，对于挂不到号的，我推荐的首选方式是在门诊当天快要结束的时候找专家加号。我 说过闯空门是无效的，但专家写个条子拿到挂号处，是可以把你加到挂号系统里的。不过，加号是充满变数的，成功与否取决于几方面：一，专家中午不算太饿不尿 急下午没有手术；二，专家属于愿意加号的性格，同时当天心情不错；三，也是决定性的一点，病情符合专家的方向且比较复杂能够体现出他的价值。前两点是不可 控因素，第三点就要取决于病人或家属的口才了。不要一进来就哭诉自己有多可怜，要冷静理智地把病情用简单几句话介绍清楚，突出复杂性，让专家对患者产生兴 趣。另外，特需门诊加号的成功率比普通门诊高一些，因为普通门诊一上午3个小时20个号，分给每个患者的时间最多只有9分钟，稍微有人一拖拉就过点了。而特需一上午只有10个号，专家的时间比较充裕，心情也舒畅一些。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/28/xuan-ze-yi-sheng/" data-id="cl310rf46001hgctk42dr9cx0" data-title="就医：怎么选医生" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-content-jiu-yi" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/content-jiu-yi/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T08:18:22.000Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/health/">health</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/content-jiu-yi/">目录：知乎话题精华“就医”</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>就医前</li>
</ol>
<ul>
<li><a href="/2021/04/28/na-xie-zheng-zhuang-yao-jiu-yi/">该不该就医</a></li>
<li><a href="/2021/04/28/xuan-ze-kan-bing-shi-jian/">选看病时间</a></li>
<li><a href="/2021/04/21/2021-04-21-xuan-ze-yi-yuan/">选医院</a></li>
<li><a href="/2021/04/07/2021-04-07-gua-hao-ke-shi/">选科室</a></li>
<li><a href="/2021/04/28/xuan-ze-yi-sheng/">选医生</a></li>
<li><a href="/2021/04/28/kan-bing-qian-zhun-bei/">看病前要做的其他准备</a></li>
</ul>
<ol>
<li>就医时</li>
</ol>
<ul>
<li><a href="/2021/04/28/miao-shu-bing-qing/">描述病情</a></li>
</ul>
<ol>
<li>其他</li>
</ol>
<ul>
<li><a href="/2021/04/22/2021-04-22-jiu-yi/">与住院有关的常见问题</a></li>
<li><a href="/2021/04/21/2021-04-21-yi-xue-ke-pu/">医学科普</a></li>
<li><a href="/2021/04/22/2021-04-22-kan-bing-chang-shi/">看病常识</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/28/content-jiu-yi/" data-id="cl310rf3a000igctkhvcghacj" data-title="目录：知乎话题精华“就医”" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/bao-xian/">bao-xian</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/book-note/">book-note</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/health/">health</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/humor/">humor</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/jekyll-update/">jekyll update</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1021/04/">April 1021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/10/high-availability-linux/">《构建高可用Linux服务器》读书笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/21/mysql-ji-shu-nei-mu/">《mysql技术内幕》读书笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/19/ubuntu-linux-os/">Ubuntu相关读书笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/07/shell-program-demo/">shell例程</a>
          </li>
        
          <li>
            <a href="/2021/07/06/unix-bian-cheng-yi-shu/">《UNIX编程艺术》读书笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>